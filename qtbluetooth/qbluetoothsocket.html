<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qbluetoothsocket.cpp -->
  <meta name="description" content="The QBluetoothSocket class enables connection to a Bluetooth device running a bluetooth server.">
  <title>QBluetoothSocket Class | Qt Bluetooth 6.6.2</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.6</a></li>
<li><a href="qtbluetooth-index.html" translate="no">Qt Bluetooth</a></li>
<li><a href="qtbluetooth-module.html" translate="no">C++ Classes</a></li>
<li>QBluetoothSocket</li>
<li id="buildversion"><a href="qtbluetooth-index.html" translate="no">Qt 6.6.2 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#reimplemented-public-functions">Reimplemented Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">Reimplemented Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QBluetoothSocket Class</h1>
<!-- $$$QBluetoothSocket-brief -->
<p>The QBluetoothSocket class enables connection to a Bluetooth device running a bluetooth server. <a href="#details">More...</a></p>
<!-- @@@QBluetoothSocket -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QBluetoothSocket&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += bluetooth</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qiodevice.html" translate="no">QIODevice</a></td></tr>
</table></div>
<ul>
<li><a href="qbluetoothsocket-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum class </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#SocketError-enum" translate="no">SocketError</a></b> { UnknownSocketError, NoSocketError, HostNotFoundError, ServiceNotFoundError, NetworkError, &hellip;, MissingPermissionsError }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum class </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#SocketState-enum" translate="no">SocketState</a></b> { UnconnectedState, ServiceLookupState, ConnectingState, ConnectedState, BoundState, &hellip;, ListeningState }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#QBluetoothSocket" translate="no">QBluetoothSocket</a></b>(QBluetoothServiceInfo::Protocol <i>socketType</i>, QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#QBluetoothSocket-1" translate="no">QBluetoothSocket</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#dtor.QBluetoothSocket" translate="no">~QBluetoothSocket</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#abort" translate="no">abort</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#connectToService" translate="no">connectToService</a></b>(const QBluetoothServiceInfo &amp;<i>service</i>, OpenMode <i>openMode</i> = ReadWrite)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#connectToService-1" translate="no">connectToService</a></b>(const QBluetoothAddress &amp;<i>address</i>, const QBluetoothUuid &amp;<i>uuid</i>, OpenMode <i>openMode</i> = ReadWrite)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#connectToService-2" translate="no">connectToService</a></b>(const QBluetoothAddress &amp;<i>address</i>, quint16 <i>port</i>, OpenMode <i>openMode</i> = ReadWrite)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#disconnectFromService" translate="no">disconnectFromService</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> SocketError </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#error" translate="no">error</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#errorString" translate="no">errorString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBluetoothAddress </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#localAddress" translate="no">localAddress</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#localName" translate="no">localName</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint16 </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#localPort" translate="no">localPort</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBluetoothAddress </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#peerAddress" translate="no">peerAddress</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#peerName" translate="no">peerName</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint16 </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#peerPort" translate="no">peerPort</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBluetooth::SecurityFlags </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#preferredSecurityFlags" translate="no">preferredSecurityFlags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#setPreferredSecurityFlags" translate="no">setPreferredSecurityFlags</a></b>(QBluetooth::SecurityFlags <i>flags</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#setSocketDescriptor" translate="no">setSocketDescriptor</a></b>(int <i>socketDescriptor</i>, QBluetoothServiceInfo::Protocol <i>socketType</i>, SocketState <i>socketState</i> = SocketState::ConnectedState, OpenMode <i>openMode</i> = ReadWrite)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#socketDescriptor" translate="no">socketDescriptor</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBluetoothServiceInfo::Protocol </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#socketType" translate="no">socketType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> SocketState </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#state" translate="no">state</a></b>() const</td></tr>
</table></div>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#bytesAvailable" translate="no">bytesAvailable</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#bytesToWrite" translate="no">bytesToWrite</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#canReadLine" translate="no">canReadLine</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#close" translate="no">close</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#isSequential" translate="no">isSequential</a></b>() const override</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#connected" translate="no">connected</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#disconnected" translate="no">disconnected</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#errorOccurred" translate="no">errorOccurred</a></b>(QBluetoothSocket::SocketError <i>error</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#stateChanged" translate="no">stateChanged</a></b>(QBluetoothSocket::SocketState <i>state</i>)</td></tr>
</table></div>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#doDeviceDiscovery" translate="no">doDeviceDiscovery</a></b>(const QBluetoothServiceInfo &amp;<i>service</i>, OpenMode <i>openMode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#setSocketError" translate="no">setSocketError</a></b>(SocketError <i>error_</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#setSocketState" translate="no">setSocketState</a></b>(SocketState <i>state</i>)</td></tr>
</table></div>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#readData" translate="no">readData</a></b>(char *<i>data</i>, qint64 <i>maxSize</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="qbluetoothsocket.html#writeData" translate="no">writeData</a></b>(const char *<i>data</i>, qint64 <i>maxSize</i>) override</td></tr>
</table></div>
<!-- $$$QBluetoothSocket-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QBluetoothSocket supports two socket types, <a href="qbluetoothserviceinfo.html#Protocol-enum" translate="no">L2CAP</a> and <a href="qbluetoothserviceinfo.html#Protocol-enum" translate="no">RFCOMM</a>.</p>
<p><a href="qbluetoothserviceinfo.html#Protocol-enum" translate="no">L2CAP</a> is a low level datagram-oriented Bluetooth socket. Android does not support <a href="qbluetoothserviceinfo.html#Protocol-enum" translate="no">L2CAP</a> for socket connections.</p>
<p><a href="qbluetoothserviceinfo.html#Protocol-enum" translate="no">RFCOMM</a> is a reliable, stream-oriented socket. RFCOMM sockets emulate an RS-232 serial port.</p>
<p>To create a connection to a Bluetooth service, create a socket of the appropriate type and call <a href="qbluetoothsocket.html#connectToService" translate="no">connectToService</a>() passing the Bluetooth address and port number. QBluetoothSocket will emit the <a href="qbluetoothsocket.html#connected" translate="no">connected</a>() signal when the connection is established.</p>
<p>If the <a href="qbluetoothserviceinfo.html#Protocol-enum" translate="no">Protocol</a> is not supported on a platform, calling <a href="qbluetoothsocket.html#connectToService" translate="no">connectToService</a>() will emit a <a href="qbluetoothsocket.html#SocketError-enum" translate="no">UnsupportedProtocolError</a> error.</p>
<div class="admonition note">
<p><b>Note: </b>QBluetoothSocket does not support synchronous read and write operations. Functions such as <a href="../qtcore/qiodevice.html#waitForReadyRead" translate="no">waitForReadyRead</a>() and <a href="../qtcore/qiodevice.html#waitForBytesWritten" translate="no">waitForBytesWritten</a>() are not implemented. I/O operations should be performed using <a href="../qtcore/qiodevice.html#readyRead" translate="no">readyRead</a>(), <a href="../qtcore/qiodevice.html#read" translate="no">read</a>() and <a href="../qtcore/qiodevice.html#write" translate="no">write</a>().</p>
</div>
<p>On iOS, this class cannot be used because the platform does not expose an API which may permit access to QBluetoothSocket related features.</p>
<div class="admonition note">
<p><b>Note: </b>On macOS Monterey (12) the socket data flow is paused when a modal dialogue is executing, or an event tracking mode is entered (for example by long-pressing a Window close button). This may change in the future releases of macOS.</p>
</div>
</div>
<!-- @@@QBluetoothSocket -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$SocketError$$$NoSocketError$$$UnknownSocketError$$$RemoteHostClosedError$$$HostNotFoundError$$$ServiceNotFoundError$$$NetworkError$$$UnsupportedProtocolError$$$OperationError$$$MissingPermissionsError -->
<h3 class="fn" translate="no" id="SocketError-enum">enum class QBluetoothSocket::<span class="name">SocketError</span></h3>
<p>This enum describes Bluetooth socket error types.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QBluetoothSocket::SocketError::UnknownSocketError</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">An unknown error has occurred.</td></tr>
<tr><td class="topAlign"><code translate="no">QBluetoothSocket::SocketError::NoSocketError</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">No error. Used for testing.</td></tr>
<tr><td class="topAlign"><code translate="no">QBluetoothSocket::SocketError::HostNotFoundError</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">Could not find the remote host.</td></tr>
<tr><td class="topAlign"><code translate="no">QBluetoothSocket::SocketError::ServiceNotFoundError</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">Could not find the service UUID on remote host.</td></tr>
<tr><td class="topAlign"><code translate="no">QBluetoothSocket::SocketError::NetworkError</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">Attempt to read or write from socket returned an error</td></tr>
<tr><td class="topAlign"><code translate="no">QBluetoothSocket::SocketError::UnsupportedProtocolError</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">The <a href="qbluetoothserviceinfo.html#Protocol-enum" translate="no">Protocol</a> is not supported on this platform.</td></tr>
<tr><td class="topAlign"><code translate="no">QBluetoothSocket::SocketError::OperationError</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">An operation was attempted while the socket was in a state that did not permit it.</td></tr>
<tr><td class="topAlign"><code translate="no">QBluetoothSocket::SocketError::RemoteHostClosedError (since Qt 5.10)</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The remote host closed the connection.</td></tr>
<tr><td class="topAlign"><code translate="no">QBluetoothSocket::SocketError::MissingPermissionsError (since Qt 6.4)</code></td><td class="topAlign tblval"><code translate="no">8</code></td><td class="topAlign">The operating system requests permissions which were not granted by the user.</td></tr>
</table></div>
<!-- @@@SocketError -->
<!-- $$$SocketState$$$UnconnectedState$$$ServiceLookupState$$$ConnectingState$$$ConnectedState$$$BoundState$$$ClosingState$$$ListeningState -->
<h3 class="fn" translate="no" id="SocketState-enum">enum class QBluetoothSocket::<span class="name">SocketState</span></h3>
<p>This enum describes the state of the Bluetooth socket.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QBluetoothSocket::SocketState::UnconnectedState</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Socket is not connected.</td></tr>
<tr><td class="topAlign"><code translate="no">QBluetoothSocket::SocketState::ServiceLookupState</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Socket is querying connection parameters.</td></tr>
<tr><td class="topAlign"><code translate="no">QBluetoothSocket::SocketState::ConnectingState</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Socket is attempting to connect to a device.</td></tr>
<tr><td class="topAlign"><code translate="no">QBluetoothSocket::SocketState::ConnectedState</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">Socket is connected to a device.</td></tr>
<tr><td class="topAlign"><code translate="no">QBluetoothSocket::SocketState::BoundState</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">Socket is bound to a local address and port.</td></tr>
<tr><td class="topAlign"><code translate="no">QBluetoothSocket::SocketState::ClosingState</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">Socket is connected and will be closed once all pending data is written to the socket.</td></tr>
<tr><td class="topAlign"><code translate="no">QBluetoothSocket::SocketState::ListeningState</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">Socket is listening for incoming connections.</td></tr>
</table></div>
<!-- @@@SocketState -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QBluetoothSocket[overload1]$$$QBluetoothSocketQBluetoothServiceInfo::ProtocolQObject* -->
<h3 class="fn" translate="no" id="QBluetoothSocket"><code translate="no">[explicit] </code>QBluetoothSocket::<span class="name">QBluetoothSocket</span>(<span class="type"><a href="qbluetoothserviceinfo.html#Protocol-enum" translate="no">QBluetoothServiceInfo::Protocol</a></span> <i>socketType</i>, <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a Bluetooth socket of <i translate="no">socketType</i> type, with <i translate="no">parent</i>.</p>
<!-- @@@QBluetoothSocket -->
<!-- $$$QBluetoothSocket$$$QBluetoothSocketQObject* -->
<h3 class="fn" translate="no" id="QBluetoothSocket-1"><code translate="no">[explicit] </code>QBluetoothSocket::<span class="name">QBluetoothSocket</span>(<span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a Bluetooth socket with <i translate="no">parent</i>.</p>
<!-- @@@QBluetoothSocket -->
<!-- $$$~QBluetoothSocket[overload1]$$$~QBluetoothSocket -->
<h3 class="fn" translate="no" id="dtor.QBluetoothSocket"><code translate="no">[virtual noexcept] </code>QBluetoothSocket::<span class="name">~QBluetoothSocket</span>()</h3>
<p>Destroys the Bluetooth socket.</p>
<!-- @@@~QBluetoothSocket -->
<!-- $$$abort[overload1]$$$abort -->
<h3 class="fn" translate="no" id="abort"><span class="type">void</span> QBluetoothSocket::<span class="name">abort</span>()</h3>
<p>Aborts the current connection and resets the socket. Unlike <a href="qbluetoothsocket.html#disconnectFromService" translate="no">disconnectFromService</a>(), this function immediately closes the socket, discarding any pending data in the write buffer.</p>
<div class="admonition note">
<p><b>Note: </b>On Android, aborting the socket requires asynchronous interaction with Android threads. Therefore the associated <a href="qbluetoothsocket.html#disconnected" translate="no">disconnected</a>() and <a href="qbluetoothsocket.html#stateChanged" translate="no">stateChanged</a>() signals are delayed until the threads have finished the closure.</p>
</div>
<p><b>See also </b><a href="qbluetoothsocket.html#disconnectFromService" translate="no">disconnectFromService</a>() and <a href="qbluetoothsocket.html#close" translate="no">close</a>().</p>
<!-- @@@abort -->
<!-- $$$bytesAvailable[overload1]$$$bytesAvailable -->
<h3 class="fn" translate="no" id="bytesAvailable"><code translate="no">[override virtual] </code><span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QBluetoothSocket::<span class="name">bytesAvailable</span>() const</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#bytesAvailable" translate="no">QIODevice::bytesAvailable() const</a>.</p>
<p>Returns the number of incoming bytes that are waiting to be read.</p>
<p><b>See also </b><a href="qbluetoothsocket.html#bytesToWrite" translate="no">bytesToWrite</a>() and <a href="../qtcore/qiodevice.html#read" translate="no">read</a>().</p>
<!-- @@@bytesAvailable -->
<!-- $$$bytesToWrite[overload1]$$$bytesToWrite -->
<h3 class="fn" translate="no" id="bytesToWrite"><code translate="no">[override virtual] </code><span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QBluetoothSocket::<span class="name">bytesToWrite</span>() const</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#bytesToWrite" translate="no">QIODevice::bytesToWrite() const</a>.</p>
<p>Returns the number of bytes that are waiting to be written. The bytes are written when control goes back to the event loop.</p>
<!-- @@@bytesToWrite -->
<!-- $$$canReadLine[overload1]$$$canReadLine -->
<h3 class="fn" translate="no" id="canReadLine"><code translate="no">[override virtual] </code><span class="type">bool</span> QBluetoothSocket::<span class="name">canReadLine</span>() const</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#canReadLine" translate="no">QIODevice::canReadLine() const</a>.</p>
<p>Returns true if you can read at least one line from the device</p>
<!-- @@@canReadLine -->
<!-- $$$close[overload1]$$$close -->
<h3 class="fn" translate="no" id="close"><code translate="no">[override virtual] </code><span class="type">void</span> QBluetoothSocket::<span class="name">close</span>()</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#close" translate="no">QIODevice::close</a>().</p>
<p>Disconnects the socket's connection with the device.</p>
<div class="admonition note">
<p><b>Note: </b>On Android, closing the socket requires asynchronous interaction with Android threads. Therefore the associated <a href="qbluetoothsocket.html#disconnected" translate="no">disconnected</a>() and <a href="qbluetoothsocket.html#stateChanged" translate="no">stateChanged</a>() signals are delayed until the threads have finished the closure.</p>
</div>
<!-- @@@close -->
<!-- $$$connectToService[overload1]$$$connectToServiceconstQBluetoothServiceInfo&OpenMode -->
<h3 class="fn" translate="no" id="connectToService"><span class="type">void</span> QBluetoothSocket::<span class="name">connectToService</span>(const <span class="type"><a href="qbluetoothserviceinfo.html" translate="no">QBluetoothServiceInfo</a></span> &amp;<i>service</i>, <span class="type"><a href="../qtcore/qiodevicebase.html#OpenModeFlag-enum" translate="no">OpenMode</a></span> <i>openMode</i> = ReadWrite)</h3>
<p>Attempts to connect to the service described by <i translate="no">service</i>.</p>
<p>The socket is opened in the given <i translate="no">openMode</i>. The <a href="qbluetoothsocket.html#socketType" translate="no">socketType</a>() is ignored if <i translate="no">service</i> specifies a differing <a href="qbluetoothserviceinfo.html#socketProtocol" translate="no">QBluetoothServiceInfo::socketProtocol</a>().</p>
<p>The socket first enters <a href="qbluetoothsocket.html#SocketState-enum" translate="no">ConnectingState</a> and attempts to connect to the device providing <i translate="no">service</i>. If a connection is established, <a href="qbluetoothsocket.html" translate="no">QBluetoothSocket</a> enters <a href="qbluetoothsocket.html#SocketState-enum" translate="no">ConnectedState</a> and emits <a href="qbluetoothsocket.html#connected" translate="no">connected</a>().</p>
<p>At any point, the socket can emit <a href="qbluetoothsocket.html#errorOccurred" translate="no">errorOccurred</a>() to signal that an error occurred.</p>
<p>Note that most platforms require a pairing prior to connecting to the remote device. Otherwise the connection process may fail.</p>
<p>On Android, only RFCOMM connections are possible. This function ignores any socket protocol indicator and assumes RFCOMM.</p>
<p><b>See also </b><a href="qbluetoothsocket.html#state" translate="no">state</a>() and <a href="qbluetoothsocket.html#disconnectFromService" translate="no">disconnectFromService</a>().</p>
<!-- @@@connectToService -->
<!-- $$$connectToService$$$connectToServiceconstQBluetoothAddress&constQBluetoothUuid&OpenMode -->
<h3 class="fn" translate="no" id="connectToService-1"><span class="type">void</span> QBluetoothSocket::<span class="name">connectToService</span>(const <span class="type"><a href="qbluetoothaddress.html" translate="no">QBluetoothAddress</a></span> &amp;<i>address</i>, const <span class="type"><a href="qbluetoothuuid.html" translate="no">QBluetoothUuid</a></span> &amp;<i>uuid</i>, <span class="type"><a href="../qtcore/qiodevicebase.html#OpenModeFlag-enum" translate="no">OpenMode</a></span> <i>openMode</i> = ReadWrite)</h3>
<p>Attempts to make a connection to the service identified by <i translate="no">uuid</i> on the device with address <i translate="no">address</i>.</p>
<p>The socket is opened in the given <i translate="no">openMode</i>.</p>
<p>For BlueZ, the socket first enters the <a href="qbluetoothsocket.html#SocketState-enum" translate="no">ServiceLookupState</a> and queries the connection parameters for <i translate="no">uuid</i>. If the service parameters are successfully retrieved the socket enters <a href="qbluetoothsocket.html#SocketState-enum" translate="no">ConnectingState</a>, and attempts to connect to <i translate="no">address</i>. If a connection is established, <a href="qbluetoothsocket.html" translate="no">QBluetoothSocket</a> enters <a href="qbluetoothsocket.html#SocketState-enum" translate="no">ConnectedState</a> and emits <a href="qbluetoothsocket.html#connected" translate="no">connected</a>().</p>
<p>On Android, the service connection can directly be established using the UUID of the remote service. Therefore the platform does not require the <a href="qbluetoothsocket.html#SocketState-enum" translate="no">ServiceLookupState</a> and <a href="qbluetoothsocket.html#socketType" translate="no">socketType</a>() is always set to <a href="qbluetoothserviceinfo.html#Protocol-enum" translate="no">QBluetoothServiceInfo::RfcommProtocol</a>.</p>
<p>At any point, the socket can emit <a href="qbluetoothsocket.html#errorOccurred" translate="no">errorOccurred</a>() to signal that an error occurred.</p>
<p>Note that most platforms require a pairing prior to connecting to the remote device. Otherwise the connection process may fail.</p>
<p><b>See also </b><a href="qbluetoothsocket.html#state" translate="no">state</a>() and <a href="qbluetoothsocket.html#disconnectFromService" translate="no">disconnectFromService</a>().</p>
<!-- @@@connectToService -->
<!-- $$$connectToService$$$connectToServiceconstQBluetoothAddress&quint16OpenMode -->
<h3 class="fn" translate="no" id="connectToService-2"><span class="type">void</span> QBluetoothSocket::<span class="name">connectToService</span>(const <span class="type"><a href="qbluetoothaddress.html" translate="no">QBluetoothAddress</a></span> &amp;<i>address</i>, <span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> <i>port</i>, <span class="type"><a href="../qtcore/qiodevicebase.html#OpenModeFlag-enum" translate="no">OpenMode</a></span> <i>openMode</i> = ReadWrite)</h3>
<p>Attempts to make a connection with <i translate="no">address</i> on the given <i translate="no">port</i>.</p>
<p>The socket is opened in the given <i translate="no">openMode</i>.</p>
<p>The socket first enters <a href="qbluetoothsocket.html#SocketState-enum" translate="no">ConnectingState</a>, and attempts to connect to <i translate="no">address</i>. If a connection is established, <a href="qbluetoothsocket.html" translate="no">QBluetoothSocket</a> enters <a href="qbluetoothsocket.html#SocketState-enum" translate="no">ConnectedState</a> and emits <a href="qbluetoothsocket.html#connected" translate="no">connected</a>().</p>
<p>At any point, the socket can emit <a href="qbluetoothsocket.html#errorOccurred" translate="no">errorOccurred</a>() to signal that an error occurred.</p>
<p>On Android and BlueZ (version 5.46 or above), a connection to a service can not be established using a port. Calling this function will emit a <a href="qbluetoothsocket.html#SocketError-enum" translate="no">ServiceNotFoundError</a>.</p>
<p>Note that most platforms require a pairing prior to connecting to the remote device. Otherwise the connection process may fail.</p>
<p><b>See also </b><a href="qbluetoothsocket.html#state" translate="no">state</a>() and <a href="qbluetoothsocket.html#disconnectFromService" translate="no">disconnectFromService</a>().</p>
<!-- @@@connectToService -->
<!-- $$$connected[overload1]$$$connected -->
<h3 class="fn" translate="no" id="connected"><code translate="no">[signal] </code><span class="type">void</span> QBluetoothSocket::<span class="name">connected</span>()</h3>
<p>This signal is emitted when a connection is established.</p>
<p><b>See also </b><a href="qbluetoothsocket.html#SocketState-enum" translate="no">QBluetoothSocket::SocketState::ConnectedState</a> and <a href="qbluetoothsocket.html#stateChanged" translate="no">stateChanged</a>().</p>
<!-- @@@connected -->
<!-- $$$disconnectFromService[overload1]$$$disconnectFromService -->
<h3 class="fn" translate="no" id="disconnectFromService"><span class="type">void</span> QBluetoothSocket::<span class="name">disconnectFromService</span>()</h3>
<p>Attempts to close the socket. If there is pending data waiting to be written <a href="qbluetoothsocket.html" translate="no">QBluetoothSocket</a> will enter <a href="qbluetoothsocket.html#SocketState-enum" translate="no">ClosingState</a> and wait until all data has been written. Eventually, it will enter <a href="qbluetoothsocket.html#SocketState-enum" translate="no">UnconnectedState</a> and emit the <a href="qbluetoothsocket.html#disconnected" translate="no">disconnected</a>() signal.</p>
<p><b>See also </b><a href="qbluetoothsocket.html#connectToService" translate="no">connectToService</a>().</p>
<!-- @@@disconnectFromService -->
<!-- $$$disconnected[overload1]$$$disconnected -->
<h3 class="fn" translate="no" id="disconnected"><code translate="no">[signal] </code><span class="type">void</span> QBluetoothSocket::<span class="name">disconnected</span>()</h3>
<p>This signal is emitted when the socket is disconnected.</p>
<p><b>See also </b><a href="qbluetoothsocket.html#SocketState-enum" translate="no">QBluetoothSocket::SocketState::UnconnectedState</a> and <a href="qbluetoothsocket.html#stateChanged" translate="no">stateChanged</a>().</p>
<!-- @@@disconnected -->
<!-- $$$doDeviceDiscovery[overload1]$$$doDeviceDiscoveryconstQBluetoothServiceInfo&OpenMode -->
<h3 class="fn" translate="no" id="doDeviceDiscovery"><code translate="no">[protected] </code><span class="type">void</span> QBluetoothSocket::<span class="name">doDeviceDiscovery</span>(const <span class="type"><a href="qbluetoothserviceinfo.html" translate="no">QBluetoothServiceInfo</a></span> &amp;<i>service</i>, <span class="type"><a href="../qtcore/qiodevicebase.html#OpenModeFlag-enum" translate="no">OpenMode</a></span> <i>openMode</i>)</h3>
<p>Start device discovery for <i translate="no">service</i> and open the socket with <i translate="no">openMode</i>. If the socket is created with a service uuid device address, use service discovery to find the port number to connect to.</p>
<!-- @@@doDeviceDiscovery -->
<!-- $$$error[overload1]$$$error -->
<h3 class="fn" translate="no" id="error"><span class="type"><a href="qbluetoothsocket.html#SocketError-enum" translate="no">SocketError</a></span> QBluetoothSocket::<span class="name">error</span>() const</h3>
<p>Returns the last error.</p>
<!-- @@@error -->
<!-- $$$errorOccurred[overload1]$$$errorOccurredQBluetoothSocket::SocketError -->
<h3 class="fn" translate="no" id="errorOccurred"><code translate="no">[signal, since 6.2] </code><span class="type">void</span> QBluetoothSocket::<span class="name">errorOccurred</span>(<span class="type"><a href="qbluetoothsocket.html#SocketError-enum" translate="no">QBluetoothSocket::SocketError</a></span> <i>error</i>)</h3>
<p>This signal is emitted when an <i translate="no">error</i> occurs.</p>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qbluetoothsocket.html#error" translate="no">error</a>().</p>
<!-- @@@errorOccurred -->
<!-- $$$errorString[overload1]$$$errorString -->
<h3 class="fn" translate="no" id="errorString"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QBluetoothSocket::<span class="name">errorString</span>() const</h3>
<p>Returns a user displayable text string for the error.</p>
<!-- @@@errorString -->
<!-- $$$isSequential[overload1]$$$isSequential -->
<h3 class="fn" translate="no" id="isSequential"><code translate="no">[override virtual] </code><span class="type">bool</span> QBluetoothSocket::<span class="name">isSequential</span>() const</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#isSequential" translate="no">QIODevice::isSequential() const</a>.</p>
<!-- @@@isSequential -->
<!-- $$$localAddress[overload1]$$$localAddress -->
<h3 class="fn" translate="no" id="localAddress"><span class="type"><a href="qbluetoothaddress.html" translate="no">QBluetoothAddress</a></span> QBluetoothSocket::<span class="name">localAddress</span>() const</h3>
<p>Returns the address of the local device.</p>
<p>Although some platforms may differ the socket must generally be connected to guarantee the return of a valid address. In particular, this is true when dealing with platforms that support multiple local Bluetooth adapters.</p>
<!-- @@@localAddress -->
<!-- $$$localName[overload1]$$$localName -->
<h3 class="fn" translate="no" id="localName"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QBluetoothSocket::<span class="name">localName</span>() const</h3>
<p>Returns the name of the local device.</p>
<p>Although some platforms may differ the socket must generally be connected to guarantee the return of a valid name. In particular, this is true when dealing with platforms that support multiple local Bluetooth adapters.</p>
<!-- @@@localName -->
<!-- $$$localPort[overload1]$$$localPort -->
<h3 class="fn" translate="no" id="localPort"><span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> QBluetoothSocket::<span class="name">localPort</span>() const</h3>
<p>Returns the port number of the local socket if available, otherwise returns 0. Although some platforms may differ the socket must generally be connected to guarantee the return of a valid port number.</p>
<p>On Android and macOS, this feature is not supported and returns 0.</p>
<!-- @@@localPort -->
<!-- $$$peerAddress[overload1]$$$peerAddress -->
<h3 class="fn" translate="no" id="peerAddress"><span class="type"><a href="qbluetoothaddress.html" translate="no">QBluetoothAddress</a></span> QBluetoothSocket::<span class="name">peerAddress</span>() const</h3>
<p>Returns the address of the peer device.</p>
<!-- @@@peerAddress -->
<!-- $$$peerName[overload1]$$$peerName -->
<h3 class="fn" translate="no" id="peerName"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QBluetoothSocket::<span class="name">peerName</span>() const</h3>
<p>Returns the name of the peer device.</p>
<!-- @@@peerName -->
<!-- $$$peerPort[overload1]$$$peerPort -->
<h3 class="fn" translate="no" id="peerPort"><span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> QBluetoothSocket::<span class="name">peerPort</span>() const</h3>
<p>Return the port number of the peer socket if available, otherwise returns 0. On Android, this feature is not supported.</p>
<!-- @@@peerPort -->
<!-- $$$preferredSecurityFlags[overload1]$$$preferredSecurityFlags -->
<h3 class="fn" translate="no" id="preferredSecurityFlags"><span class="type"><a href="qbluetooth.html#Security-enum" translate="no">QBluetooth::SecurityFlags</a></span> QBluetoothSocket::<span class="name">preferredSecurityFlags</span>() const</h3>
<p>Returns the security parameters used for the initial connection attempt.</p>
<p>The security parameters may be renegotiated between the two parties during or after the connection has been established. If such a change happens it is not reflected in the value of this flag.</p>
<p>On macOS, this flag is always set to <a href="qbluetooth.html#Security-enum" translate="no">QBluetooth::Security::Secure</a>.</p>
<p><b>See also </b><a href="qbluetoothsocket.html#setPreferredSecurityFlags" translate="no">setPreferredSecurityFlags</a>().</p>
<!-- @@@preferredSecurityFlags -->
<!-- $$$readData[overload1]$$$readDatachar*qint64 -->
<h3 class="fn" translate="no" id="readData"><code translate="no">[override virtual protected] </code><span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QBluetoothSocket::<span class="name">readData</span>(<span class="type">char</span> *<i>data</i>, <span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>maxSize</i>)</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#readData" translate="no">QIODevice::readData</a>(char *data, qint64 maxSize).</p>
<!-- @@@readData -->
<!-- $$$setPreferredSecurityFlags[overload1]$$$setPreferredSecurityFlagsQBluetooth::SecurityFlags -->
<h3 class="fn" translate="no" id="setPreferredSecurityFlags"><span class="type">void</span> QBluetoothSocket::<span class="name">setPreferredSecurityFlags</span>(<span class="type"><a href="qbluetooth.html#Security-enum" translate="no">QBluetooth::SecurityFlags</a></span> <i>flags</i>)</h3>
<p>Sets the preferred security parameter for the connection attempt to <i translate="no">flags</i>. This value is incorporated when calling <a href="qbluetoothsocket.html#connectToService" translate="no">connectToService</a>(). Therefore it is required to reconnect to change this parameter for an existing connection.</p>
<p>On Bluez this property is set to <a href="qbluetooth.html#Security-enum" translate="no">QBluetooth::Security::Authorization</a> by default.</p>
<p>On macOS, this value is ignored as the platform does not permit access to the security parameter of the socket. By default the platform prefers secure/encrypted connections though and therefore this function always returns <a href="qbluetooth.html#Security-enum" translate="no">QBluetooth::Security::Secure</a>.</p>
<p>Android only supports two levels of security (secure and non-secure). If this flag is set to <a href="qbluetooth.html#Security-enum" translate="no">QBluetooth::Security::NoSecurity</a> the socket object will not employ any authentication or encryption. Any other security flag combination will trigger a secure Bluetooth connection. This flag is set to <a href="qbluetooth.html#Security-enum" translate="no">QBluetooth::Security::Secure</a> by default.</p>
<div class="admonition note">
<p><b>Note: </b>A secure connection requires a pairing between the two devices. On some platforms, the pairing is automatically initiated during the establishment of the connection. Other platforms require the application to manually trigger the pairing before attempting to connect.</p>
</div>
<p><b>See also </b><a href="qbluetoothsocket.html#preferredSecurityFlags" translate="no">preferredSecurityFlags</a>().</p>
<!-- @@@setPreferredSecurityFlags -->
<!-- $$$setSocketDescriptor[overload1]$$$setSocketDescriptorintQBluetoothServiceInfo::ProtocolSocketStateOpenMode -->
<h3 class="fn" translate="no" id="setSocketDescriptor"><span class="type">bool</span> QBluetoothSocket::<span class="name">setSocketDescriptor</span>(<span class="type">int</span> <i>socketDescriptor</i>, <span class="type"><a href="qbluetoothserviceinfo.html#Protocol-enum" translate="no">QBluetoothServiceInfo::Protocol</a></span> <i>socketType</i>, <span class="type"><a href="qbluetoothsocket.html#SocketState-enum" translate="no">SocketState</a></span> <i>socketState</i> = SocketState::ConnectedState, <span class="type"><a href="../qtcore/qiodevicebase.html#OpenModeFlag-enum" translate="no">OpenMode</a></span> <i>openMode</i> = ReadWrite)</h3>
<p>Sets the socket to use <i translate="no">socketDescriptor</i> with a type of <i translate="no">socketType</i>, which is in state <i translate="no">socketState</i>, and mode <i translate="no">openMode</i>.</p>
<p>The socket descriptor is owned by the <a href="qbluetoothsocket.html" translate="no">QBluetoothSocket</a> instance and may be closed once finished.</p>
<p>Returns <code translate="no">true</code> on success.</p>
<p><b>See also </b><a href="qbluetoothsocket.html#socketDescriptor" translate="no">socketDescriptor</a>().</p>
<!-- @@@setSocketDescriptor -->
<!-- $$$setSocketError[overload1]$$$setSocketErrorSocketError -->
<h3 class="fn" translate="no" id="setSocketError"><code translate="no">[protected] </code><span class="type">void</span> QBluetoothSocket::<span class="name">setSocketError</span>(<span class="type"><a href="qbluetoothsocket.html#SocketError-enum" translate="no">SocketError</a></span> <i>error_</i>)</h3>
<p>Sets the type of error that last occurred to <i translate="no">error_</i>.</p>
<!-- @@@setSocketError -->
<!-- $$$setSocketState[overload1]$$$setSocketStateSocketState -->
<h3 class="fn" translate="no" id="setSocketState"><code translate="no">[protected] </code><span class="type">void</span> QBluetoothSocket::<span class="name">setSocketState</span>(<span class="type"><a href="qbluetoothsocket.html#SocketState-enum" translate="no">SocketState</a></span> <i>state</i>)</h3>
<p>Sets the socket state to <i translate="no">state</i>.</p>
<!-- @@@setSocketState -->
<!-- $$$socketDescriptor[overload1]$$$socketDescriptor -->
<h3 class="fn" translate="no" id="socketDescriptor"><span class="type">int</span> QBluetoothSocket::<span class="name">socketDescriptor</span>() const</h3>
<p>Returns the platform-specific socket descriptor, if available. This function returns -1 if the descriptor is not available or an error has occurred.</p>
<p><b>See also </b><a href="qbluetoothsocket.html#setSocketDescriptor" translate="no">setSocketDescriptor</a>().</p>
<!-- @@@socketDescriptor -->
<!-- $$$socketType[overload1]$$$socketType -->
<h3 class="fn" translate="no" id="socketType"><span class="type"><a href="qbluetoothserviceinfo.html#Protocol-enum" translate="no">QBluetoothServiceInfo::Protocol</a></span> QBluetoothSocket::<span class="name">socketType</span>() const</h3>
<p>Returns the socket type. The socket automatically adjusts to the protocol offered by the remote service.</p>
<p>Android only support <a href="qbluetoothserviceinfo.html#Protocol-enum" translate="no">RFCOMM</a> based sockets.</p>
<!-- @@@socketType -->
<!-- $$$state[overload1]$$$state -->
<h3 class="fn" translate="no" id="state"><span class="type"><a href="qbluetoothsocket.html#SocketState-enum" translate="no">SocketState</a></span> QBluetoothSocket::<span class="name">state</span>() const</h3>
<p>Returns the current state of the socket.</p>
<!-- @@@state -->
<!-- $$$stateChanged[overload1]$$$stateChangedQBluetoothSocket::SocketState -->
<h3 class="fn" translate="no" id="stateChanged"><code translate="no">[signal] </code><span class="type">void</span> QBluetoothSocket::<span class="name">stateChanged</span>(<span class="type"><a href="qbluetoothsocket.html#SocketState-enum" translate="no">QBluetoothSocket::SocketState</a></span> <i>state</i>)</h3>
<p>This signal is emitted when the socket state changes to <i translate="no">state</i>.</p>
<p><b>See also </b><a href="qbluetoothsocket.html#connected" translate="no">connected</a>(), <a href="qbluetoothsocket.html#disconnected" translate="no">disconnected</a>(), <a href="qbluetoothsocket.html#state" translate="no">state</a>(), and <a href="qbluetoothsocket.html#SocketState-enum" translate="no">QBluetoothSocket::SocketState</a>.</p>
<!-- @@@stateChanged -->
<!-- $$$writeData[overload1]$$$writeDataconstchar*qint64 -->
<h3 class="fn" translate="no" id="writeData"><code translate="no">[override virtual protected] </code><span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QBluetoothSocket::<span class="name">writeData</span>(const <span class="type">char</span> *<i>data</i>, <span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>maxSize</i>)</h3>
<p>Reimplements: <a href="../qtcore/qiodevice.html#writeData" translate="no">QIODevice::writeData</a>(const char *data, qint64 maxSize).</p>
<!-- @@@writeData -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
