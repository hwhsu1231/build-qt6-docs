<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- overview.qdoc -->
  <meta name="description" content="Provides insight into the MQTT protocol and the Qt MQTT module.">
  <title>Qt MQTT Overview | Qt MQTT 6.6.2</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.6</a></li>
<li><a href="qtmqtt-index.html" translate="no">Qt MQTT</a></li>
<li>Qt MQTT Overview</li>
<li id="buildversion"><a href="qtmqtt-index.html" translate="no">Qt 6.6.2 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#publish-and-subscribe">Publish and Subscribe</a></li>
<li class="level1"><a href="#topics">Topics</a></li>
<li class="level1"><a href="#subscribing-to-topics-using-wildcards">Subscribing to Topics Using Wildcards</a></li>
<li class="level1"><a href="#shared-subscriptions">Shared Subscriptions</a></li>
<li class="level1"><a href="#topic-aliases">Topic Aliases</a></li>
<li class="level1"><a href="#security">Security</a></li>
<li class="level1"><a href="#quality-of-service">Quality of Service</a></li>
<li class="level1"><a href="#will-messages">Will Messages</a></li>
<li class="level1"><a href="#retained-messages">Retained Messages</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Qt MQTT Overview</h1>
<!-- $$$qtmqtt-overview.html-description -->
<div class="descr" id="details">
<p>Qt MQTT enables you to create applications and devices that can communicate over the MQ telemetry transport (MQTT) protocol. It fully complies to the MQTT protocol specification.</p>
<h2 id="publish-and-subscribe">Publish and Subscribe</h2>
<p><a href="https://www.mqtt.org" translate="no">MQTT</a> is a machine-to-machine connectivity protocol that operates on the publish-and-subscribe model. An MQTT client is a program or device that uses MQTT to create a network connection to an MQTT server, also called a <i>broker</i>. Once a connection is created, the client can send messages to the broker. The other clients can subscribe to notifications on particular topics sent by the client.</p>
<p class="centerAlign"><img src="images/mqtt.png" alt="" /></p><p>For example, if <i>Client 2</i> subscribes to messages on <i>Topic A</i>, it receives a notification when <i>Client 1</i> sends a message on that topic. If <i>Client 3</i> subscribes to <i>Topic A</i> and <i>Topic B</i>, it receives notifications about messages on both those topics.</p>
<p>Qt MQTT is a client solution that does not include a broker. It is especially suitable for developing telemetry applications for embedded devices. However, Qt MQTT has no external dependencies, and therefore the implemented clients can be run on all supported Qt platforms.</p>
<h2 id="topics">Topics</h2>
<p>Topics are stored in a hierarchical tree structure. The standard does not specify how the tree should be designed, nor does it provide predefined hierarchy sets. You can freely design the hierarchy as required by your project. The following is an example of a topic hierarchy, where <i>active</i> means all active sensors, whereas <i>house</i> and <i>garage</i> are individual sensors:</p>
<pre class="cpp plain" translate="no">
 sensors/active
 sensors/house/temperature
 sensors/house/bedroom/light
 sensors/house/livingroom/light
 sensors/garage/temperature
 sensors/garage/light
</pre>
<h2 id="subscribing-to-topics-using-wildcards">Subscribing to Topics Using Wildcards</h2>
<p>When clients subscribe to topics, they can use the hash mark (#) and plus sign (+) as wildcards. The hash mark indicates that the client wants to receive notifications on all messages on a topic and its subtopics. For example, if a client subscribes to <i>sensors/house/#</i>, it receives all messages on the <i>house</i> sensor.</p>
<p>The plus sign indicates that a branch on the tree can be skipped over when looking for a matching subtopic. For example, if a client subscribes to <i>sensors/+/temperature</i>, it receives messages on <i>temperature</i> regardless of which sensor sent them. You can use multiple plus signs to skip over multiple branches. For example, <i>house/+/+/temperature</i> could be used to receive messages on the temperature of all rooms in all apartments in a house.</p>
<h2 id="shared-subscriptions">Shared Subscriptions</h2>
<p><i>Shared subscriptions</i> describe a pool of subscribers to one topic filter. Instead of all subscribers receiving a message, only one subscriber receives it. This enables load balancing on multiple clients. The format of a shared subscription is:</p>
<pre class="cpp plain" translate="no">
 $share/{sharename}/{topicfilter}
</pre>
<p>For example, if <i>Client 1</i> and <i>Client 2</i> should share a subscription to the topic <i>sensors/house/temperature</i>, the topic filter to subscribe to is:</p>
<pre class="cpp plain" translate="no">
 $share/poolAB/sensors/house/temperature
</pre>
<p>It is not defined in which order messages are distributed by the server. This is a server specific option.</p>
<p>To identify whether a server supports shared subscriptions, see also <a href="qmqttserverconnectionproperties.html#sharedSubscriptionSupported" translate="no">QMqttServerConnectionProperties::sharedSubscriptionSupported</a>().</p>
<h2 id="topic-aliases">Topic Aliases</h2>
<p>Structuring topics in a tree helps to separate data channels and provide a logical order of information. However, this can lead to very long topic names being used during the publication of messages, hence increasing the size of each message.</p>
<p>The MQTT 5.0 protocol version introduced <i>topic aliases</i> to circumvent this. Instead of the topic string, an integer value is sent. To create an initial mapping between the client and the server, both the topic string and the alias need to be part of a message. Thereafter, only the ID with an empty topic is used.</p>
<p>This mapping can be changed at any time by using a topic alias with another topic string. Note that this mapping does not necessarily apply to other connections, such as connections from the server to other clients. Each connection needs to create this mapping manually.</p>
<p>Qt MQTT provides an automated mechanism to help reduce data rates. After <a href="qmqttclient.html" translate="no">QMqttClient</a> creates a connection, information about topic aliases supported by the server is stored. Subsequently, topic aliases are used in the order the messages are published, until all available aliases are in use. A user is always able to modify this mapping by using <a href="qmqttpublishproperties.html#setTopicAlias" translate="no">QMqttPublishProperties::setTopicAlias</a>() during publication.</p>
<p>When <a href="qmqttclient.html" translate="no">QMqttClient</a> subscribes to a topic, the server can use topic aliases as well, depending on the <a href="qmqttconnectionproperties.html#maximumTopicAlias" translate="no">QMqttConnectionProperties::maximumTopicAlias</a>() value set by the client. The client automatically maps topic aliases and transparently forwards messages to the user including the full topic string.</p>
<h2 id="security">Security</h2>
<p>The connections between the clients and the broker are secured by an in-built authentication system that uses user names and passwords. Messages are encrypted by using SSL/TLS at the transport layer. The standardized port number for encrypted MQTT messages is 8883.</p>
<h2 id="quality-of-service">Quality of Service</h2>
<p>The following quality of service (QoS) levels for messages are defined:</p>
<ul>
<li><i>At most once (0)</i> means that messages are delivered according to the best efforts of the operating environment, and therefore message loss can occur. This level could be used, for example, with ambient sensor data where it does not matter if an individual reading is lost as the next one will be published soon after.</li>
<li><i>At least once (1)</i> means that messages are assured to arrive but duplicates can occur.</li>
<li><i>Exactly once (2)</i> means that messages are assured to arrive exactly once. This level could be used, for example, with billing systems where duplicate or lost messages could lead to incorrect charges being applied.</li>
</ul>
<h2 id="will-messages">Will Messages</h2>
<p>A <i>Will Message</i>, also called <i>testament</i>, is a message sent from a client and stored at the broker location. If the connection between the client and broker breaks in an unexpected way, the Will Message will be forwarded to any subscriber of the <i>Will Topic</i>.</p>
<p>Will Messages must be specified at the connecting stage. Hence, it is mandatory to set them before invoking <a href="qmqttclient.html#connectToHost" translate="no">QMqttClient::connectToHost</a>() or <a href="qmqttclient.html#connectToHostEncrypted" translate="no">QMqttClient::connectToHostEncrypted</a>(). A Will Message has all the properties of a regular message, as well as a Will Topic, QoS level, retained flag, and message payload.</p>
<p>If the client disconnects from the broker in a regular fashion by calling <a href="qmqttclient.html#disconnectFromHost" translate="no">QMqttClient::disconnectFromHost</a>(), the broker will discard the Will Message. If needed, the client is responsible for sending all the required messages before disconnecting.</p>
<h2 id="retained-messages">Retained Messages</h2>
<p>Retained messages are stored on the broker side. As future clients connect, they will receive such messages. A typical use case is to store the current health status of the publisher in a retained message. Subscribers will instantly receive a message about the status.</p>
<p>A broker can only store the last retained message sent for a specified topic. If a client publishes a retained message with the QoS level zero, any previously retained message for its topic at the broker <i>must</i> be discarded. The broker <i>should</i> store the last message, but <i>may</i> also discard it. This depends on the implementation of the broker.</p>
</div>
<!-- @@@qtmqtt-overview.html -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
