<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qwebsocket.cpp -->
  <meta name="description" content="Implements a TCP socket that talks the WebSocket protocol.">
  <title>QWebSocket Class | Qt WebSockets 6.6.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.6</a></li>
<li><a href="qtwebsockets-index.html" translate="no">Qt WebSockets</a></li>
<li><a href="qtwebsockets-module.html" translate="no">C++ Classes</a></li>
<li>QWebSocket</li>
<li id="buildversion"><a href="qtwebsockets-index.html" translate="no">Qt 6.6&#x2e;0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#public-slots">Public Slots</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QWebSocket Class</h1>
<!-- $$$QWebSocket-brief -->
<p>Implements a TCP socket that talks the WebSocket protocol. <a href="#details">More...</a></p>
<!-- @@@QWebSocket -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QWebSocket&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS WebSockets) <br/>
target_link_libraries(mytarget PRIVATE Qt6::WebSockets)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += websockets</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html" translate="no">QObject</a></td></tr>
</table></div>
<ul>
<li><a href="qwebsocket-members.html">List of all members, including inherited members</a></li>
<li><a href="qwebsocket-obsolete.html">Deprecated members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#QWebSocket-1" translate="no">QWebSocket</a></b>(const QString &amp;<i>origin</i> = QString(), QWebSocketProtocol::Version <i>version</i> = QWebSocketProtocol::VersionLatest, QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#dtor.QWebSocket" translate="no">~QWebSocket</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#abort" translate="no">abort</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#bytesToWrite" translate="no">bytesToWrite</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWebSocketProtocol::CloseCode </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#closeCode" translate="no">closeCode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#closeReason" translate="no">closeReason</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#continueInterruptedHandshake" translate="no">continueInterruptedHandshake</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractSocket::SocketError </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#error" translate="no">error</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#errorString" translate="no">errorString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#flush" translate="no">flush</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWebSocketHandshakeOptions </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#handshakeOptions" translate="no">handshakeOptions</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#ignoreSslErrors-1" translate="no">ignoreSslErrors</a></b>(const QList&lt;QSslError&gt; &amp;<i>errors</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QHostAddress </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#localAddress" translate="no">localAddress</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint16 </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#localPort" translate="no">localPort</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QMaskGenerator *</td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#maskGenerator" translate="no">maskGenerator</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint64 </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#maxAllowedIncomingFrameSize" translate="no">maxAllowedIncomingFrameSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint64 </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#maxAllowedIncomingMessageSize" translate="no">maxAllowedIncomingMessageSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#origin" translate="no">origin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint64 </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#outgoingFrameSize" translate="no">outgoingFrameSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractSocket::PauseModes </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#pauseMode" translate="no">pauseMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QHostAddress </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#peerAddress" translate="no">peerAddress</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#peerName" translate="no">peerName</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint16 </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#peerPort" translate="no">peerPort</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkProxy </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#proxy" translate="no">proxy</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#readBufferSize" translate="no">readBufferSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkRequest </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#request" translate="no">request</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QUrl </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#requestUrl" translate="no">requestUrl</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#resourceName" translate="no">resourceName</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#resume" translate="no">resume</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#sendBinaryMessage" translate="no">sendBinaryMessage</a></b>(const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#sendTextMessage" translate="no">sendTextMessage</a></b>(const QString &amp;<i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#setMaskGenerator" translate="no">setMaskGenerator</a></b>(const QMaskGenerator *<i>maskGenerator</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#setMaxAllowedIncomingFrameSize" translate="no">setMaxAllowedIncomingFrameSize</a></b>(quint64 <i>maxAllowedIncomingFrameSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#setMaxAllowedIncomingMessageSize" translate="no">setMaxAllowedIncomingMessageSize</a></b>(quint64 <i>maxAllowedIncomingMessageSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#setOutgoingFrameSize" translate="no">setOutgoingFrameSize</a></b>(quint64 <i>outgoingFrameSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#setPauseMode" translate="no">setPauseMode</a></b>(QAbstractSocket::PauseModes <i>pauseMode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#setProxy" translate="no">setProxy</a></b>(const QNetworkProxy &amp;<i>networkProxy</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#setReadBufferSize" translate="no">setReadBufferSize</a></b>(qint64 <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#setSslConfiguration" translate="no">setSslConfiguration</a></b>(const QSslConfiguration &amp;<i>sslConfiguration</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSslConfiguration </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#sslConfiguration" translate="no">sslConfiguration</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractSocket::SocketState </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#state" translate="no">state</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#subprotocol" translate="no">subprotocol</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWebSocketProtocol::Version </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#version" translate="no">version</a></b>() const</td></tr>
</table></div>
<h2 id="public-slots">Public Slots</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#close" translate="no">close</a></b>(QWebSocketProtocol::CloseCode <i>closeCode</i> = QWebSocketProtocol::CloseCodeNormal, const QString &amp;<i>reason</i> = QString())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#ignoreSslErrors" translate="no">ignoreSslErrors</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#open" translate="no">open</a></b>(const QUrl &amp;<i>url</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#open-1" translate="no">open</a></b>(const QNetworkRequest &amp;<i>request</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#open-2" translate="no">open</a></b>(const QUrl &amp;<i>url</i>, const QWebSocketHandshakeOptions &amp;<i>options</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#open-3" translate="no">open</a></b>(const QNetworkRequest &amp;<i>request</i>, const QWebSocketHandshakeOptions &amp;<i>options</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#ping" translate="no">ping</a></b>(const QByteArray &amp;<i>payload</i> = QByteArray())</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#aboutToClose" translate="no">aboutToClose</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#alertReceived" translate="no">alertReceived</a></b>(QSsl::AlertLevel <i>level</i>, QSsl::AlertType <i>type</i>, const QString &amp;<i>description</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#alertSent" translate="no">alertSent</a></b>(QSsl::AlertLevel <i>level</i>, QSsl::AlertType <i>type</i>, const QString &amp;<i>description</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#authenticationRequired" translate="no">authenticationRequired</a></b>(QAuthenticator *<i>authenticator</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#binaryFrameReceived" translate="no">binaryFrameReceived</a></b>(const QByteArray &amp;<i>frame</i>, bool <i>isLastFrame</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#binaryMessageReceived" translate="no">binaryMessageReceived</a></b>(const QByteArray &amp;<i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#bytesWritten" translate="no">bytesWritten</a></b>(qint64 <i>bytes</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#connected" translate="no">connected</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#disconnected" translate="no">disconnected</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#errorOccurred" translate="no">errorOccurred</a></b>(QAbstractSocket::SocketError <i>error</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#handshakeInterruptedOnError" translate="no">handshakeInterruptedOnError</a></b>(const QSslError &amp;<i>error</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#peerVerifyError" translate="no">peerVerifyError</a></b>(const QSslError &amp;<i>error</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#pong" translate="no">pong</a></b>(quint64 <i>elapsedTime</i>, const QByteArray &amp;<i>payload</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#preSharedKeyAuthenticationRequired" translate="no">preSharedKeyAuthenticationRequired</a></b>(QSslPreSharedKeyAuthenticator *<i>authenticator</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#proxyAuthenticationRequired" translate="no">proxyAuthenticationRequired</a></b>(const QNetworkProxy &amp;<i>proxy</i>, QAuthenticator *<i>authenticator</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#readChannelFinished" translate="no">readChannelFinished</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#sslErrors" translate="no">sslErrors</a></b>(const QList&lt;QSslError&gt; &amp;<i>errors</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#stateChanged" translate="no">stateChanged</a></b>(QAbstractSocket::SocketState <i>state</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#textFrameReceived" translate="no">textFrameReceived</a></b>(const QString &amp;<i>frame</i>, bool <i>isLastFrame</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#textMessageReceived" translate="no">textMessageReceived</a></b>(const QString &amp;<i>message</i>)</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> quint64 </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#maxIncomingFrameSize" translate="no">maxIncomingFrameSize</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint64 </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#maxIncomingMessageSize" translate="no">maxIncomingMessageSize</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint64 </td><td class="memItemRight bottomAlign"><b><a href="qwebsocket.html#maxOutgoingFrameSize" translate="no">maxOutgoingFrameSize</a></b>()</td></tr>
</table></div>
<!-- $$$QWebSocket-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>WebSockets is a web technology providing full-duplex communications channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as <a href="https://datatracker.ietf.org/doc/html/rfc6455" translate="no">RFC 6455</a> in 2011. QWebSocket can both be used in a client application and server application.</p>
<p>This class was modeled after <a href="../qtnetwork/qabstractsocket.html" translate="no">QAbstractSocket</a>.</p>
<p>QWebSocket currently does not support <a href="https://datatracker.ietf.org/doc/html/rfc6455#section-9" translate="no">WebSocket Extensions</a>.</p>
<p>QWebSocket only supports version 13 of the WebSocket protocol, as outlined in <a href="https://datatracker.ietf.org/doc/html/rfc6455" translate="no">RFC 6455</a>.</p>
<div class="admonition note">
<p><b>Note: </b>Some proxies do not understand certain HTTP headers used during a WebSocket handshake. In that case, non-secure WebSocket connections fail. The best way to mitigate against this problem is to use WebSocket over a secure connection.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>To generate masks, this implementation of WebSockets uses the reasonably secure <a href="../qtcore/qrandomgenerator.html#global" translate="no">QRandomGenerator::global</a>()-&gt;generate() function. For more information about the importance of good masking, see <a href="https://www.ieee-security.org/TC/W2SP/2011/papers/websocket.pdf" translate="no">&quot;Talking to Yourself for Fun and Profit&quot; by Lin-Shung Huang et al</a>. The best measure against attacks mentioned in the document above, is to use QWebSocket over a secure connection (<i>wss://</i>). In general, always be careful to not have 3rd party script access to a QWebSocket in your application.</p>
</div>
</div>
<p><b>See also </b><a href="../qtnetwork/qabstractsocket.html" translate="no">QAbstractSocket</a>, <a href="../qtnetwork/qtcpsocket.html" translate="no">QTcpSocket</a>, and <a href="echoclient.html" translate="no">QWebSocket client example</a>.</p>
<!-- @@@QWebSocket -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QWebSocket$$$QWebSocketconstQString&QWebSocketProtocol::VersionQObject* -->
<h3 class="fn" translate="no" id="QWebSocket-1"><code translate="no">[explicit] </code>QWebSocket::<span class="name">QWebSocket</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>origin</i> = QString(), <span class="type"><a href="qwebsocketprotocol.html#Version-enum" translate="no">QWebSocketProtocol::Version</a></span> <i>version</i> = QWebSocketProtocol::VersionLatest, <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Creates a new QWebSocket with the given <i translate="no">origin</i>, the <i translate="no">version</i> of the protocol to use and <i translate="no">parent</i>.</p>
<p>The <i translate="no">origin</i> of the client is as specified in <a href="https://datatracker.ietf.org/doc/html/rfc6454" translate="no">RFC 6454</a>. (The <i translate="no">origin</i> is not required for non-web browser clients (see <a href="https://datatracker.ietf.org/doc/html/rfc6455" translate="no">RFC 6455</a>)). The <i translate="no">origin</i> may not contain new line characters, otherwise the connection will be aborted immediately during the handshake phase.</p>
<div class="admonition note">
<p><b>Note: </b>Currently only V13 (<a href="https://datatracker.ietf.org/doc/html/rfc6455" translate="no">RFC 6455</a>) is supported</p>
</div>
<!-- @@@QWebSocket -->
<!-- $$$~QWebSocket[overload1]$$$~QWebSocket -->
<h3 class="fn" translate="no" id="dtor.QWebSocket"><code translate="no">[override virtual noexcept] </code>QWebSocket::<span class="name">~QWebSocket</span>()</h3>
<p>Destroys the <a href="qwebsocket.html" translate="no">QWebSocket</a>. Closes the socket if it is still open, and releases any used resources.</p>
<!-- @@@~QWebSocket -->
<!-- $$$abort[overload1]$$$abort -->
<h3 class="fn" translate="no" id="abort"><span class="type">void</span> QWebSocket::<span class="name">abort</span>()</h3>
<p>Aborts the current socket and resets the socket. Unlike <a href="qwebsocket.html#close" translate="no">close</a>(), this function immediately closes the socket, discarding any pending data in the write buffer.</p>
<!-- @@@abort -->
<!-- $$$aboutToClose[overload1]$$$aboutToClose -->
<h3 class="fn" translate="no" id="aboutToClose"><code translate="no">[signal] </code><span class="type">void</span> QWebSocket::<span class="name">aboutToClose</span>()</h3>
<p>This signal is emitted when the socket is about to close. Connect this signal if you have operations that need to be performed before the socket closes (e.g&#x2e;, if you have data in a separate buffer that needs to be written to the device).</p>
<p><b>See also </b><a href="qwebsocket.html#close" translate="no">close</a>().</p>
<!-- @@@aboutToClose -->
<!-- $$$alertReceived[overload1]$$$alertReceivedQSsl::AlertLevelQSsl::AlertTypeconstQString& -->
<h3 class="fn" translate="no" id="alertReceived"><code translate="no">[signal, since 6.2] </code><span class="type">void</span> QWebSocket::<span class="name">alertReceived</span>(<span class="type"><a href="../qtnetwork/qsslsocket.html#AlertLevel-enum" translate="no">QSsl::AlertLevel</a></span> <i>level</i>, <span class="type"><a href="../qtnetwork/qsslsocket.html#AlertType-enum" translate="no">QSsl::AlertType</a></span> <i>type</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>description</i>)</h3>
<p><a href="qwebsocket.html" translate="no">QWebSocket</a> emits this signal if an alert message was received from a peer. <i translate="no">level</i> tells if the alert was fatal or it was a warning. <i translate="no">type</i> is the code explaining why the alert was sent. When a textual description of the alert message is available, it is supplied in <i translate="no">description</i>.</p>
<div class="admonition note">
<p><b>Note: </b>The signal is mostly for informational and debugging purposes and does not require any handling in the application. If the alert was fatal, underlying backend will handle it and close the connection.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Not all backends support this functionality.</p>
</div>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qwebsocket.html#alertSent" translate="no">alertSent</a>(), <a href="../qtnetwork/qsslsocket.html#AlertLevel-enum" translate="no">QSsl::AlertLevel</a>, and <a href="../qtnetwork/qsslsocket.html#AlertType-enum" translate="no">QSsl::AlertType</a>.</p>
<!-- @@@alertReceived -->
<!-- $$$alertSent[overload1]$$$alertSentQSsl::AlertLevelQSsl::AlertTypeconstQString& -->
<h3 class="fn" translate="no" id="alertSent"><code translate="no">[signal, since 6.2] </code><span class="type">void</span> QWebSocket::<span class="name">alertSent</span>(<span class="type"><a href="../qtnetwork/qsslsocket.html#AlertLevel-enum" translate="no">QSsl::AlertLevel</a></span> <i>level</i>, <span class="type"><a href="../qtnetwork/qsslsocket.html#AlertType-enum" translate="no">QSsl::AlertType</a></span> <i>type</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>description</i>)</h3>
<p><a href="qwebsocket.html" translate="no">QWebSocket</a> emits this signal if an alert message was sent to a peer. <i translate="no">level</i> describes if it was a warning or a fatal error. <i translate="no">type</i> gives the code of the alert message. When a textual description of the alert message is available, it is supplied in <i translate="no">description</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This signal is mostly informational and can be used for debugging purposes, normally it does not require any actions from the application.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Not all backends support this functionality.</p>
</div>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qwebsocket.html#alertReceived" translate="no">alertReceived</a>(), <a href="../qtnetwork/qsslsocket.html#AlertLevel-enum" translate="no">QSsl::AlertLevel</a>, and <a href="../qtnetwork/qsslsocket.html#AlertType-enum" translate="no">QSsl::AlertType</a>.</p>
<!-- @@@alertSent -->
<!-- $$$authenticationRequired[overload1]$$$authenticationRequiredQAuthenticator* -->
<h3 class="fn" translate="no" id="authenticationRequired"><code translate="no">[signal, since 6.6] </code><span class="type">void</span> QWebSocket::<span class="name">authenticationRequired</span>(<span class="type"><a href="../qtnetwork/qauthenticator.html" translate="no">QAuthenticator</a></span> *<i>authenticator</i>)</h3>
<p>This signal is emitted when the server requires authentication. The <i translate="no">authenticator</i> object must then be filled in with the required details to allow authentication and continue the connection.</p>
<p>If you know that the server may require authentication, you can set the username and password on the initial <a href="../qtcore/qurl.html" translate="no">QUrl</a>, using <a href="../qtcore/qurl.html#setUserName" translate="no">QUrl::setUserName</a> and <a href="../qtcore/qurl.html#setPassword" translate="no">QUrl::setPassword</a>. <a href="qwebsocket.html" translate="no">QWebSocket</a> will still try to connect <i>once</i> without using the provided credentials.</p>
<div class="admonition note">
<p><b>Note: </b>It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</p>
</div>
<p>This function was introduced in Qt 6.6.</p>
<p><b>See also </b><a href="../qtnetwork/qauthenticator.html" translate="no">QAuthenticator</a>.</p>
<!-- @@@authenticationRequired -->
<!-- $$$binaryFrameReceived[overload1]$$$binaryFrameReceivedconstQByteArray&bool -->
<h3 class="fn" translate="no" id="binaryFrameReceived"><code translate="no">[signal] </code><span class="type">void</span> QWebSocket::<span class="name">binaryFrameReceived</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>frame</i>, <span class="type">bool</span> <i>isLastFrame</i>)</h3>
<p>This signal is emitted whenever a binary frame is received. The <i translate="no">frame</i> contains the data and <i translate="no">isLastFrame</i> indicates whether this is the last frame of the complete message.</p>
<p>This signal can be used to process large messages frame by frame, instead of waiting for the complete message to arrive.</p>
<p><b>See also </b><a href="qwebsocket.html#textFrameReceived" translate="no">textFrameReceived</a>().</p>
<!-- @@@binaryFrameReceived -->
<!-- $$$binaryMessageReceived[overload1]$$$binaryMessageReceivedconstQByteArray& -->
<h3 class="fn" translate="no" id="binaryMessageReceived"><code translate="no">[signal] </code><span class="type">void</span> QWebSocket::<span class="name">binaryMessageReceived</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>message</i>)</h3>
<p>This signal is emitted whenever a binary message is received. The <i translate="no">message</i> contains the received bytes.</p>
<p><b>See also </b><a href="qwebsocket.html#textMessageReceived" translate="no">textMessageReceived</a>().</p>
<!-- @@@binaryMessageReceived -->
<!-- $$$bytesToWrite[overload1]$$$bytesToWrite -->
<h3 class="fn" translate="no" id="bytesToWrite"><span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QWebSocket::<span class="name">bytesToWrite</span>() const</h3>
<p>Returns the number of bytes that are waiting to be written. The bytes are written when control goes back to the event loop or when <a href="qwebsocket.html#flush" translate="no">flush</a>() is called.</p>
<p><b>See also </b><a href="qwebsocket.html#flush" translate="no">flush</a>.</p>
<!-- @@@bytesToWrite -->
<!-- $$$bytesWritten[overload1]$$$bytesWrittenqint64 -->
<h3 class="fn" translate="no" id="bytesWritten"><code translate="no">[signal] </code><span class="type">void</span> QWebSocket::<span class="name">bytesWritten</span>(<span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>bytes</i>)</h3>
<p>This signal is emitted every time a payload of data has been written to the socket. The <i translate="no">bytes</i> argument is set to the number of bytes that were written in this payload.</p>
<div class="admonition note">
<p><b>Note: </b>This signal has the same meaning both for secure and non-secure WebSockets. As opposed to <a href="../qtnetwork/qsslsocket.html" translate="no">QSslSocket</a>, bytesWritten() is only emitted when encrypted data is effectively written (see <a href="../qtnetwork/qsslsocket.html#encryptedBytesWritten" translate="no">QSslSocket::encryptedBytesWritten</a>()).</p>
</div>
<p><b>See also </b><a href="qwebsocket.html#close" translate="no">close</a>().</p>
<!-- @@@bytesWritten -->
<!-- $$$close[overload1]$$$closeQWebSocketProtocol::CloseCodeconstQString& -->
<h3 class="fn" translate="no" id="close"><code translate="no">[slot] </code><span class="type">void</span> QWebSocket::<span class="name">close</span>(<span class="type"><a href="qwebsocketprotocol.html#CloseCode-enum" translate="no">QWebSocketProtocol::CloseCode</a></span> <i>closeCode</i> = QWebSocketProtocol::CloseCodeNormal, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>reason</i> = QString())</h3>
<p>Gracefully closes the socket with the given <i translate="no">closeCode</i> and <i translate="no">reason</i>.</p>
<p>Any data in the write buffer is flushed before the socket is closed. The <i translate="no">closeCode</i> is a <a href="qwebsocketprotocol.html#CloseCode-enum" translate="no">QWebSocketProtocol::CloseCode</a> indicating the reason to close, and <i translate="no">reason</i> describes the reason of the closure more in detail. All control frames, including the Close frame, are limited to 125 bytes. Since two of these are used for <i translate="no">closeCode</i> the maximum length of <i translate="no">reason</i> is 123! If <i translate="no">reason</i> exceeds this limit it will be truncated.</p>
<!-- @@@close -->
<!-- $$$closeCode[overload1]$$$closeCode -->
<h3 class="fn" translate="no" id="closeCode"><span class="type"><a href="qwebsocketprotocol.html#CloseCode-enum" translate="no">QWebSocketProtocol::CloseCode</a></span> QWebSocket::<span class="name">closeCode</span>() const</h3>
<p>Returns the code indicating why the socket was closed.</p>
<p><b>See also </b><a href="qwebsocketprotocol.html#CloseCode-enum" translate="no">QWebSocketProtocol::CloseCode</a> and <a href="qwebsocket.html#closeReason" translate="no">closeReason</a>().</p>
<!-- @@@closeCode -->
<!-- $$$closeReason[overload1]$$$closeReason -->
<h3 class="fn" translate="no" id="closeReason"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QWebSocket::<span class="name">closeReason</span>() const</h3>
<p>Returns the reason why the socket was closed.</p>
<p><b>See also </b><a href="qwebsocket.html#closeCode" translate="no">closeCode</a>().</p>
<!-- @@@closeReason -->
<!-- $$$connected[overload1]$$$connected -->
<h3 class="fn" translate="no" id="connected"><code translate="no">[signal] </code><span class="type">void</span> QWebSocket::<span class="name">connected</span>()</h3>
<p>Emitted when a connection is successfully established. A connection is successfully established when the socket is connected and the handshake was successful.</p>
<p><b>See also </b><a href="qwebsocket.html#open" translate="no">open</a>() and <a href="qwebsocket.html#disconnected" translate="no">disconnected</a>().</p>
<!-- @@@connected -->
<!-- $$$continueInterruptedHandshake[overload1]$$$continueInterruptedHandshake -->
<h3 class="fn" translate="no" id="continueInterruptedHandshake"><code translate="no">[since 6.2] </code><span class="type">void</span> QWebSocket::<span class="name">continueInterruptedHandshake</span>()</h3>
<p>If an application wants to conclude a handshake even after receiving <a href="qwebsocket.html#handshakeInterruptedOnError" translate="no">handshakeInterruptedOnError</a>() signal, it must call this function. This call must be done from a slot function attached to the signal. The signal-slot connection must be direct.</p>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qwebsocket.html#handshakeInterruptedOnError" translate="no">handshakeInterruptedOnError</a>() and <a href="../qtnetwork/qsslconfiguration.html#setHandshakeMustInterruptOnError" translate="no">QSslConfiguration::setHandshakeMustInterruptOnError</a>().</p>
<!-- @@@continueInterruptedHandshake -->
<!-- $$$disconnected[overload1]$$$disconnected -->
<h3 class="fn" translate="no" id="disconnected"><code translate="no">[signal] </code><span class="type">void</span> QWebSocket::<span class="name">disconnected</span>()</h3>
<p>Emitted when the socket is disconnected.</p>
<p><b>See also </b><a href="qwebsocket.html#close" translate="no">close</a>() and <a href="qwebsocket.html#connected" translate="no">connected</a>().</p>
<!-- @@@disconnected -->
<!-- $$$error[overload1]$$$error -->
<h3 class="fn" translate="no" id="error"><span class="type"><a href="../qtnetwork/qabstractsocket.html#SocketError-enum" translate="no">QAbstractSocket::SocketError</a></span> QWebSocket::<span class="name">error</span>() const</h3>
<p>Returns the type of error that last occurred</p>
<p><b>See also </b><a href="qwebsocket.html#errorString" translate="no">errorString</a>().</p>
<!-- @@@error -->
<!-- $$$errorOccurred[overload1]$$$errorOccurredQAbstractSocket::SocketError -->
<h3 class="fn" translate="no" id="errorOccurred"><code translate="no">[signal, since 6.5] </code><span class="type">void</span> QWebSocket::<span class="name">errorOccurred</span>(<span class="type"><a href="../qtnetwork/qabstractsocket.html#SocketError-enum" translate="no">QAbstractSocket::SocketError</a></span> <i>error</i>)</h3>
<p>This signal is emitted after an error occurred.</p>
<p>The <i translate="no">error</i> parameter describes the type of error that occurred.</p>
<p><a href="../qtnetwork/qabstractsocket.html#SocketError-enum" translate="no">QAbstractSocket::SocketError</a> is not a registered metatype, so for queued connections, you will have to register it with <a href="../qtcore/qmetatype.html#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a>() and <a href="../qtcore/qmetatype.html#qRegisterMetaType-3" translate="no">qRegisterMetaType</a>().</p>
<p>This function was introduced in Qt 6.5.</p>
<p><b>See also </b><a href="qwebsocket.html#error" translate="no">error</a>() and <a href="qwebsocket.html#errorString" translate="no">errorString</a>().</p>
<!-- @@@errorOccurred -->
<!-- $$$errorString[overload1]$$$errorString -->
<h3 class="fn" translate="no" id="errorString"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QWebSocket::<span class="name">errorString</span>() const</h3>
<p>Returns a human-readable description of the last error that occurred</p>
<p><b>See also </b><a href="qwebsocket.html#error" translate="no">error</a>().</p>
<!-- @@@errorString -->
<!-- $$$flush[overload1]$$$flush -->
<h3 class="fn" translate="no" id="flush"><span class="type">bool</span> QWebSocket::<span class="name">flush</span>()</h3>
<p>This function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns true; otherwise false is returned. Call this function if you need <a href="qwebsocket.html" translate="no">QWebSocket</a> to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because <a href="qwebsocket.html" translate="no">QWebSocket</a> will start sending data automatically once control goes back to the event loop.</p>
<!-- @@@flush -->
<!-- $$$handshakeInterruptedOnError[overload1]$$$handshakeInterruptedOnErrorconstQSslError& -->
<h3 class="fn" translate="no" id="handshakeInterruptedOnError"><code translate="no">[signal, since 6.2] </code><span class="type">void</span> QWebSocket::<span class="name">handshakeInterruptedOnError</span>(const <span class="type"><a href="../qtnetwork/qsslerror.html" translate="no">QSslError</a></span> &amp;<i>error</i>)</h3>
<p><a href="qwebsocket.html" translate="no">QWebSocket</a> emits this signal if a certificate verification error was found and if early error reporting was enabled in <a href="../qtnetwork/qsslconfiguration.html" translate="no">QSslConfiguration</a>. An application is expected to inspect the <i translate="no">error</i> and decide if it wants to continue the handshake, or abort it and send an alert message to the peer. The signal-slot connection must be direct.</p>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qwebsocket.html#continueInterruptedHandshake" translate="no">continueInterruptedHandshake</a>(), <a href="qwebsocket.html#sslErrors" translate="no">sslErrors</a>(), and <a href="../qtnetwork/qsslconfiguration.html#setHandshakeMustInterruptOnError" translate="no">QSslConfiguration::setHandshakeMustInterruptOnError</a>().</p>
<!-- @@@handshakeInterruptedOnError -->
<!-- $$$handshakeOptions[overload1]$$$handshakeOptions -->
<h3 class="fn" translate="no" id="handshakeOptions"><code translate="no">[since 6.4] </code><span class="type"><a href="qwebsockethandshakeoptions.html" translate="no">QWebSocketHandshakeOptions</a></span> QWebSocket::<span class="name">handshakeOptions</span>() const</h3>
<p>Returns the handshake options that were used to open this socket.</p>
<p>This function was introduced in Qt 6.4.</p>
<!-- @@@handshakeOptions -->
<!-- $$$ignoreSslErrors[overload1]$$$ignoreSslErrors -->
<h3 class="fn" translate="no" id="ignoreSslErrors"><code translate="no">[slot] </code><span class="type">void</span> QWebSocket::<span class="name">ignoreSslErrors</span>()</h3>
<p>This slot tells <a href="qwebsocket.html" translate="no">QWebSocket</a> to ignore errors during <a href="qwebsocket.html" translate="no">QWebSocket</a>'s handshake phase and continue connecting. If you want to continue with the connection even if errors occur during the handshake phase, then you must call this slot, either from a slot connected to <a href="qwebsocket.html#sslErrors" translate="no">sslErrors</a>(), or before the handshake phase. If you don't call this slot, either in response to errors or before the handshake, the connection will be dropped after the <a href="qwebsocket.html#sslErrors" translate="no">sslErrors</a>() signal has been emitted.</p>
<div class="admonition warning">
<p><b>Warning: </b>Be sure to always let the user inspect the errors reported by the <a href="qwebsocket.html#sslErrors" translate="no">sslErrors</a>() signal, and only call this method upon confirmation from the user that proceeding is ok. If there are unexpected errors, the connection should be aborted. Calling this method without inspecting the actual errors will most likely pose a security risk for your application. Use it with great care!</p>
</div>
<p><b>See also </b><a href="qwebsocket.html#sslErrors" translate="no">sslErrors</a>(), <a href="../qtnetwork/qsslsocket.html#ignoreSslErrors" translate="no">QSslSocket::ignoreSslErrors</a>(), and <a href="../qtnetwork/qnetworkreply.html#ignoreSslErrors" translate="no">QNetworkReply::ignoreSslErrors</a>().</p>
<!-- @@@ignoreSslErrors -->
<!-- $$$ignoreSslErrors$$$ignoreSslErrorsconstQList<QSslError>& -->
<h3 class="fn" translate="no" id="ignoreSslErrors-1"><span class="type">void</span> QWebSocket::<span class="name">ignoreSslErrors</span>(const <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="../qtnetwork/qsslerror.html" translate="no">QSslError</a></span>&gt; &amp;<i>errors</i>)</h3>
<p>This is an overloaded function.</p>
<p>This method tells <a href="qwebsocket.html" translate="no">QWebSocket</a> to ignore the errors given in <i translate="no">errors</i>.</p>
<p>Note that you can set the expected certificate in the SSL error: If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtnetwork/qsslcertificate.html" translate="no">QSslCertificate</a></span><span class="operator">&gt;</span> cert <span class="operator">=</span> <span class="type"><a href="../qtnetwork/qsslcertificate.html" translate="no">QSslCertificate</a></span><span class="operator">::</span>fromPath(QLatin1String(<span class="string">&quot;server-certificate.pem&quot;</span>));
 <span class="type"><a href="../qtnetwork/qsslerror.html" translate="no">QSslError</a></span> error(<span class="type"><a href="../qtnetwork/qsslerror.html" translate="no">QSslError</a></span><span class="operator">::</span>SelfSignedCertificate<span class="operator">,</span> cert<span class="operator">.</span>at(<span class="number">0</span>));
 <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtnetwork/qsslerror.html" translate="no">QSslError</a></span><span class="operator">&gt;</span> expectedSslErrors;
 expectedSslErrors<span class="operator">.</span>append(error);

 <span class="type">QWebSocket</span> socket;
 socket<span class="operator">.</span>ignoreSslErrors(expectedSslErrors);
 socket<span class="operator">.</span>open(<span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span>(<span class="type"><a href="../qtcore/qstring.html#QStringLiteral" translate="no">QStringLiteral</a></span>(<span class="string">&quot;wss://myserver.at.home&quot;</span>)));
</pre>
<p>Multiple calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.</p>
<p><b>See also </b><a href="qwebsocket.html#sslErrors" translate="no">sslErrors</a>().</p>
<!-- @@@ignoreSslErrors -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" translate="no" id="isValid"><span class="type">bool</span> QWebSocket::<span class="name">isValid</span>() const</h3>
<p>Returns <code translate="no">true</code> if the socket is ready for reading and writing; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@isValid -->
<!-- $$$localAddress[overload1]$$$localAddress -->
<h3 class="fn" translate="no" id="localAddress"><span class="type"><a href="../qtnetwork/qhostaddress.html" translate="no">QHostAddress</a></span> QWebSocket::<span class="name">localAddress</span>() const</h3>
<p>Returns the local address</p>
<!-- @@@localAddress -->
<!-- $$$localPort[overload1]$$$localPort -->
<h3 class="fn" translate="no" id="localPort"><span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> QWebSocket::<span class="name">localPort</span>() const</h3>
<p>Returns the local port</p>
<!-- @@@localPort -->
<!-- $$$maskGenerator[overload1]$$$maskGenerator -->
<h3 class="fn" translate="no" id="maskGenerator">const <span class="type"><a href="qmaskgenerator.html" translate="no">QMaskGenerator</a></span> *QWebSocket::<span class="name">maskGenerator</span>() const</h3>
<p>Returns the mask generator that is currently used by this <a href="qwebsocket.html" translate="no">QWebSocket</a>.</p>
<p><b>See also </b><a href="qwebsocket.html#setMaskGenerator" translate="no">setMaskGenerator</a>().</p>
<!-- @@@maskGenerator -->
<!-- $$$maxAllowedIncomingFrameSize[overload1]$$$maxAllowedIncomingFrameSize -->
<h3 class="fn" translate="no" id="maxAllowedIncomingFrameSize"><span class="type"><a href="../qtcore/qttypes.html#quint64-typedef" translate="no">quint64</a></span> QWebSocket::<span class="name">maxAllowedIncomingFrameSize</span>() const</h3>
<p>Returns the maximum allowed size of an incoming websocket frame.</p>
<p><b>See also </b><a href="qwebsocket.html#setMaxAllowedIncomingFrameSize" translate="no">setMaxAllowedIncomingFrameSize</a>().</p>
<!-- @@@maxAllowedIncomingFrameSize -->
<!-- $$$maxAllowedIncomingMessageSize[overload1]$$$maxAllowedIncomingMessageSize -->
<h3 class="fn" translate="no" id="maxAllowedIncomingMessageSize"><span class="type"><a href="../qtcore/qttypes.html#quint64-typedef" translate="no">quint64</a></span> QWebSocket::<span class="name">maxAllowedIncomingMessageSize</span>() const</h3>
<p>Returns the maximum allowed size of an incoming websocket message.</p>
<p><b>See also </b><a href="qwebsocket.html#setMaxAllowedIncomingMessageSize" translate="no">setMaxAllowedIncomingMessageSize</a>().</p>
<!-- @@@maxAllowedIncomingMessageSize -->
<!-- $$$maxIncomingFrameSize[overload1]$$$maxIncomingFrameSize -->
<h3 class="fn" translate="no" id="maxIncomingFrameSize"><code translate="no">[static] </code><span class="type"><a href="../qtcore/qttypes.html#quint64-typedef" translate="no">quint64</a></span> QWebSocket::<span class="name">maxIncomingFrameSize</span>()</h3>
<p>Returns the maximum supported size of an incoming websocket frame for this websocket implementation.</p>
<!-- @@@maxIncomingFrameSize -->
<!-- $$$maxIncomingMessageSize[overload1]$$$maxIncomingMessageSize -->
<h3 class="fn" translate="no" id="maxIncomingMessageSize"><code translate="no">[static] </code><span class="type"><a href="../qtcore/qttypes.html#quint64-typedef" translate="no">quint64</a></span> QWebSocket::<span class="name">maxIncomingMessageSize</span>()</h3>
<p>Returns the maximum supported size of an incoming websocket message for this websocket implementation.</p>
<!-- @@@maxIncomingMessageSize -->
<!-- $$$maxOutgoingFrameSize[overload1]$$$maxOutgoingFrameSize -->
<h3 class="fn" translate="no" id="maxOutgoingFrameSize"><code translate="no">[static] </code><span class="type"><a href="../qtcore/qttypes.html#quint64-typedef" translate="no">quint64</a></span> QWebSocket::<span class="name">maxOutgoingFrameSize</span>()</h3>
<p>Returns the maximum supported size of an outgoing websocket frame for this websocket implementation.</p>
<!-- @@@maxOutgoingFrameSize -->
<!-- $$$open[overload1]$$$openconstQUrl& -->
<h3 class="fn" translate="no" id="open"><code translate="no">[slot] </code><span class="type">void</span> QWebSocket::<span class="name">open</span>(const <span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span> &amp;<i>url</i>)</h3>
<p>Opens a WebSocket connection using the given <i translate="no">url</i>.</p>
<p>If the url contains newline characters (\r\n), then the error signal will be emitted with <a href="../qtnetwork/qabstractsocket.html#SocketError-enum" translate="no">QAbstractSocket::ConnectionRefusedError</a> as error type.</p>
<!-- @@@open -->
<!-- $$$open$$$openconstQNetworkRequest& -->
<h3 class="fn" translate="no" id="open-1"><code translate="no">[slot] </code><span class="type">void</span> QWebSocket::<span class="name">open</span>(const <span class="type"><a href="../qtnetwork/qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>request</i>)</h3>
<p>Opens a WebSocket connection using the given <i translate="no">request</i>.</p>
<p>The <i translate="no">request</i> url will be used to open the WebSocket connection. Headers present in the request will be sent to the server in the upgrade request, together with the ones needed for the websocket handshake.</p>
<!-- @@@open -->
<!-- $$$open$$$openconstQUrl&constQWebSocketHandshakeOptions& -->
<h3 class="fn" translate="no" id="open-2"><code translate="no">[slot, since 6.4] </code><span class="type">void</span> QWebSocket::<span class="name">open</span>(const <span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span> &amp;<i>url</i>, const <span class="type"><a href="qwebsockethandshakeoptions.html" translate="no">QWebSocketHandshakeOptions</a></span> &amp;<i>options</i>)</h3>
<p>Opens a WebSocket connection using the given <i translate="no">url</i> and <i translate="no">options</i>.</p>
<p>If the url contains newline characters (\r\n), then the error signal will be emitted with <a href="../qtnetwork/qabstractsocket.html#SocketError-enum" translate="no">QAbstractSocket::ConnectionRefusedError</a> as error type.</p>
<p>Additional options for the WebSocket handshake such as subprotocols can be specified in <i translate="no">options</i>.</p>
<p>This function was introduced in Qt 6.4.</p>
<!-- @@@open -->
<!-- $$$open$$$openconstQNetworkRequest&constQWebSocketHandshakeOptions& -->
<h3 class="fn" translate="no" id="open-3"><code translate="no">[slot, since 6.4] </code><span class="type">void</span> QWebSocket::<span class="name">open</span>(const <span class="type"><a href="../qtnetwork/qnetworkrequest.html" translate="no">QNetworkRequest</a></span> &amp;<i>request</i>, const <span class="type"><a href="qwebsockethandshakeoptions.html" translate="no">QWebSocketHandshakeOptions</a></span> &amp;<i>options</i>)</h3>
<p>Opens a WebSocket connection using the given <i translate="no">request</i> and <i translate="no">options</i>.</p>
<p>The <i translate="no">request</i> url will be used to open the WebSocket connection. Headers present in the request will be sent to the server in the upgrade request, together with the ones needed for the websocket handshake.</p>
<p>Additional options for the WebSocket handshake such as subprotocols can be specified in <i translate="no">options</i>.</p>
<p>This function was introduced in Qt 6.4.</p>
<!-- @@@open -->
<!-- $$$origin[overload1]$$$origin -->
<h3 class="fn" translate="no" id="origin"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QWebSocket::<span class="name">origin</span>() const</h3>
<p>Returns the current origin.</p>
<!-- @@@origin -->
<!-- $$$outgoingFrameSize[overload1]$$$outgoingFrameSize -->
<h3 class="fn" translate="no" id="outgoingFrameSize"><span class="type"><a href="../qtcore/qttypes.html#quint64-typedef" translate="no">quint64</a></span> QWebSocket::<span class="name">outgoingFrameSize</span>() const</h3>
<p>Returns the maximum size of an outgoing websocket frame.</p>
<p><b>See also </b><a href="qwebsocket.html#setOutgoingFrameSize" translate="no">setOutgoingFrameSize</a>().</p>
<!-- @@@outgoingFrameSize -->
<!-- $$$pauseMode[overload1]$$$pauseMode -->
<h3 class="fn" translate="no" id="pauseMode"><span class="type"><a href="../qtnetwork/qabstractsocket.html#PauseMode-enum" translate="no">QAbstractSocket::PauseModes</a></span> QWebSocket::<span class="name">pauseMode</span>() const</h3>
<p>Returns the pause mode of this socket</p>
<p><b>See also </b><a href="qwebsocket.html#setPauseMode" translate="no">setPauseMode</a>().</p>
<!-- @@@pauseMode -->
<!-- $$$peerAddress[overload1]$$$peerAddress -->
<h3 class="fn" translate="no" id="peerAddress"><span class="type"><a href="../qtnetwork/qhostaddress.html" translate="no">QHostAddress</a></span> QWebSocket::<span class="name">peerAddress</span>() const</h3>
<p>Returns the peer address</p>
<!-- @@@peerAddress -->
<!-- $$$peerName[overload1]$$$peerName -->
<h3 class="fn" translate="no" id="peerName"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QWebSocket::<span class="name">peerName</span>() const</h3>
<p>Returns the peerName</p>
<!-- @@@peerName -->
<!-- $$$peerPort[overload1]$$$peerPort -->
<h3 class="fn" translate="no" id="peerPort"><span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> QWebSocket::<span class="name">peerPort</span>() const</h3>
<p>Returns the peerport</p>
<!-- @@@peerPort -->
<!-- $$$peerVerifyError[overload1]$$$peerVerifyErrorconstQSslError& -->
<h3 class="fn" translate="no" id="peerVerifyError"><code translate="no">[signal, since 6.2] </code><span class="type">void</span> QWebSocket::<span class="name">peerVerifyError</span>(const <span class="type"><a href="../qtnetwork/qsslerror.html" translate="no">QSslError</a></span> &amp;<i>error</i>)</h3>
<p><a href="qwebsocket.html" translate="no">QWebSocket</a> can emit this signal several times during the SSL handshake, before encryption has been established, to indicate that an error has occurred while establishing the identity of the peer. The <i translate="no">error</i> is usually an indication that <a href="qwebsocket.html" translate="no">QWebSocket</a> is unable to securely identify the peer.</p>
<p>This signal provides you with an early indication when something's wrong. By connecting to this signal, you can manually choose to tear down the connection from inside the connected slot before the handshake has completed. If no action is taken, <a href="qwebsocket.html" translate="no">QWebSocket</a> will proceed to emitting <a href="qwebsocket.html#sslErrors" translate="no">QWebSocket::sslErrors</a>().</p>
<p>This function was introduced in Qt 6.2.</p>
<p><b>See also </b><a href="qwebsocket.html#sslErrors" translate="no">sslErrors</a>().</p>
<!-- @@@peerVerifyError -->
<!-- $$$ping[overload1]$$$pingconstQByteArray& -->
<h3 class="fn" translate="no" id="ping"><code translate="no">[slot] </code><span class="type">void</span> QWebSocket::<span class="name">ping</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>payload</i> = QByteArray())</h3>
<p>Pings the server to indicate that the connection is still alive. Additional <i translate="no">payload</i> can be sent along the ping message.</p>
<p>The size of the <i translate="no">payload</i> cannot be bigger than 125. If it is larger, the <i translate="no">payload</i> is clipped to 125 bytes.</p>
<div class="admonition note">
<p><b>Note: </b><a href="qwebsocket.html" translate="no">QWebSocket</a> and <a href="qwebsocketserver.html" translate="no">QWebSocketServer</a> handles ping requests internally, which means they automatically send back a pong response to the peer.</p>
</div>
<p><b>See also </b><a href="qwebsocket.html#pong" translate="no">pong</a>().</p>
<!-- @@@ping -->
<!-- $$$pong[overload1]$$$pongquint64constQByteArray& -->
<h3 class="fn" translate="no" id="pong"><code translate="no">[signal] </code><span class="type">void</span> QWebSocket::<span class="name">pong</span>(<span class="type"><a href="../qtcore/qttypes.html#quint64-typedef" translate="no">quint64</a></span> <i>elapsedTime</i>, const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>payload</i>)</h3>
<p>Emitted when a pong message is received in reply to a previous ping. <i translate="no">elapsedTime</i> contains the roundtrip time in milliseconds and <i translate="no">payload</i> contains an optional payload that was sent with the ping.</p>
<p><b>See also </b><a href="qwebsocket.html#ping" translate="no">ping</a>().</p>
<!-- @@@pong -->
<!-- $$$preSharedKeyAuthenticationRequired[overload1]$$$preSharedKeyAuthenticationRequiredQSslPreSharedKeyAuthenticator* -->
<h3 class="fn" translate="no" id="preSharedKeyAuthenticationRequired"><code translate="no">[signal] </code><span class="type">void</span> QWebSocket::<span class="name">preSharedKeyAuthenticationRequired</span>(<span class="type"><a href="../qtnetwork/qsslpresharedkeyauthenticator.html" translate="no">QSslPreSharedKeyAuthenticator</a></span> *<i>authenticator</i>)</h3>
<p>This signal is emitted if the SSL/TLS handshake negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.</p>
<p>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed <i translate="no">authenticator</i> object according to their needs.</p>
<div class="admonition note">
<p><b>Note: </b>Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The <i translate="no">authenticator</i> object is owned by the websocket and must not be deleted by the application.</p>
</div>
<p><b>See also </b><a href="../qtnetwork/qsslpresharedkeyauthenticator.html" translate="no">QSslPreSharedKeyAuthenticator</a> and <a href="../qtnetwork/qsslsocket.html#preSharedKeyAuthenticationRequired" translate="no">QSslSocket::preSharedKeyAuthenticationRequired</a>().</p>
<!-- @@@preSharedKeyAuthenticationRequired -->
<!-- $$$proxy[overload1]$$$proxy -->
<h3 class="fn" translate="no" id="proxy"><span class="type"><a href="../qtnetwork/qnetworkproxy.html" translate="no">QNetworkProxy</a></span> QWebSocket::<span class="name">proxy</span>() const</h3>
<p>Returns the currently configured proxy</p>
<p><b>See also </b><a href="qwebsocket.html#setProxy" translate="no">setProxy</a>().</p>
<!-- @@@proxy -->
<!-- $$$proxyAuthenticationRequired[overload1]$$$proxyAuthenticationRequiredconstQNetworkProxy&QAuthenticator* -->
<h3 class="fn" translate="no" id="proxyAuthenticationRequired"><code translate="no">[signal] </code><span class="type">void</span> QWebSocket::<span class="name">proxyAuthenticationRequired</span>(const <span class="type"><a href="../qtnetwork/qnetworkproxy.html" translate="no">QNetworkProxy</a></span> &amp;<i>proxy</i>, <span class="type"><a href="../qtnetwork/qauthenticator.html" translate="no">QAuthenticator</a></span> *<i>authenticator</i>)</h3>
<p>This signal can be emitted when a <i translate="no">proxy</i> that requires authentication is used. The <i translate="no">authenticator</i> object can then be filled in with the required details to allow authentication and continue the connection.</p>
<div class="admonition note">
<p><b>Note: </b>It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</p>
</div>
<p><b>See also </b><a href="../qtnetwork/qauthenticator.html" translate="no">QAuthenticator</a> and <a href="../qtnetwork/qnetworkproxy.html" translate="no">QNetworkProxy</a>.</p>
<!-- @@@proxyAuthenticationRequired -->
<!-- $$$readBufferSize[overload1]$$$readBufferSize -->
<h3 class="fn" translate="no" id="readBufferSize"><span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QWebSocket::<span class="name">readBufferSize</span>() const</h3>
<p>Returns the size in bytes of the readbuffer that is used by the socket.</p>
<p><b>See also </b><a href="qwebsocket.html#setReadBufferSize" translate="no">setReadBufferSize</a>().</p>
<!-- @@@readBufferSize -->
<!-- $$$readChannelFinished[overload1]$$$readChannelFinished -->
<h3 class="fn" translate="no" id="readChannelFinished"><code translate="no">[signal] </code><span class="type">void</span> QWebSocket::<span class="name">readChannelFinished</span>()</h3>
<p>This signal is emitted when the input (reading) stream is closed in this device. It is emitted as soon as the closing is detected.</p>
<p><b>See also </b><a href="qwebsocket.html#close" translate="no">close</a>().</p>
<!-- @@@readChannelFinished -->
<!-- $$$request[overload1]$$$request -->
<h3 class="fn" translate="no" id="request"><span class="type"><a href="../qtnetwork/qnetworkrequest.html" translate="no">QNetworkRequest</a></span> QWebSocket::<span class="name">request</span>() const</h3>
<p>Returns the request that was or will be used to open this socket.</p>
<!-- @@@request -->
<!-- $$$requestUrl[overload1]$$$requestUrl -->
<h3 class="fn" translate="no" id="requestUrl"><span class="type"><a href="../qtcore/qurl.html" translate="no">QUrl</a></span> QWebSocket::<span class="name">requestUrl</span>() const</h3>
<p>Returns the url the socket is connected to or will connect to.</p>
<!-- @@@requestUrl -->
<!-- $$$resourceName[overload1]$$$resourceName -->
<h3 class="fn" translate="no" id="resourceName"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QWebSocket::<span class="name">resourceName</span>() const</h3>
<p>Returns the name of the resource currently accessed.</p>
<!-- @@@resourceName -->
<!-- $$$resume[overload1]$$$resume -->
<h3 class="fn" translate="no" id="resume"><span class="type">void</span> QWebSocket::<span class="name">resume</span>()</h3>
<p>Continues data transfer on the socket. This method should only be used after the socket has been set to pause upon notifications and a notification has been received. The only notification currently supported is <a href="qwebsocket.html#sslErrors" translate="no">sslErrors</a>(). Calling this method if the socket is not paused results in undefined behavior.</p>
<p><b>See also </b><a href="qwebsocket.html#pauseMode" translate="no">pauseMode</a>() and <a href="qwebsocket.html#setPauseMode" translate="no">setPauseMode</a>().</p>
<!-- @@@resume -->
<!-- $$$sendBinaryMessage[overload1]$$$sendBinaryMessageconstQByteArray& -->
<h3 class="fn" translate="no" id="sendBinaryMessage"><span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QWebSocket::<span class="name">sendBinaryMessage</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>)</h3>
<p>Sends the given <i translate="no">data</i> over the socket as a binary message and returns the number of bytes actually sent.</p>
<p><b>See also </b><a href="qwebsocket.html#sendTextMessage" translate="no">sendTextMessage</a>().</p>
<!-- @@@sendBinaryMessage -->
<!-- $$$sendTextMessage[overload1]$$$sendTextMessageconstQString& -->
<h3 class="fn" translate="no" id="sendTextMessage"><span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QWebSocket::<span class="name">sendTextMessage</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>message</i>)</h3>
<p>Sends the given <i translate="no">message</i> over the socket as a text message and returns the number of bytes actually sent.</p>
<p><b>See also </b><a href="qwebsocket.html#sendBinaryMessage" translate="no">sendBinaryMessage</a>().</p>
<!-- @@@sendTextMessage -->
<!-- $$$setMaskGenerator[overload1]$$$setMaskGeneratorconstQMaskGenerator* -->
<h3 class="fn" translate="no" id="setMaskGenerator"><span class="type">void</span> QWebSocket::<span class="name">setMaskGenerator</span>(const <span class="type"><a href="qmaskgenerator.html" translate="no">QMaskGenerator</a></span> *<i>maskGenerator</i>)</h3>
<p>Sets the generator to use for creating masks to <i translate="no">maskGenerator</i>. The default <a href="qwebsocket.html" translate="no">QWebSocket</a> generator can be reset by supplying a <i>nullptr</i>. The mask generator can be changed at any time, even while the connection is open.</p>
<p><b>See also </b><a href="qwebsocket.html#maskGenerator" translate="no">maskGenerator</a>().</p>
<!-- @@@setMaskGenerator -->
<!-- $$$setMaxAllowedIncomingFrameSize[overload1]$$$setMaxAllowedIncomingFrameSizequint64 -->
<h3 class="fn" translate="no" id="setMaxAllowedIncomingFrameSize"><span class="type">void</span> QWebSocket::<span class="name">setMaxAllowedIncomingFrameSize</span>(<span class="type"><a href="../qtcore/qttypes.html#quint64-typedef" translate="no">quint64</a></span> <i>maxAllowedIncomingFrameSize</i>)</h3>
<p>Sets the maximum allowed size of an incoming websocket frame to <i translate="no">maxAllowedIncomingFrameSize</i>. If an incoming frame exceeds this limit, the peer gets disconnected. The accepted range is between 0 and <a href="qwebsocket.html#maxIncomingFrameSize" translate="no">maxIncomingFrameSize</a>(), default is <a href="qwebsocket.html#maxIncomingFrameSize" translate="no">maxIncomingFrameSize</a>(). The purpose of this function is to avoid exhausting virtual memory.</p>
<p><b>See also </b><a href="qwebsocket.html#maxAllowedIncomingFrameSize" translate="no">maxAllowedIncomingFrameSize</a>().</p>
<!-- @@@setMaxAllowedIncomingFrameSize -->
<!-- $$$setMaxAllowedIncomingMessageSize[overload1]$$$setMaxAllowedIncomingMessageSizequint64 -->
<h3 class="fn" translate="no" id="setMaxAllowedIncomingMessageSize"><span class="type">void</span> QWebSocket::<span class="name">setMaxAllowedIncomingMessageSize</span>(<span class="type"><a href="../qtcore/qttypes.html#quint64-typedef" translate="no">quint64</a></span> <i>maxAllowedIncomingMessageSize</i>)</h3>
<p>Sets the maximum allowed size of an incoming websocket message to <i translate="no">maxAllowedIncomingMessageSize</i>. If an incoming message exceeds this limit, the peer gets disconnected. The accepted range is between 0 and <a href="qwebsocket.html#maxIncomingMessageSize" translate="no">maxIncomingMessageSize</a>(), default is <a href="qwebsocket.html#maxIncomingMessageSize" translate="no">maxIncomingMessageSize</a>(). The purpose of this function is to avoid exhausting virtual memory.</p>
<p><b>See also </b><a href="qwebsocket.html#maxAllowedIncomingMessageSize" translate="no">maxAllowedIncomingMessageSize</a>().</p>
<!-- @@@setMaxAllowedIncomingMessageSize -->
<!-- $$$setOutgoingFrameSize[overload1]$$$setOutgoingFrameSizequint64 -->
<h3 class="fn" translate="no" id="setOutgoingFrameSize"><span class="type">void</span> QWebSocket::<span class="name">setOutgoingFrameSize</span>(<span class="type"><a href="../qtcore/qttypes.html#quint64-typedef" translate="no">quint64</a></span> <i>outgoingFrameSize</i>)</h3>
<p>Sets the maximum size of an outgoing websocket frame to <i translate="no">outgoingFrameSize</i>. The accepted range is between 0 and <a href="qwebsocket.html#maxOutgoingFrameSize" translate="no">maxOutgoingFrameSize</a>(), default is 512kB. The purpose of this function is to adapt to the maximum allowed frame size of the receiver.</p>
<p><b>See also </b><a href="qwebsocket.html#outgoingFrameSize" translate="no">outgoingFrameSize</a>().</p>
<!-- @@@setOutgoingFrameSize -->
<!-- $$$setPauseMode[overload1]$$$setPauseModeQAbstractSocket::PauseModes -->
<h3 class="fn" translate="no" id="setPauseMode"><span class="type">void</span> QWebSocket::<span class="name">setPauseMode</span>(<span class="type"><a href="../qtnetwork/qabstractsocket.html#PauseMode-enum" translate="no">QAbstractSocket::PauseModes</a></span> <i>pauseMode</i>)</h3>
<p>Controls whether to pause upon receiving a notification. The <i translate="no">pauseMode</i> parameter specifies the conditions in which the socket should be paused.</p>
<p>The only notification currently supported is <a href="qwebsocket.html#sslErrors" translate="no">sslErrors</a>(). If set to PauseOnSslErrors, data transfer on the socket will be paused and needs to be enabled explicitly again by calling <a href="qwebsocket.html#resume" translate="no">resume</a>(). By default, this option is set to PauseNever. This option must be called before connecting to the server, otherwise it will result in undefined behavior.</p>
<p><b>See also </b><a href="qwebsocket.html#pauseMode" translate="no">pauseMode</a>() and <a href="qwebsocket.html#resume" translate="no">resume</a>().</p>
<!-- @@@setPauseMode -->
<!-- $$$setProxy[overload1]$$$setProxyconstQNetworkProxy& -->
<h3 class="fn" translate="no" id="setProxy"><span class="type">void</span> QWebSocket::<span class="name">setProxy</span>(const <span class="type"><a href="../qtnetwork/qnetworkproxy.html" translate="no">QNetworkProxy</a></span> &amp;<i>networkProxy</i>)</h3>
<p>Sets the proxy to <i translate="no">networkProxy</i></p>
<p><b>See also </b><a href="qwebsocket.html#proxy" translate="no">proxy</a>().</p>
<!-- @@@setProxy -->
<!-- $$$setReadBufferSize[overload1]$$$setReadBufferSizeqint64 -->
<h3 class="fn" translate="no" id="setReadBufferSize"><span class="type">void</span> QWebSocket::<span class="name">setReadBufferSize</span>(<span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>size</i>)</h3>
<p>Sets the size of <a href="qwebsocket.html" translate="no">QWebSocket</a>'s internal read buffer to be <i translate="no">size</i> bytes.</p>
<p>If the buffer size is limited to a certain size, <a href="qwebsocket.html" translate="no">QWebSocket</a> won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default. This option is useful if you only read the data at certain points in time (for example, in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.</p>
<p><b>See also </b><a href="qwebsocket.html#readBufferSize" translate="no">readBufferSize</a>().</p>
<!-- @@@setReadBufferSize -->
<!-- $$$setSslConfiguration[overload1]$$$setSslConfigurationconstQSslConfiguration& -->
<h3 class="fn" translate="no" id="setSslConfiguration"><span class="type">void</span> QWebSocket::<span class="name">setSslConfiguration</span>(const <span class="type"><a href="../qtnetwork/qsslconfiguration.html" translate="no">QSslConfiguration</a></span> &amp;<i>sslConfiguration</i>)</h3>
<p>Sets the socket's SSL configuration to be the contents of <i translate="no">sslConfiguration</i>.</p>
<p>This function sets the local certificate, the ciphers, the private key and the CA certificates to those stored in <i translate="no">sslConfiguration</i>. It is not possible to set the SSL-state related fields.</p>
<p><b>See also </b><a href="qwebsocket.html#sslConfiguration" translate="no">sslConfiguration</a>().</p>
<!-- @@@setSslConfiguration -->
<!-- $$$sslConfiguration[overload1]$$$sslConfiguration -->
<h3 class="fn" translate="no" id="sslConfiguration"><span class="type"><a href="../qtnetwork/qsslconfiguration.html" translate="no">QSslConfiguration</a></span> QWebSocket::<span class="name">sslConfiguration</span>() const</h3>
<p>Returns the socket's SSL configuration state. The default SSL configuration of a socket is to use the default ciphers, default CA certificates, no local private key or certificate. The SSL configuration also contains fields that can change with time without notice.</p>
<p><b>See also </b><a href="qwebsocket.html#setSslConfiguration" translate="no">setSslConfiguration</a>().</p>
<!-- @@@sslConfiguration -->
<!-- $$$sslErrors[overload1]$$$sslErrorsconstQList<QSslError>& -->
<h3 class="fn" translate="no" id="sslErrors"><code translate="no">[signal] </code><span class="type">void</span> QWebSocket::<span class="name">sslErrors</span>(const <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="../qtnetwork/qsslerror.html" translate="no">QSslError</a></span>&gt; &amp;<i>errors</i>)</h3>
<p><a href="qwebsocket.html" translate="no">QWebSocket</a> emits this signal after the SSL handshake to indicate that one or more errors have occurred while establishing the identity of the peer. The errors are usually an indication that <a href="qwebsocket.html" translate="no">QWebSocket</a> is unable to securely identify the peer. Unless any action is taken, the connection will be dropped after this signal has been emitted. If you want to continue connecting despite the errors that have occurred, you must call <a href="qwebsocket.html#ignoreSslErrors" translate="no">QWebSocket::ignoreSslErrors</a>() from inside a slot connected to this signal. If you need to access the error list at a later point, you can call sslErrors() (without arguments).</p>
<p><i translate="no">errors</i> contains one or more errors that prevent <a href="qwebsocket.html" translate="no">QWebSocket</a> from verifying the identity of the peer.</p>
<div class="admonition note">
<p><b>Note: </b>You cannot use <a href="../qtcore/qt.html#ConnectionType-enum" translate="no">Qt::QueuedConnection</a> when connecting to this signal, or calling <a href="qwebsocket.html#ignoreSslErrors" translate="no">QWebSocket::ignoreSslErrors</a>() will have no effect.</p>
</div>
<!-- @@@sslErrors -->
<!-- $$$state[overload1]$$$state -->
<h3 class="fn" translate="no" id="state"><span class="type"><a href="../qtnetwork/qabstractsocket.html#SocketState-enum" translate="no">QAbstractSocket::SocketState</a></span> QWebSocket::<span class="name">state</span>() const</h3>
<p>Returns the current state of the socket.</p>
<!-- @@@state -->
<!-- $$$stateChanged[overload1]$$$stateChangedQAbstractSocket::SocketState -->
<h3 class="fn" translate="no" id="stateChanged"><code translate="no">[signal] </code><span class="type">void</span> QWebSocket::<span class="name">stateChanged</span>(<span class="type"><a href="../qtnetwork/qabstractsocket.html#SocketState-enum" translate="no">QAbstractSocket::SocketState</a></span> <i>state</i>)</h3>
<p>This signal is emitted whenever <a href="qwebsocket.html" translate="no">QWebSocket</a>'s state changes. The <i translate="no">state</i> parameter is the new state.</p>
<div class="admonition note">
<p><b>Note: </b><a href="../qtnetwork/qabstractsocket.html#SocketState-enum" translate="no">QAbstractSocket::ConnectedState</a> is emitted after the handshake with the server has succeeded.</p>
</div>
<p><a href="../qtnetwork/qabstractsocket.html#SocketState-enum" translate="no">QAbstractSocket::SocketState</a> is not a registered metatype, so for queued connections, you will have to register it with Q_REGISTER_METATYPE() and <a href="../qtcore/qmetatype.html#qRegisterMetaType-3" translate="no">qRegisterMetaType</a>().</p>
<p><b>See also </b><a href="qwebsocket.html#state" translate="no">state</a>().</p>
<!-- @@@stateChanged -->
<!-- $$$subprotocol[overload1]$$$subprotocol -->
<h3 class="fn" translate="no" id="subprotocol"><code translate="no">[since 6.4] </code><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QWebSocket::<span class="name">subprotocol</span>() const</h3>
<p>Returns the used WebSocket protocol.</p>
<p>This function was introduced in Qt 6.4.</p>
<!-- @@@subprotocol -->
<!-- $$$textFrameReceived[overload1]$$$textFrameReceivedconstQString&bool -->
<h3 class="fn" translate="no" id="textFrameReceived"><code translate="no">[signal] </code><span class="type">void</span> QWebSocket::<span class="name">textFrameReceived</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>frame</i>, <span class="type">bool</span> <i>isLastFrame</i>)</h3>
<p>This signal is emitted whenever a text frame is received. The <i translate="no">frame</i> contains the data and <i translate="no">isLastFrame</i> indicates whether this is the last frame of the complete message.</p>
<p>This signal can be used to process large messages frame by frame, instead of waiting for the complete message to arrive.</p>
<p><b>See also </b><a href="qwebsocket.html#binaryFrameReceived" translate="no">binaryFrameReceived</a>().</p>
<!-- @@@textFrameReceived -->
<!-- $$$textMessageReceived[overload1]$$$textMessageReceivedconstQString& -->
<h3 class="fn" translate="no" id="textMessageReceived"><code translate="no">[signal] </code><span class="type">void</span> QWebSocket::<span class="name">textMessageReceived</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>message</i>)</h3>
<p>This signal is emitted whenever a text message is received. The <i translate="no">message</i> contains the received text.</p>
<p><b>See also </b><a href="qwebsocket.html#binaryMessageReceived" translate="no">binaryMessageReceived</a>().</p>
<!-- @@@textMessageReceived -->
<!-- $$$version[overload1]$$$version -->
<h3 class="fn" translate="no" id="version"><span class="type"><a href="qwebsocketprotocol.html#Version-enum" translate="no">QWebSocketProtocol::Version</a></span> QWebSocket::<span class="name">version</span>() const</h3>
<p>Returns the version the socket is currently using.</p>
<!-- @@@version -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2023 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
