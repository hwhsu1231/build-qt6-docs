<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- surfacegallery.qdoc -->
  <meta name="description" content="Gallery with three different ways to use a Surface3D graph.">
  <title>Surface Graph Gallery | Qt Graphs 6.6.2</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.6</a></li>
<li><a href="qtgraphs-index.html" translate="no">Qt Graphs</a></li>
<li>Surface Graph Gallery</li>
<li id="buildversion"><a href="qtgraphs-index.html" translate="no">Qt Graphs | Commercial or GPLv3</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#running-the-example">Running the Example</a></li>
<li class="level1"><a href="#height-map">Height Map</a></li>
<li class="level2"><a href="#adding-data-to-the-graph">Adding Data to the Graph</a></li>
<li class="level2"><a href="#displaying-the-data">Displaying the Data</a></li>
<li class="level1"><a href="#spectrogram">Spectrogram</a></li>
<li class="level2"><a href="#creating-a-spectrogram">Creating a Spectrogram</a></li>
<li class="level2"><a href="#polar-spectrogram">Polar Spectrogram</a></li>
<li class="level1"><a href="#oscilloscope">Oscilloscope</a></li>
<li class="level2"><a href="#data-source-in-c">Data Source in C++</a></li>
<li class="level2"><a href="#qml-application">QML Application</a></li>
<li class="level2"><a href="#enabling-direct-rendering">Enabling Direct Rendering</a></li>
<li class="level1"><a href="#example-contents">Example Contents</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Surface Graph Gallery</h1>
<!-- $$$surfacegallery-brief -->
<p>Gallery with three different ways to use a <a href="qml-qtgraphs-surface3d.html" translate="no">Surface3D</a> graph.</p>
<!-- @@@surfacegallery -->
<!-- $$$surfacegallery-description -->
<div class="descr" id="details">
<p><i>Surface Graph Gallery</i> demonstrates three different custom features with <a href="qml-qtgraphs-surface3d.html" translate="no">Surface3D</a> graphs. The features have their own tabs in the application.</p>
<p>The following sections concentrate on those features only and skip explaining the basic functionality - for more detailed QML example documentation, see <a href="qtgraphs-scatter-example.html" translate="no">Simple Scatter Graph</a>.</p>
<p class="centerAlign"><img src="images/surfacegallery-example.png" alt="" /></p><h4 id="running-the-example">Running the Example</h4>
<p>To run the example from <a href="https://doc.qt.io/qtcreator/index.html" translate="no">Qt Creator</a>, open the <b translate="no">Welcome</b> mode and select the example from <b translate="no">Examples</b>. For more information, visit <a href="https://doc.qt.io/qtcreator/creator-build-example-application.html" translate="no">Building and Running an Example</a>.</p>
<h4 id="height-map">Height Map</h4>
<p>In the <b translate="no">Height Map</b> tab, generate a surface graph from height data. The data used is a height map of Mount Ruapehu and Mount Ngauruhoe in New Zealand.</p>
<h5 id="adding-data-to-the-graph">Adding Data to the Graph</h5>
<p>The data is set using <a href="qml-qtgraphs-heightmapsurfacedataproxy.html" translate="no">HeightMapSurfaceDataProxy</a>, which reads height information from a height map image. The proxy itself is contained in a <a href="qml-qtgraphs-surface3dseries.html" translate="no">Surface3DSeries</a>. Inside the <a href="qml-qtgraphs-heightmapsurfacedataproxy.html" translate="no">HeightMapSurfaceDataProxy</a> the <code translate="no">heightMapFile</code> property specifies the image file containing the height data. The value properties in the proxy define the minimum and maximum values for surface area width, depth, and height. The <code translate="no">z</code> and <code translate="no">x</code> values are in latitude and longitude, approximately at the real-world position, and the <code translate="no">y</code> is in meters.</p>
<div class="admonition note">
<p><b>Note: </b>The aspect ratio of the graph is not set to real-life scale, but the height is exaggerated instead.</p>
</div>
<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtgraphs-surface3dseries.html" translate="no">Surface3DSeries</a></span> {
     <span class="name">id</span>: <span class="name">heightSeries</span>
     <span class="name">flatShadingEnabled</span>: <span class="number">false</span>
     <span class="name">drawMode</span>: <span class="name">Surface3DSeries</span>.<span class="name">DrawSurface</span>

     <span class="type"><a href="qml-qtgraphs-heightmapsurfacedataproxy.html" translate="no">HeightMapSurfaceDataProxy</a></span> {
         <span class="name">heightMapFile</span>: <span class="string">&quot;://qml/surfacegallery/heightmap.png&quot;</span>
         <span class="comment">// We don't want the default data values set by heightmap proxy, but use</span>
         <span class="comment">// actual coordinate and height values instead</span>
         <span class="name">autoScaleY</span>: <span class="number">true</span>
         <span class="name">minYValue</span>: <span class="number">740</span>
         <span class="name">maxYValue</span>: <span class="number">2787</span>
         <span class="name">minZValue</span>: -<span class="number">374</span> <span class="comment">// ~ -39.374411&quot;N</span>
         <span class="name">maxZValue</span>: -<span class="number">116</span> <span class="comment">// ~ -39.115971&quot;N</span>
         <span class="name">minXValue</span>: <span class="number">472</span>  <span class="comment">// ~ 175.471767&quot;E</span>
         <span class="name">maxXValue</span>: <span class="number">781</span>  <span class="comment">// ~ 175.780758&quot;E</span>
     }

     <span class="name">onDrawModeChanged</span>: <span class="name">heightMapView</span>.<span class="name">checkState</span>()
 }
</pre>
<h5 id="displaying-the-data">Displaying the Data</h5>
<p>In <code translate="no">main.qml</code>, set up the <a href="qml-qtgraphs-surface3d.html" translate="no">Surface3D</a> element to display the data.</p>
<p>First, define the custom gradient to be used for the surface. Set the colors from position 0.0 to 1.0 with <a href="qml-qtgraphs-colorgradient.html" translate="no">ColorGradient</a>, with two extra stops to make the graph more vivid:</p>
<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtgraphs-colorgradient.html" translate="no">ColorGradient</a></span> {
     <span class="name">id</span>: <span class="name">surfaceGradient</span>
     <span class="type"><a href="qml-qtgraphs-colorgradientstop.html" translate="no">ColorGradientStop</a></span> { <span class="name">position</span>: <span class="number">0.0</span>; <span class="name">color</span>: <span class="string">&quot;darkgreen&quot;</span>}
     <span class="type"><a href="qml-qtgraphs-colorgradientstop.html" translate="no">ColorGradientStop</a></span> { <span class="name">position</span>: <span class="number">0.15</span>; <span class="name">color</span>: <span class="string">&quot;darkslategray&quot;</span> }
     <span class="type"><a href="qml-qtgraphs-colorgradientstop.html" translate="no">ColorGradientStop</a></span> { <span class="name">position</span>: <span class="number">0.7</span>; <span class="name">color</span>: <span class="string">&quot;peru&quot;</span> }
     <span class="type"><a href="qml-qtgraphs-colorgradientstop.html" translate="no">ColorGradientStop</a></span> { <span class="name">position</span>: <span class="number">1.0</span>; <span class="name">color</span>: <span class="string">&quot;white&quot;</span> }
 }
</pre>
<p>Set this element into the <code translate="no">baseGradients</code> property in the <code translate="no">theme</code> used in <a href="qml-qtgraphs-surface3d.html" translate="no">Surface3D</a>:</p>
<pre class="qml" translate="no">
 <span class="name">theme</span>: <span class="name">Theme3D</span> {
     <span class="name">type</span>: <span class="name">Theme3D</span>.<span class="name">ThemeStoneMoss</span>
     <span class="name">font</span>.family: <span class="string">&quot;STCaiyun&quot;</span>
     <span class="name">font</span>.pointSize: <span class="number">35</span>
     <span class="name">colorStyle</span>: <span class="name">Theme3D</span>.<span class="name">ColorStyleRangeGradient</span>
     <span class="name">baseGradients</span>: [<span class="name">surfaceGradient</span>] <span class="comment">// Use the custom gradient</span>
 }
</pre>
<p>Use the buttons to control other <a href="qml-qtgraphs-surface3d.html" translate="no">Surface3D</a> features.</p>
<p>The first button toggles on and off the surface grid. The draw mode cannot be cleared completely, so unless the surface itself is visible, the surface grid cannot be hidden:</p>
<pre class="qml" translate="no">
 <span class="name">onClicked</span>: {
     <span class="keyword">if</span> (<span class="name">heightSeries</span>.<span class="name">drawMode</span> <span class="operator">&amp;</span> <span class="name">Surface3DSeries</span>.<span class="name">DrawWireframe</span>)
         <span class="name">heightSeries</span>.<span class="name">drawMode</span> <span class="operator">&amp;=</span> ~<span class="name">Surface3DSeries</span>.<span class="name">DrawWireframe</span>;
     <span class="keyword">else</span>
         <span class="name">heightSeries</span>.<span class="name">drawMode</span> <span class="operator">|=</span> <span class="name">Surface3DSeries</span>.<span class="name">DrawWireframe</span>;
 }
</pre>
<p>The second one sets the surface grid color:</p>
<pre class="qml" translate="no">
 <span class="name">onClicked</span>: {
     <span class="keyword">if</span> (<span class="name">Qt</span>.<span class="name">colorEqual</span>(<span class="name">heightSeries</span>.<span class="name">wireframeColor</span>, <span class="string">&quot;#000000&quot;</span>)) {
         <span class="name">heightSeries</span>.<span class="name">wireframeColor</span> <span class="operator">=</span> <span class="string">&quot;red&quot;</span>;
         <span class="name">text</span> <span class="operator">=</span> <span class="string">&quot;Black surface\ngrid color&quot;</span>;
     } <span class="keyword">else</span> {
         <span class="name">heightSeries</span>.<span class="name">wireframeColor</span> <span class="operator">=</span> <span class="string">&quot;black&quot;</span>;
         <span class="name">text</span> <span class="operator">=</span> <span class="string">&quot;Red surface\ngrid color&quot;</span>;
     }
 }
</pre>
<p>The third one toggles the surface on or off in the surface draw mode. The draw mode cannot be cleared completely, so unless the surface grid is visible, the surface itself cannot be hidden:</p>
<pre class="qml" translate="no">
 <span class="name">onClicked</span>: {
     <span class="keyword">if</span> (<span class="name">heightSeries</span>.<span class="name">drawMode</span> <span class="operator">&amp;</span> <span class="name">Surface3DSeries</span>.<span class="name">DrawSurface</span>)
         <span class="name">heightSeries</span>.<span class="name">drawMode</span> <span class="operator">&amp;=</span> ~<span class="name">Surface3DSeries</span>.<span class="name">DrawSurface</span>;
     <span class="keyword">else</span>
         <span class="name">heightSeries</span>.<span class="name">drawMode</span> <span class="operator">|=</span> <span class="name">Surface3DSeries</span>.<span class="name">DrawSurface</span>;
 }
</pre>
<p>The fourth sets the for shading mode. If you are running the example on OpenGL ES system, flat shading is not available:</p>
<pre class="qml" translate="no">
 <span class="name">onClicked</span>: {
     <span class="keyword">if</span> (<span class="name">heightSeries</span>.<span class="name">flatShadingEnabled</span>) {
         <span class="name">heightSeries</span>.<span class="name">flatShadingEnabled</span> <span class="operator">=</span> <span class="number">false</span>;
         <span class="name">text</span> <span class="operator">=</span> <span class="string">&quot;Show\nFlat&quot;</span>
     } <span class="keyword">else</span> {
         <span class="name">heightSeries</span>.<span class="name">flatShadingEnabled</span> <span class="operator">=</span> <span class="number">true</span>;
         <span class="name">text</span> <span class="operator">=</span> <span class="string">&quot;Show\nSmooth&quot;</span>
     }
 }
</pre>
<p>The remaining buttons control the graph background features.</p>
<h4 id="spectrogram">Spectrogram</h4>
<p>In the <b translate="no">Spectrogram</b> tab, display polar and cartesian spectrograms and use orthographic projection to show them in 2D.</p>
<p>A spectrogram is a surface graph with a range gradient used to emphasize the different values. Typically, spectrograms are shown with two-dimensional surfaces, which is simulated with a top-down orthographic view of the graph. To enforce the 2D effect, disable the graph rotation via mouse or touch when in the orthographic mode.</p>
<h5 id="creating-a-spectrogram">Creating a Spectrogram</h5>
<p>To create a 2D spectrogram, define a <a href="qml-qtgraphs-surface3d.html" translate="no">Surface3D</a> item with the data given in the <a href="qml-qtgraphs-surface3dseries.html" translate="no">Surface3DSeries</a> with an <a href="qml-qtgraphs-itemmodelsurfacedataproxy.html" translate="no">ItemModelSurfaceDataProxy</a>:</p>
<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtgraphs-surface3d.html" translate="no">Surface3D</a></span> {
     <span class="name">id</span>: <span class="name">surfaceGraph</span>
     <span class="name">anchors</span>.fill: <span class="name">parent</span>

     <span class="type"><a href="qml-qtgraphs-surface3dseries.html" translate="no">Surface3DSeries</a></span> {
         <span class="name">id</span>: <span class="name">surfaceSeries</span>
         <span class="name">flatShadingEnabled</span>: <span class="number">false</span>
         <span class="name">drawMode</span>: <span class="name">Surface3DSeries</span>.<span class="name">DrawSurface</span>
         <span class="name">baseGradient</span>: <span class="name">surfaceGradient</span>
         <span class="name">colorStyle</span>: <span class="name">Theme3D</span>.<span class="name">ColorStyleRangeGradient</span>
         <span class="name">itemLabelFormat</span>: <span class="string">&quot;(@xLabel, @zLabel): @yLabel&quot;</span>

         <span class="type"><a href="qml-qtgraphs-itemmodelsurfacedataproxy.html" translate="no">ItemModelSurfaceDataProxy</a></span> {
             <span class="name">itemModel</span>: <span class="name">surfaceData</span>.<span class="name">model</span>
             <span class="name">rowRole</span>: <span class="string">&quot;radius&quot;</span>
             <span class="name">columnRole</span>: <span class="string">&quot;angle&quot;</span>
             <span class="name">yPosRole</span>: <span class="string">&quot;value&quot;</span>
         }
     }
</pre>
<p>The key properties for enabling the 2D effect are <a href="qml-qtgraphs-abstractgraph3d.html#orthoProjection-prop" translate="no">orthoProjection</a> and <a href="qml-qtgraphs-camera3d.html#cameraPreset-prop" translate="no">scene.activeCamera.cameraPreset</a>. Remove the perspective by enabling orthographic projection for the graph, and the Y-dimension by viewing the graph directly from above:</p>
<pre class="qml" translate="no">
 <span class="comment">// Remove the perspective and view the graph from top down to achieve 2D effect</span>
 <span class="name">orthoProjection</span>: <span class="number">true</span>
 <span class="name">scene</span>.activeCamera.cameraPreset: <span class="name">Camera3D</span>.<span class="name">CameraPresetDirectlyAbove</span>
</pre>
<p>Since this viewpoint causes the horizontal axis grid to be mostly obscured by the surface, flip the horizontal grid to be drawn on top of the graph:</p>
<pre class="qml" translate="no">
 <span class="name">flipHorizontalGrid</span>: <span class="number">true</span>
</pre>
<h5 id="polar-spectrogram">Polar Spectrogram</h5>
<p>Depending on the data, it is sometimes more natural to use a polar graph instead of a cartesian one. This is supported via the <a href="qml-qtgraphs-abstractgraph3d.html#polar-prop" translate="no">polar</a> property.</p>
<p>Add a button to switch between polar and cartesian modes:</p>
<pre class="qml" translate="no">
 <span class="type">Button</span> {
     <span class="name">id</span>: <span class="name">polarToggle</span>
     <span class="name">anchors</span>.margins: <span class="number">5</span>
     <span class="name">anchors</span>.left: <span class="name">parent</span>.<span class="name">left</span>
     <span class="name">anchors</span>.top: <span class="name">parent</span>.<span class="name">top</span>
     <span class="name">width</span>: <span class="name">spectrogramView</span>.<span class="name">buttonWidth</span> <span class="comment">// Calculated elsewhere based on screen orientation</span>
     <span class="name">text</span>: <span class="string">&quot;Switch to\n&quot;</span> <span class="operator">+</span> (<span class="name">surfaceGraph</span>.<span class="name">polar</span> ? <span class="string">&quot;cartesian&quot;</span> : <span class="string">&quot;polar&quot;</span>)
     <span class="name">onClicked</span>: <span class="name">surfaceGraph</span>.<span class="name">polar</span> <span class="operator">=</span> !<span class="name">surfaceGraph</span>.<span class="name">polar</span>;
 }
</pre>
<p>In the polar mode, X-axis is converted into the angular polar axis, and Z-axis is converted into a radial polar axis. The surface points are recalculated according to the new axes.</p>
<p>The radial axis labels are drawn outside the graph by default. To draw them right next to the 0 degree angular axis inside the graph, define only a small offset for them:</p>
<pre class="qml" translate="no">
 <span class="name">radialLabelOffset</span>: <span class="number">0.01</span>
</pre>
<p>To enforce the 2D effect, disable graph rotation in orthographic mode by overriding the default input handler with a custom one, which automatically toggles the <a href="qml-qtgraphs-inputhandler3d.html#rotationEnabled-prop" translate="no">rotationEnabled</a> property based on the projection mode:</p>
<pre class="qml" translate="no">
 <span class="name">inputHandler</span>: <span class="name">TouchInputHandler3D</span> {
     <span class="name">rotationEnabled</span>: !<span class="name">surfaceGraph</span>.<span class="name">orthoProjection</span>
 }
</pre>
<h4 id="oscilloscope">Oscilloscope</h4>
<p>In the <b translate="no">Oscilloscope</b> tab, combine C++ and QML in an application, and show data that dynamically changes.</p>
<h5 id="data-source-in-c">Data Source in C++</h5>
<p>The item model based proxies are good for simple or static graphs, but use basic proxies to achieve the best performance when displaying data changing in realtime. These are not supported in QML, as the data items they store do not inherit <a href="../qtcore/qobject.html" translate="no">QObject</a> and cannot therefore be directly manipulated from QML code. To overcome this limitation, implement a simple <code translate="no">DataSource</code> class in C++ to populate the data proxy of the series.</p>
<p>Create a <code translate="no">DataSource</code> class to provide two methods that can be invoked from QML:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> DataSource : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     ...
 Q_INVOKABLE <span class="type">void</span> generateData(<span class="type">int</span> cacheCount<span class="operator">,</span> <span class="type">int</span> rowCount<span class="operator">,</span> <span class="type">int</span> columnCount<span class="operator">,</span>
                               <span class="type">float</span> xMin<span class="operator">,</span> <span class="type">float</span> xMax<span class="operator">,</span>
                               <span class="type">float</span> yMin<span class="operator">,</span> <span class="type">float</span> yMax<span class="operator">,</span>
                               <span class="type">float</span> zMin<span class="operator">,</span> <span class="type">float</span> zMax);

 Q_INVOKABLE <span class="type">void</span> update(QSurface3DSeries <span class="operator">*</span>series);
</pre>
<p>The first method, <code translate="no">generateData()</code>, creates a cache of simulated oscilloscope data to display. The data is cached in a format that <a href="qsurfacedataproxy.html" translate="no">QSurfaceDataProxy</a> accepts:</p>
<pre class="cpp" translate="no">
 <span class="comment">// Populate caches</span>
 <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> cacheCount; i<span class="operator">+</span><span class="operator">+</span>) {
     <span class="type"><a href="qsurfacedataproxy.html#QSurfaceDataArray-typedef" translate="no">QSurfaceDataArray</a></span> <span class="operator">&amp;</span>cache <span class="operator">=</span> m_data<span class="operator">[</span>i<span class="operator">]</span>;
     <span class="type">float</span> cacheXAdjustment <span class="operator">=</span> cacheStep <span class="operator">*</span> i;
     <span class="type">float</span> cacheIndexAdjustment <span class="operator">=</span> cacheIndexStep <span class="operator">*</span> i;
     <span class="keyword">for</span> (<span class="type">int</span> j <span class="operator">=</span> <span class="number">0</span>; j <span class="operator">&lt;</span> rowCount; j<span class="operator">+</span><span class="operator">+</span>) {
         <span class="type"><a href="qsurfacedataproxy.html#QSurfaceDataRow-typedef" translate="no">QSurfaceDataRow</a></span> <span class="operator">&amp;</span>row <span class="operator">=</span> <span class="operator">*</span>(cache<span class="operator">[</span>j<span class="operator">]</span>);
         <span class="type">float</span> rowMod <span class="operator">=</span> (<span class="type">float</span>(j)) <span class="operator">/</span> <span class="type">float</span>(rowCount);
         <span class="type">float</span> yRangeMod <span class="operator">=</span> yRange <span class="operator">*</span> rowMod;
         <span class="type">float</span> zRangeMod <span class="operator">=</span> zRange <span class="operator">*</span> rowMod;
         <span class="type">float</span> z <span class="operator">=</span> zRangeMod <span class="operator">+</span> zMin;
         <span class="type"><a href="../qtcore/qttypes.html#qreal-typedef" translate="no">qreal</a></span> rowColWaveAngleMul <span class="operator">=</span> M_PI <span class="operator">*</span> M_PI <span class="operator">*</span> rowMod;
         <span class="type">float</span> rowColWaveMul <span class="operator">=</span> yRangeMod <span class="operator">*</span> <span class="number">0.2f</span>;
         <span class="keyword">for</span> (<span class="type">int</span> k <span class="operator">=</span> <span class="number">0</span>; k <span class="operator">&lt;</span> columnCount; k<span class="operator">+</span><span class="operator">+</span>) {
             <span class="type">float</span> colMod <span class="operator">=</span> (<span class="type">float</span>(k)) <span class="operator">/</span> <span class="type">float</span>(columnCount);
             <span class="type">float</span> xRangeMod <span class="operator">=</span> xRange <span class="operator">*</span> colMod;
             <span class="type">float</span> x <span class="operator">=</span> xRangeMod <span class="operator">+</span> xMin <span class="operator">+</span> cacheXAdjustment;
             <span class="type">float</span> colWave <span class="operator">=</span> <span class="type">float</span>(<a href="../qtcore/qtmath.html#qSin" translate="no">qSin</a>((<span class="number">2.0</span> <span class="operator">*</span> M_PI <span class="operator">*</span> colMod) <span class="operator">-</span> (<span class="number">1.0</span> <span class="operator">/</span> <span class="number">2.0</span> <span class="operator">*</span> M_PI)) <span class="operator">+</span> <span class="number">1.0</span>);
             <span class="type">float</span> y <span class="operator">=</span> (colWave <span class="operator">*</span> ((<span class="type">float</span>(<a href="../qtcore/qtmath.html#qSin" translate="no">qSin</a>(rowColWaveAngleMul <span class="operator">*</span> colMod) <span class="operator">+</span> <span class="number">1.0</span>))))
                     <span class="operator">*</span> rowColWaveMul
                     <span class="operator">+</span> <span class="type"><a href="../qtcore/qrandomgenerator.html" translate="no">QRandomGenerator</a></span><span class="operator">::</span>global()<span class="operator">-</span><span class="operator">&gt;</span>bounded(<span class="number">0.15f</span>) <span class="operator">*</span> yRangeMod;

             <span class="type">int</span> index <span class="operator">=</span> k <span class="operator">+</span> cacheIndexAdjustment;
             <span class="keyword">if</span> (index <span class="operator">&gt;</span><span class="operator">=</span> columnCount) {
                 <span class="comment">// Wrap over</span>
                 index <span class="operator">-</span><span class="operator">=</span> columnCount;
                 x <span class="operator">-</span><span class="operator">=</span> xRange;
             }
             row<span class="operator">[</span>index<span class="operator">]</span> <span class="operator">=</span> QVector3D(x<span class="operator">,</span> y<span class="operator">,</span> z);
         }
     }
 }
</pre>
<p>The second method, <code translate="no">update()</code>, copies one set of the cached data into another array, which is set to the data proxy of the series by calling <a href="qsurfacedataproxy.html#resetArray" translate="no">QSurfaceDataProxy::resetArray</a>(). To minimize overhead, reuse the same array if the array dimensions have not changed:</p>
<pre class="cpp" translate="no">
 <span class="comment">// Each iteration uses data from a different cached array</span>
 m_index<span class="operator">+</span><span class="operator">+</span>;
 <span class="keyword">if</span> (m_index <span class="operator">&gt;</span> m_data<span class="operator">.</span>count() <span class="operator">-</span> <span class="number">1</span>)
     m_index <span class="operator">=</span> <span class="number">0</span>;

 <span class="type"><a href="qsurfacedataproxy.html#QSurfaceDataArray-typedef" translate="no">QSurfaceDataArray</a></span> array <span class="operator">=</span> m_data<span class="operator">.</span>at(m_index);
 <span class="type">int</span> newRowCount <span class="operator">=</span> array<span class="operator">.</span>size();
 <span class="type">int</span> newColumnCount <span class="operator">=</span> array<span class="operator">.</span>at(<span class="number">0</span>)<span class="operator">-</span><span class="operator">&gt;</span>size();

 <span class="comment">// If the first time or the dimensions of the cache array have changed,</span>
 <span class="comment">// reconstruct the reset array</span>
 <span class="keyword">if</span> (<span class="operator">!</span>m_resetArray <span class="operator">|</span><span class="operator">|</span> series<span class="operator">-</span><span class="operator">&gt;</span>dataProxy()<span class="operator">-</span><span class="operator">&gt;</span>rowCount() <span class="operator">!</span><span class="operator">=</span> newRowCount
         <span class="operator">|</span><span class="operator">|</span> series<span class="operator">-</span><span class="operator">&gt;</span>dataProxy()<span class="operator">-</span><span class="operator">&gt;</span>columnCount() <span class="operator">!</span><span class="operator">=</span> newColumnCount) {
     m_resetArray <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qsurfacedataproxy.html#QSurfaceDataArray-typedef" translate="no">QSurfaceDataArray</a></span>();
     m_resetArray<span class="operator">-</span><span class="operator">&gt;</span>reserve(newRowCount);
     <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> newRowCount; i<span class="operator">+</span><span class="operator">+</span>)
         m_resetArray<span class="operator">-</span><span class="operator">&gt;</span>append(<span class="keyword">new</span> <span class="type"><a href="qsurfacedataproxy.html#QSurfaceDataRow-typedef" translate="no">QSurfaceDataRow</a></span>(newColumnCount));
 }

 <span class="comment">// Copy items from our cache to the reset array</span>
 <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> newRowCount; i<span class="operator">+</span><span class="operator">+</span>) {
     <span class="keyword">const</span> <span class="type"><a href="qsurfacedataproxy.html#QSurfaceDataRow-typedef" translate="no">QSurfaceDataRow</a></span> <span class="operator">&amp;</span>sourceRow <span class="operator">=</span> <span class="operator">*</span>(array<span class="operator">.</span>at(i));
     <span class="type"><a href="qsurfacedataproxy.html#QSurfaceDataRow-typedef" translate="no">QSurfaceDataRow</a></span> <span class="operator">&amp;</span>row <span class="operator">=</span> <span class="operator">*</span>(<span class="operator">*</span>m_resetArray)<span class="operator">[</span>i<span class="operator">]</span>;
     <span class="keyword">for</span> (<span class="type">int</span> j <span class="operator">=</span> <span class="number">0</span>; j <span class="operator">&lt;</span> newColumnCount; j<span class="operator">+</span><span class="operator">+</span>)
         row<span class="operator">[</span>j<span class="operator">]</span><span class="operator">.</span>setPosition(sourceRow<span class="operator">.</span>at(j)<span class="operator">.</span>position());
 }

 <span class="comment">// Notify the proxy that data has changed</span>
 series<span class="operator">-</span><span class="operator">&gt;</span>dataProxy()<span class="operator">-</span><span class="operator">&gt;</span>resetArray(m_resetArray);
</pre>
<p>Even though we are operating on the array pointer previously set to the proxy, <a href="qsurfacedataproxy.html#resetArray" translate="no">QSurfaceDataProxy::resetArray</a>() still needs to be called after changing the data in it to prompt the graph to render the data.</p>
<p>To be able to access the <code translate="no">DataSource</code> methods from QML, expose the data source by making the DataSource a <a href="../qtqml/qqmlengine.html#QML_ELEMENT" translate="no">QML_ELEMENT</a>:</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> DataSource : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span>
 {
     Q_OBJECT
     QML_ELEMENT
</pre>
<p>Further, declare it as a QML module in the CMakeLists.txt:</p>
<pre class="cpp plain" translate="no">
 qt6_add_qml_module(surfacegallery
     URI SurfaceGallery
     VERSION 1.0
     NO_RESOURCE_TARGET_PATH
     SOURCES
         datasource.cpp datasource.h
     ...
 )
</pre>
<p>To use <a href="qsurface3dseries.html" translate="no">QSurface3DSeries</a> pointers as parameters for the <code translate="no">DataSource</code> class methods on all environments and builds, make sure the meta type is registered:</p>
<pre class="cpp" translate="no">
 <a href="../qtcore/qmetatype.html#qRegisterMetaType-3" translate="no">qRegisterMetaType</a><span class="operator">&lt;</span>QSurface3DSeries <span class="operator">*</span><span class="operator">&gt;</span>();
</pre>
<h5 id="qml-application">QML Application</h5>
<p>To use the <code translate="no">DataSource</code>, import the QML module and create an instance of <code translate="no">DataSource</code> to be used:</p>
<pre class="qml" translate="no">
 import SurfaceGallery
 ...
 <span class="type">DataSource</span> {
     <span class="name">id</span>: <span class="name">dataSource</span>
 }
</pre>
<p>Define a <a href="qml-qtgraphs-surface3d.html" translate="no">Surface3D</a> graph and give it a <a href="qml-qtgraphs-surface3dseries.html" translate="no">Surface3DSeries</a>:</p>
<pre class="qml" translate="no">
 <span class="type"><a href="qml-qtgraphs-surface3d.html" translate="no">Surface3D</a></span> {
     <span class="name">id</span>: <span class="name">surfaceGraph</span>
     <span class="name">anchors</span>.fill: <span class="name">parent</span>

     <span class="type"><a href="qml-qtgraphs-surface3dseries.html" translate="no">Surface3DSeries</a></span> {
         <span class="name">id</span>: <span class="name">surfaceSeries</span>
         <span class="name">drawMode</span>: <span class="name">Surface3DSeries</span>.<span class="name">DrawSurfaceAndWireframe</span>
         <span class="name">itemLabelFormat</span>: <span class="string">&quot;@xLabel, @zLabel: @yLabel&quot;</span>
</pre>
<p>Don't specify a proxy for the <a href="qml-qtgraphs-surface3dseries.html" translate="no">Surface3DSeries</a> that you attach to the graph. This makes the series utilize the default <a href="qsurfacedataproxy.html" translate="no">QSurfaceDataProxy</a>.</p>
<p>Hide the item label with <a href="qml-qtgraphs-abstract3dseries.html#itemLabelVisible-prop" translate="no">itemLabelVisible</a>. With dynamic, fast-changing data, a floating selection label would be distracting and difficult to read.</p>
<pre class="qml" translate="no">
 <span class="name">itemLabelVisible</span>: <span class="number">false</span>
</pre>
<p>You can display the selected item information in a <code translate="no">Text</code> element instead of the default floating label above the selection pointer:</p>
<pre class="qml" translate="no">
 <span class="name">onItemLabelChanged</span>: {
     <span class="keyword">if</span> (<span class="name">surfaceSeries</span>.<span class="name">selectedPoint</span> <span class="operator">==</span> <span class="name">surfaceSeries</span>.<span class="name">invalidSelectionPosition</span>)
         <span class="name">selectionText</span>.<span class="name">text</span> <span class="operator">=</span> <span class="string">&quot;No selection&quot;</span>;
     <span class="keyword">else</span>
         <span class="name">selectionText</span>.<span class="name">text</span> <span class="operator">=</span> <span class="name">surfaceSeries</span>.<span class="name">itemLabel</span>;
 }
</pre>
<p>Initialize the <code translate="no">DataSource</code> cache when the graph is complete by calling a helper function <code translate="no">generateData()</code>, which calls the method with the same name in <code translate="no">DataSource</code>:</p>
<pre class="qml" translate="no">
 <span class="name">Component</span>.onCompleted: <span class="name">oscilloscopeView</span>.<span class="name">generateData</span>();
 ...
 <span class="keyword">function </span><span class="name">generateData</span>() {
     <span class="name">dataSource</span>.<span class="name">generateData</span>(<span class="name">oscilloscopeView</span>.<span class="name">sampleCache</span>, <span class="name">oscilloscopeView</span>.<span class="name">sampleRows</span>,
                             <span class="name">oscilloscopeView</span>.<span class="name">sampleColumns</span>,
                             <span class="name">surfaceGraph</span>.<span class="name">axisX</span>.<span class="name">min</span>, <span class="name">surfaceGraph</span>.<span class="name">axisX</span>.<span class="name">max</span>,
                             <span class="name">surfaceGraph</span>.<span class="name">axisY</span>.<span class="name">min</span>, <span class="name">surfaceGraph</span>.<span class="name">axisY</span>.<span class="name">max</span>,
                             <span class="name">surfaceGraph</span>.<span class="name">axisZ</span>.<span class="name">min</span>, <span class="name">surfaceGraph</span>.<span class="name">axisZ</span>.<span class="name">max</span>);
 }
</pre>
<p>To trigger the updates in data, define a <code translate="no">Timer</code>, which calls the <code translate="no">update()</code> method in <code translate="no">DataSource</code> at requested intervals:</p>
<pre class="qml" translate="no">
 <span class="type"><a href="../qtqml/qml-qtqml-timer.html" translate="no">Timer</a></span> {
     <span class="name">id</span>: <span class="name">refreshTimer</span>
     <span class="name">interval</span>: <span class="number">1000</span> <span class="operator">/</span> <span class="name">frequencySlider</span>.<span class="name">value</span>
     <span class="name">running</span>: <span class="number">true</span>
     <span class="name">repeat</span>: <span class="number">true</span>
     <span class="name">onTriggered</span>: <span class="name">dataSource</span>.<span class="name">update</span>(<span class="name">surfaceSeries</span>);
 }
</pre>
<h5 id="enabling-direct-rendering">Enabling Direct Rendering</h5>
<p>Since this application potentially deals with a lot of rapidly changing data, it uses direct rendering mode for performance. To enable antialiasing in this mode, change the surface format of the application window. The default format used by <a href="../qtquick/qquickview.html" translate="no">QQuickView</a> doesn't support antialiasing. Use the utility function provided to change the surface format in <code translate="no">main.cpp</code>:</p>
<pre class="cpp" translate="no">
 <span class="preprocessor">#include &lt;QtGraphs/qutils.h&gt;</span>
 ...
 <span class="comment">// Enable antialiasing in direct rendering mode</span>
 viewer<span class="operator">.</span>setFormat(<a href="qabstract3dgraph.html#qDefaultSurfaceFormat" translate="no">qDefaultSurfaceFormat</a>(<span class="keyword">true</span>));
</pre>
<h4 id="example-contents">Example Contents</h4>
<p>Files:</p>
<ul>
<li><a href="qtgraphs-surfacegallery-cmakelists-txt.html" translate="no">surfacegallery/CMakeLists.txt</a></li>
<li><a href="qtgraphs-surfacegallery-datasource-cpp.html" translate="no">surfacegallery/datasource.cpp</a></li>
<li><a href="qtgraphs-surfacegallery-datasource-h.html" translate="no">surfacegallery/datasource.h</a></li>
<li><a href="qtgraphs-surfacegallery-main-cpp.html" translate="no">surfacegallery/main.cpp</a></li>
<li><a href="qtgraphs-surfacegallery-qml-surfacegallery-spectrogramdata-qml.html" translate="no">surfacegallery/qml/surfacegallery/SpectrogramData.qml</a></li>
<li><a href="qtgraphs-surfacegallery-qml-surfacegallery-surfaceheightmap-qml.html" translate="no">surfacegallery/qml/surfacegallery/SurfaceHeightMap.qml</a></li>
<li><a href="qtgraphs-surfacegallery-qml-surfacegallery-surfaceoscilloscope-qml.html" translate="no">surfacegallery/qml/surfacegallery/SurfaceOscilloscope.qml</a></li>
<li><a href="qtgraphs-surfacegallery-qml-surfacegallery-surfacespectrogram-qml.html" translate="no">surfacegallery/qml/surfacegallery/SurfaceSpectrogram.qml</a></li>
<li><a href="qtgraphs-surfacegallery-qml-surfacegallery-main-qml.html" translate="no">surfacegallery/qml/surfacegallery/main.qml</a></li>
<li><a href="qtgraphs-surfacegallery-surfacegallery-pro.html" translate="no">surfacegallery/surfacegallery.pro</a></li>
<li><a href="qtgraphs-surfacegallery-surfacegallery-qrc.html" translate="no">surfacegallery/surfacegallery.qrc</a></li>
</ul>
<p>Images:</p>
<ul>
<li><a href="images/used-in-examples/surfacegallery/qml/surfacegallery/heightmap.png" translate="no">surfacegallery/qml/surfacegallery/heightmap.png</a></li>
</ul>
</div>
<!-- @@@surfacegallery -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
