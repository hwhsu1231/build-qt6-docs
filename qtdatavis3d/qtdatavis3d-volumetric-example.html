<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- volumetric.qdoc -->
  <meta name="description" content="Rendering volumetric objects.">
  <title>Volumetric Rendering | Qt Data Visualization 6.6.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.6</a></li>
<li><a href="qtdatavisualization-index.html" translate="no">Qt Data Visualization</a></li>
<li>Volumetric Rendering</li>
<li id="buildversion"><a href="qtdatavisualization-index.html" translate="no">Qt Data Visualization | Commercial or GPLv3</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#running-the-example">Running the Example</a></li>
<li class="level1"><a href="#initializing-volume-item">Initializing Volume Item</a></li>
<li class="level1"><a href="#slicing-into-the-volume">Slicing into the Volume</a></li>
<li class="level1"><a href="#adjusting-volume-transparency">Adjusting Volume Transparency</a></li>
<li class="level1"><a href="#high-definition-vs-low-definition-shader">High Definition vs. Low Definition Shader</a></li>
<li class="level1"><a href="#example-contents">Example Contents</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Volumetric Rendering</h1>
<!-- $$$volumetric-brief -->
<p>Rendering volumetric objects.</p>
<!-- @@@volumetric -->
<!-- $$$volumetric-description -->
<div class="descr" id="details">
<p><i>Volumetric Rendering</i> shows how to use <a href="qcustom3dvolume.html" translate="no">QCustom3DVolume</a> to display volumetric data.</p>
<p class="centerAlign"><img src="images/volumetric-example.png" alt="" /></p><h4 id="running-the-example">Running the Example</h4>
<p>To run the example from <a href="https://doc.qt.io/qtcreator/index.html" translate="no">Qt Creator</a>, open the <b translate="no">Welcome</b> mode and select the example from <b translate="no">Examples</b>. For more information, visit <a href="https://doc.qt.io/qtcreator/creator-build-example-application.html" translate="no">Building and Running an Example</a>.</p>
<h4 id="initializing-volume-item">Initializing Volume Item</h4>
<p>The <a href="qcustom3dvolume.html" translate="no">QCustom3DVolume</a> items are special custom items (see <a href="qcustom3ditem.html" translate="no">QCustom3DItem</a>), which can be used to display volumetric data. The volume items are only supported with orthographic projection, so first make sure the graph is using it:</p>
<pre class="cpp" translate="no">
 m_graph<span class="operator">-</span><span class="operator">&gt;</span>setOrthoProjection(<span class="keyword">true</span>);
</pre>
<p>Create a volumetric item tied to the data ranges of the axes:</p>
<pre class="cpp" translate="no">
 m_volumeItem <span class="operator">=</span> <span class="keyword">new</span> QCustom3DVolume;
 <span class="comment">// Adjust water level to zero with a minor tweak to y-coordinate position and scaling</span>
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setScaling(
             QVector3D(m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisX()<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">-</span> m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisX()<span class="operator">-</span><span class="operator">&gt;</span>min()<span class="operator">,</span>
                       (m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisY()<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">-</span> m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisY()<span class="operator">-</span><span class="operator">&gt;</span>min()) <span class="operator">*</span> <span class="number">0.91f</span><span class="operator">,</span>
                       m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisZ()<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">-</span> m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisZ()<span class="operator">-</span><span class="operator">&gt;</span>min()));
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setPosition(
             QVector3D((m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisX()<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">+</span> m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisX()<span class="operator">-</span><span class="operator">&gt;</span>min()) <span class="operator">/</span> <span class="number">2.0f</span><span class="operator">,</span>
                       <span class="operator">-</span><span class="number">0.045f</span> <span class="operator">*</span> (m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisY()<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">-</span> m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisY()<span class="operator">-</span><span class="operator">&gt;</span>min()) <span class="operator">+</span>
                       (m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisY()<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">+</span> m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisY()<span class="operator">-</span><span class="operator">&gt;</span>min()) <span class="operator">/</span> <span class="number">2.0f</span><span class="operator">,</span>
                       (m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisZ()<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">+</span> m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisZ()<span class="operator">-</span><span class="operator">&gt;</span>min()) <span class="operator">/</span> <span class="number">2.0f</span>));
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setScalingAbsolute(<span class="keyword">false</span>);
</pre>
<p>Indicate that the scaling of the volume should follow the changes in the data ranges by setting the <a href="qcustom3ditem.html#scalingAbsolute-prop" translate="no">QCustom3DItem::scalingAbsolute</a> property to <code translate="no">false</code>. Next, define the internal contents of the volume:</p>
<pre class="cpp" translate="no">
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setTextureWidth(lowDetailSize);
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setTextureHeight(lowDetailSize <span class="operator">/</span> <span class="number">2</span>);
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setTextureDepth(lowDetailSize);
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setTextureFormat(<span class="type"><a href="../qtgui/qimage.html" translate="no">QImage</a></span><span class="operator">::</span>Format_Indexed8);
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setTextureData(<span class="keyword">new</span> <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtcore/qttypes.html#uchar-typedef" translate="no">uchar</a></span><span class="operator">&gt;</span>(<span class="operator">*</span>m_lowDetailData));
</pre>
<p>Use eight bit indexed color for the texture, as it is compact and makes it easy to adjust the colors without needing to reset the whole texture. For the texture data, use the data created earlier based on height maps. Typically, the data for volume items comes pregenerated in the form of a stack of images, so the data generation details can be skipped. For more information about the actual data generation process, see the example code.</p>
<p>Since eight bit indexed colors are used, a color table is needed to map the eight bit color indexes to actual colors. In a typical use case, you would get the color table from the source images instead of using one manually defined:</p>
<pre class="cpp" translate="no">
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setColorTable(m_colorTable1);
</pre>
<p>To have an option to show slice frames around the volume, initialize their properties. Initially, the frames will be hidden:</p>
<pre class="cpp" translate="no">
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setSliceFrameGaps(QVector3D(<span class="number">0.01f</span><span class="operator">,</span> <span class="number">0.02f</span><span class="operator">,</span> <span class="number">0.01f</span>));
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setSliceFrameThicknesses(QVector3D(<span class="number">0.0025f</span><span class="operator">,</span> <span class="number">0.005f</span><span class="operator">,</span> <span class="number">0.0025f</span>));
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setSliceFrameWidths(QVector3D(<span class="number">0.0025f</span><span class="operator">,</span> <span class="number">0.005f</span><span class="operator">,</span> <span class="number">0.0025f</span>));
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setDrawSliceFrames(<span class="keyword">false</span>);
</pre>
<p>Finally, add the volume as a custom item to the graph to display it:</p>
<pre class="cpp" translate="no">
 m_graph<span class="operator">-</span><span class="operator">&gt;</span>addCustomItem(m_volumeItem);
</pre>
<h4 id="slicing-into-the-volume">Slicing into the Volume</h4>
<p>Unless the volume is largely transparent, you can only see the surface of it, which is often not very helpful. One way to inspect the internal structure of the volume is to view the slices of the volume. <a href="qcustom3dvolume.html" translate="no">QCustom3DVolume</a> provides two ways to display the slices. The first is to show the selected slices in place of the volume. For example, to specify a slice perpendicular to the X-axis, use the following method:</p>
<pre class="cpp" translate="no">
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setSliceIndexX(m_sliceIndexX);
</pre>
<p>To display the slice specified above, the <a href="qcustom3dvolume.html#drawSlices-prop" translate="no">QCustom3DVolume::drawSlices</a> property must also be set:</p>
<pre class="cpp" translate="no">
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setDrawSlices(<span class="keyword">true</span>);
</pre>
<p>The second way to view slices is to use <a href="qcustom3dvolume.html#renderSlice" translate="no">QCustom3DVolume::renderSlice</a>() method, which produces a <a href="../qtgui/qimage.html" translate="no">QImage</a> from the specified slice. This image can then be displayed on another widget, such as a <a href="../qtwidgets/qlabel.html" translate="no">QLabel</a>:</p>
<pre class="cpp" translate="no">
 m_sliceLabelX<span class="operator">-</span><span class="operator">&gt;</span>setPixmap(
             <span class="type"><a href="../qtgui/qpixmap.html" translate="no">QPixmap</a></span><span class="operator">::</span>fromImage(m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>renderSlice(<span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>XAxis<span class="operator">,</span> m_sliceIndexX)));
</pre>
<h4 id="adjusting-volume-transparency">Adjusting Volume Transparency</h4>
<p>Sometimes, viewing just the slices doesn't give you a good understanding of the volume's internal structure. <a href="qcustom3dvolume.html" translate="no">QCustom3DVolume</a> provides two properties that can be used to adjust the volume transparency:</p>
<pre class="cpp" translate="no">
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setAlphaMultiplier(mult);
     ...
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setPreserveOpacity(enabled);
</pre>
<p>The <a href="qcustom3dvolume.html#alphaMultiplier-prop" translate="no">QCustom3DVolume::alphaMultiplier</a> is a general multiplier that is applied to the alpha value of each voxel of the volume. It makes it possible to add uniform transparency to the already somewhat transparent portions of the volume to reveal internal opaque details. This multiplier doesn't affect colors that are fully opaque, unless the <a href="qcustom3dvolume.html#preserveOpacity-prop" translate="no">QCustom3DVolume::preserveOpacity</a> property is set to <code translate="no">false</code>.</p>
<p>An alternative way to adjust the transparency of the volume is to adjust the alpha values of the voxels directly. For eight bit indexed textures, this is done simply by modifying and resetting the color table:</p>
<pre class="cpp" translate="no">
 <span class="type">int</span> newAlpha <span class="operator">=</span> enabled <span class="operator">?</span> terrainTransparency : <span class="number">255</span>;
 <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> aboveWaterGroundColorsMin; i <span class="operator">&lt;</span> underWaterGroundColorsMax; i<span class="operator">+</span><span class="operator">+</span>) {
     <span class="type"><a href="../qtgui/qcolor.html#QRgb-typedef" translate="no">QRgb</a></span> oldColor1 <span class="operator">=</span> m_colorTable1<span class="operator">.</span>at(i);
     <span class="type"><a href="../qtgui/qcolor.html#QRgb-typedef" translate="no">QRgb</a></span> oldColor2 <span class="operator">=</span> m_colorTable2<span class="operator">.</span>at(i);
     m_colorTable1<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> <a href="../qtgui/qcolor.html#qRgba" translate="no">qRgba</a>(qRed(oldColor1)<span class="operator">,</span> qGreen(oldColor1)<span class="operator">,</span> qBlue(oldColor1)<span class="operator">,</span> newAlpha);
     m_colorTable2<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> <a href="../qtgui/qcolor.html#qRgba" translate="no">qRgba</a>(qRed(oldColor2)<span class="operator">,</span> qGreen(oldColor2)<span class="operator">,</span> qBlue(oldColor2)<span class="operator">,</span> newAlpha);
 }
 <span class="keyword">if</span> (m_usingPrimaryTable)
     m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setColorTable(m_colorTable1);
 <span class="keyword">else</span>
     m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setColorTable(m_colorTable2);
</pre>
<h4 id="high-definition-vs-low-definition-shader">High Definition vs. Low Definition Shader</h4>
<p>By default, the volumetric rendering uses a high definition shader. It accounts for each voxel of the volume with the correct weight when ray-tracing the volume contents, providing an accurate representation of even the finer details of the volume. However, this is computationally very expensive, so the frame rate suffers. If rendering speed is more important than pixel-perfect accuracy of the volume contents, take the much faster low definition shader into use by setting <a href="qcustom3dvolume.html#useHighDefShader-prop" translate="no">QCustom3DVolume::useHighDefShader</a> property <code translate="no">false</code>. The low definition shader achieves the speed by making compromises on accuracy, so it doesn't guarantee that every voxel of the volume will be sampled. This can lead to flickering or other rendering artifacts on the finer details of the volume.</p>
<pre class="cpp" translate="no">
 m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setUseHighDefShader(enabled);
</pre>
<h4 id="example-contents">Example Contents</h4>
<p><a href="https://code.qt.io/cgit/qt/qtdatavis3d.git/tree/examples/datavisualization/volumetric?h=6.6" translate="no">Example project @ code.qt.io</a></p>
</div>
<!-- @@@volumetric -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2023 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
