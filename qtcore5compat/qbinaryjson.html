<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qbinaryjson.cpp -->
  <meta name="description" content="Contains functions for converting QJsonDocument to and from JSON binary format.">
  <title>QBinaryJson Namespace | Qt 5 Core Compatibility APIs 6.6.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.6</a></li>
<li><a href="qtcore5-index.html" translate="no">Qt 5 Core Compatibility APIs</a></li>
<li>QBinaryJson Namespace</li>
<li id="buildversion"><a href="qtcore5-index.html" translate="no">Qt 6.6&#x2e;0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#types">Types</a></li>
<li class="level1"><a href="#functions">Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QBinaryJson Namespace</h1>
<!-- $$$QBinaryJson-brief -->
<p>Contains functions for converting <a href="../qtcore/qjsondocument.html" translate="no">QJsonDocument</a> to and from JSON binary format. <a href="#details">More...</a></p>
<!-- @@@QBinaryJson -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QBinaryJson&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core5Compat) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core5Compat)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core5compat</td></tr>
</table></div>
<h2 id="types">Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qbinaryjson.html#DataValidation-enum" translate="no">DataValidation</a></b> { Validate, BypassValidation }</td></tr>
</table></div>
<h2 id="functions">Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QJsonDocument </td><td class="memItemRight bottomAlign"><b><a href="qbinaryjson.html#fromBinaryData" translate="no">fromBinaryData</a></b>(const QByteArray &amp;<i>data</i>, QBinaryJson::DataValidation <i>validation</i> = Validate)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJsonDocument </td><td class="memItemRight bottomAlign"><b><a href="qbinaryjson.html#fromRawData" translate="no">fromRawData</a></b>(const char *<i>data</i>, int <i>size</i>, QBinaryJson::DataValidation <i>validation</i> = Validate)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qbinaryjson.html#toBinaryData" translate="no">toBinaryData</a></b>(const QJsonDocument &amp;<i>document</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="qbinaryjson.html#toRawData" translate="no">toRawData</a></b>(const QJsonDocument &amp;<i>document</i>, int *<i>size</i>)</td></tr>
</table></div>
<!-- $$$QBinaryJson-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>This namespace provides utility functions to keep compatibility with older code, which uses the JSON binary format for serializing JSON. Qt JSON types can be converted to Qt CBOR types, which can in turn be serialized into the CBOR binary format and vice versa.</p>
</div>
<!-- @@@QBinaryJson -->
<div class="types">
<h2>Type Documentation</h2>
<!-- $$$DataValidation$$$Validate$$$BypassValidation -->
<h3 class="fn" translate="no" id="DataValidation-enum">enum QBinaryJson::<span class="name">DataValidation</span></h3>
<p>This enum is used to tell <a href="../qtcore/qjsondocument.html" translate="no">QJsonDocument</a> whether to validate the binary data when converting to a <a href="../qtcore/qjsondocument.html" translate="no">QJsonDocument</a> using <a href="qbinaryjson.html#fromBinaryData" translate="no">fromBinaryData</a>() or <a href="qbinaryjson.html#fromRawData" translate="no">fromRawData</a>().</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QBinaryJson::Validate</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Validate the data before using it. This is the default.</td></tr>
<tr><td class="topAlign"><code translate="no">QBinaryJson::BypassValidation</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Bypasses data validation. Only use if you received the data from a trusted place and know it's valid, as using of invalid data can crash the application.</td></tr>
</table></div>
<!-- @@@DataValidation -->
</div>
<div class="func">
<h2>Function Documentation</h2>
<!-- $$$fromBinaryData[overload1]$$$fromBinaryDataconstQByteArray&QBinaryJson::DataValidation -->
<h3 class="fn" translate="no" id="fromBinaryData"><span class="type"><a href="../qtcore/qjsondocument.html" translate="no">QJsonDocument</a></span> QBinaryJson::<span class="name">fromBinaryData</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>data</i>, <span class="type"><a href="qbinaryjson.html#DataValidation-enum" translate="no">QBinaryJson::DataValidation</a></span> <i>validation</i> = Validate)</h3>
<p>Creates a <a href="../qtcore/qjsondocument.html" translate="no">QJsonDocument</a> from <i translate="no">data</i>.</p>
<p><i translate="no">validation</i> decides whether the data is checked for validity before being used. By default the data is validated. If the <i translate="no">data</i> is not valid, the method returns a null document.</p>
<div class="admonition note">
<p><b>Note: </b>The binary JSON encoding is only retained for backwards compatibility. It is undocumented and restrictive in the maximum size of JSON documents that can be encoded. Qt JSON types can be converted to Qt CBOR types, which can in turn be serialized into the CBOR binary format and vice versa. The CBOR format is a well-defined and less restrictive binary representation for a superset of JSON.</p>
</div>
<p><b>See also </b><a href="qbinaryjson.html#toBinaryData" translate="no">toBinaryData</a>(), <a href="qbinaryjson.html#fromRawData" translate="no">fromRawData</a>(), <a href="qbinaryjson.html#DataValidation-enum" translate="no">DataValidation</a>, and <a href="../qtcore/qcborvalue.html" translate="no">QCborValue</a>.</p>
<!-- @@@fromBinaryData -->
<!-- $$$fromRawData[overload1]$$$fromRawDataconstchar*intQBinaryJson::DataValidation -->
<h3 class="fn" translate="no" id="fromRawData"><span class="type"><a href="../qtcore/qjsondocument.html" translate="no">QJsonDocument</a></span> QBinaryJson::<span class="name">fromRawData</span>(const <span class="type">char</span> *<i>data</i>, <span class="type">int</span> <i>size</i>, <span class="type"><a href="qbinaryjson.html#DataValidation-enum" translate="no">QBinaryJson::DataValidation</a></span> <i>validation</i> = Validate)</h3>
<p>Creates a <a href="../qtcore/qjsondocument.html" translate="no">QJsonDocument</a> that uses the first <i translate="no">size</i> bytes from <i translate="no">data</i>. It assumes <i translate="no">data</i> contains a binary encoded JSON document. The created document does not take ownership of <i translate="no">data</i>. The data is copied into a different data structure, and the original data can be deleted or modified afterwards.</p>
<p><i translate="no">data</i> has to be aligned to a 4 byte boundary.</p>
<p><i translate="no">validation</i> decides whether the data is checked for validity before being used. By default the data is validated. If the <i translate="no">data</i> is not valid, the method returns a null document.</p>
<p>Returns a <a href="../qtcore/qjsondocument.html" translate="no">QJsonDocument</a> representing the data.</p>
<div class="admonition note">
<p><b>Note: </b>The binary JSON encoding is only retained for backwards compatibility. It is undocumented and restrictive in the maximum size of JSON documents that can be encoded. Qt JSON types can be converted to Qt CBOR types, which can in turn be serialized into the CBOR binary format and vice versa. The CBOR format is a well-defined and less restrictive binary representation for a superset of JSON.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Before Qt 5.15, the caller had to guarantee that <i translate="no">data</i> would not be deleted or modified as long as any <a href="../qtcore/qjsondocument.html" translate="no">QJsonDocument</a>, <a href="../qtcore/qjsonobject.html" translate="no">QJsonObject</a> or <a href="../qtcore/qjsonarray.html" translate="no">QJsonArray</a> still referenced the data. From Qt 5.15 on, this is not necessary anymore.</p>
</div>
<p><b>See also </b><a href="qbinaryjson.html#toRawData" translate="no">toRawData</a>(), <a href="qbinaryjson.html#fromBinaryData" translate="no">fromBinaryData</a>(), <a href="qbinaryjson.html#DataValidation-enum" translate="no">DataValidation</a>, and <a href="../qtcore/qcborvalue.html" translate="no">QCborValue</a>.</p>
<!-- @@@fromRawData -->
<!-- $$$toBinaryData[overload1]$$$toBinaryDataconstQJsonDocument& -->
<h3 class="fn" translate="no" id="toBinaryData"><span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> QBinaryJson::<span class="name">toBinaryData</span>(const <span class="type"><a href="../qtcore/qjsondocument.html" translate="no">QJsonDocument</a></span> &amp;<i>document</i>)</h3>
<p>Returns a binary representation of <i translate="no">document</i>.</p>
<p>The binary representation is also the native format used internally in Qt, and is very efficient and fast to convert to and from.</p>
<p>The binary format can be stored on disk and interchanged with other applications or computers. <a href="qbinaryjson.html#fromBinaryData" translate="no">fromBinaryData</a>() can be used to convert it back into a JSON document.</p>
<div class="admonition note">
<p><b>Note: </b>The binary JSON encoding is only retained for backwards compatibility. It is undocumented and restrictive in the maximum size of JSON documents that can be encoded. Qt JSON types can be converted to Qt CBOR types, which can in turn be serialized into the CBOR binary format and vice versa. The CBOR format is a well-defined and less restrictive binary representation for a superset of JSON.</p>
</div>
<p><b>See also </b><a href="qbinaryjson.html#fromBinaryData" translate="no">fromBinaryData</a>() and <a href="../qtcore/qcborvalue.html" translate="no">QCborValue</a>.</p>
<!-- @@@toBinaryData -->
<!-- $$$toRawData[overload1]$$$toRawDataconstQJsonDocument&int* -->
<h3 class="fn" translate="no" id="toRawData">const <span class="type">char</span> *QBinaryJson::<span class="name">toRawData</span>(const <span class="type"><a href="../qtcore/qjsondocument.html" translate="no">QJsonDocument</a></span> &amp;<i>document</i>, <span class="type">int</span> *<i>size</i>)</h3>
<p>Returns the raw binary representation of <i translate="no">document</i>. <i translate="no">size</i> will contain the size of the returned data.</p>
<p>This method is useful to e.g&#x2e; stream the JSON document in its binary form to a file.</p>
<div class="admonition note">
<p><b>Note: </b>The binary JSON encoding is only retained for backwards compatibility. It is undocumented and restrictive in the maximum size of JSON documents that can be encoded. Qt JSON types can be converted to Qt CBOR types, which can in turn be serialized into the CBOR binary format and vice versa. The CBOR format is a well-defined and less restrictive binary representation for a superset of JSON.</p>
</div>
<p><b>See also </b><a href="qbinaryjson.html#fromRawData" translate="no">fromRawData</a>(), <a href="qbinaryjson.html#fromBinaryData" translate="no">fromBinaryData</a>(), <a href="qbinaryjson.html#toBinaryData" translate="no">toBinaryData</a>(), and <a href="../qtcore/qcborvalue.html" translate="no">QCborValue</a>.</p>
<!-- @@@toRawData -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2023 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
