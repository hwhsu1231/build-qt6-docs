<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qregexp.cpp -->
  <meta name="description" content="The QRegExp class provides pattern matching using regular expressions.">
  <title>QRegExp Class | Qt 5 Core Compatibility APIs 6.6.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.6</a></li>
<li><a href="qtcore5-index.html" translate="no">Qt 5 Core Compatibility APIs</a></li>
<li><a href="qtcore5compat-module.html" translate="no">C++ Classes</a></li>
<li>QRegExp</li>
<li id="buildversion"><a href="qtcore5-index.html" translate="no">Qt 6.6&#x2e;0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#introduction">Introduction</a></li>
<li class="level2"><a href="#characters-and-abbreviations-for-sets-of-characters">Characters and Abbreviations for Sets of Characters</a></li>
<li class="level2"><a href="#sets-of-characters">Sets of Characters</a></li>
<li class="level2"><a href="#quantifiers">Quantifiers</a></li>
<li class="level2"><a href="#capturing-text">Capturing Text</a></li>
<li class="level2"><a href="#assertions">Assertions</a></li>
<li class="level2"><a href="#wildcard-matching">Wildcard Matching</a></li>
<li class="level2"><a href="#notes-for-perl-users">Notes for Perl Users</a></li>
<li class="level2"><a href="#code-examples">Code Examples</a></li>
<li class="level2"><a href="#porting-to-qregularexpression">Porting to QRegularExpression</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QRegExp Class</h1>
<!-- $$$QRegExp-brief -->
<p>The QRegExp class provides pattern matching using regular expressions. <a href="#details">More...</a></p>
<!-- @@@QRegExp -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QRegExp&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Core5Compat) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Core5Compat)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core5compat</td></tr>
</table></div>
<ul>
<li><a href="qregexp-members.html">List of all members, including inherited members</a></li>
<li>QRegExp is part of <a href="../qtcore/shared.html">Implicitly Shared Classes</a>.</li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="../qtdoc/threads-reentrancy.html" translate="no">reentrant</a>.</p>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#CaretMode-enum" translate="no">CaretMode</a></b> { CaretAtZero, CaretAtOffset, CaretWontMatch }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#PatternSyntax-enum" translate="no">PatternSyntax</a></b> { RegExp, RegExp2, Wildcard, WildcardUnix, FixedString, W3CXmlSchema11 }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#QRegExp-1" translate="no">QRegExp</a></b>(const QString &amp;<i>pattern</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive, PatternSyntax <i>syntax</i> = RegExp)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#QRegExp-2" translate="no">QRegExp</a></b>(const QRegExp &amp;<i>rx</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#dtor.QRegExp" translate="no">~QRegExp</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#cap" translate="no">cap</a></b>(int <i>nth</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#captureCount" translate="no">captureCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#capturedTexts" translate="no">capturedTexts</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::CaseSensitivity </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#caseSensitivity" translate="no">caseSensitivity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#countIn" translate="no">countIn</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#errorString" translate="no">errorString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#exactMatch" translate="no">exactMatch</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#filterList" translate="no">filterList</a></b>(const QStringList &amp;<i>stringList</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#indexIn" translate="no">indexIn</a></b>(const QString &amp;<i>str</i>, int <i>offset</i> = 0, CaretMode <i>caretMode</i> = CaretAtZero) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#indexIn-1" translate="no">indexIn</a></b>(const QStringList &amp;<i>list</i>, int <i>from</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#isEmpty" translate="no">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#isMinimal" translate="no">isMinimal</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#lastIndexIn" translate="no">lastIndexIn</a></b>(const QString &amp;<i>str</i>, int <i>offset</i> = -1, CaretMode <i>caretMode</i> = CaretAtZero) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#lastIndexIn-1" translate="no">lastIndexIn</a></b>(const QStringList &amp;<i>list</i>, int <i>from</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#matchedLength" translate="no">matchedLength</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#pattern" translate="no">pattern</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> PatternSyntax </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#patternSyntax" translate="no">patternSyntax</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#pos" translate="no">pos</a></b>(int <i>nth</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#removeIn" translate="no">removeIn</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#replaceIn" translate="no">replaceIn</a></b>(const QString &amp;<i>str</i>, const QString &amp;<i>after</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#replaceIn-1" translate="no">replaceIn</a></b>(const QStringList &amp;<i>stringList</i>, const QString &amp;<i>after</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#setCaseSensitivity" translate="no">setCaseSensitivity</a></b>(Qt::CaseSensitivity <i>cs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#setMinimal" translate="no">setMinimal</a></b>(bool <i>minimal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#setPattern" translate="no">setPattern</a></b>(const QString &amp;<i>pattern</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#setPatternSyntax" translate="no">setPatternSyntax</a></b>(PatternSyntax <i>syntax</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#splitString" translate="no">splitString</a></b>(const QString &amp;<i>str</i>, Qt::SplitBehavior <i>behavior</i> = Qt::KeepEmptyParts) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#swap" translate="no">swap</a></b>(QRegExp &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariant </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#operator-QVariant" translate="no">operator QVariant</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#operator-not-eq" translate="no">operator!=</a></b>(const QRegExp &amp;<i>rx</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRegExp &amp;</td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#operator-eq" translate="no">operator=</a></b>(const QRegExp &amp;<i>rx</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRegExp &amp;</td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#operator-eq-1" translate="no">operator=</a></b>(QRegExp &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#operator-eq-eq" translate="no">operator==</a></b>(const QRegExp &amp;<i>rx</i>) const</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#escape" translate="no">escape</a></b>(const QString &amp;<i>str</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> size_t </td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#qHash" translate="no">qHash</a></b>(const QRegExp &amp;<i>key</i>, size_t <i>seed</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#operator-lt-lt" translate="no">operator&lt;&lt;</a></b>(QDataStream &amp;<i>out</i>, const QRegExp &amp;<i>regExp</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="qregexp.html#operator-gt-gt" translate="no">operator&gt;&gt;</a></b>(QDataStream &amp;<i>in</i>, QRegExp &amp;<i>regExp</i>)</td></tr>
</table></div>
<!-- $$$QRegExp-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>This class is deprecated in Qt 6. Please use <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a> instead for all new code. For guidelines on porting old code from QRegExp to <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a>, see {Porting to <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a>}</p>
<p>A regular expression, or &quot;regexp&quot;, is a pattern for matching substrings in a text. This is useful in many contexts, e.g&#x2e;,</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td >Validation</td><td >A regexp can test whether a substring meets some criteria, e.g&#x2e; is an integer or contains no whitespace.</td></tr>
<tr valign="top" class="even"><td >Searching</td><td >A regexp provides more powerful pattern matching than simple substring matching, e.g&#x2e;, match one of the words <i>mail</i>, <i>letter</i> or <i>correspondence</i>, but none of the words <i>email</i>, <i>mailman</i>, <i>mailer</i>, <i>letterbox</i>, etc.</td></tr>
<tr valign="top" class="odd"><td >Search and Replace</td><td >A regexp can replace all occurrences of a substring with a different substring, e.g&#x2e;, replace all occurrences of <i>&amp;</i> with <i>&amp;amp;</i> except where the <i>&amp;</i> is already followed by an <i>amp;</i>.</td></tr>
<tr valign="top" class="even"><td >String Splitting</td><td >A regexp can be used to identify where a string should be split apart, e.g&#x2e; splitting tab-delimited strings.</td></tr>
</table></div>
<p>A brief introduction to regexps is presented, a description of Qt's regexp language, some examples, and the function documentation itself. QRegExp is modeled on Perl's regexp language. It fully supports Unicode. QRegExp can also be used in a simpler, <i>wildcard mode</i> that is similar to the functionality found in command shells. The syntax rules used by QRegExp can be changed with <a href="qregexp.html#setPatternSyntax" translate="no">setPatternSyntax</a>(). In particular, the pattern syntax can be set to <a href="qregexp.html#PatternSyntax-enum" translate="no">QRegExp::FixedString</a>, which means the pattern to be matched is interpreted as a plain string, i.e&#x2e;, special characters (e.g&#x2e;, backslash) are not escaped.</p>
<p>A good text on regexps is <i>Mastering Regular Expressions</i> (Third Edition) by Jeffrey E. F. Friedl, ISBN 0-596-52812-4.</p>
<div class="admonition note">
<p><b>Note: </b>In Qt 5, the new <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a> class provides a Perl compatible implementation of regular expressions and is recommended in place of QRegExp.</p>
</div>
<h3 id="introduction">Introduction</h3>
<p>Regexps are built up from expressions, quantifiers, and assertions. The simplest expression is a character, e.g&#x2e; <b>x</b> or <b>5</b>. An expression can also be a set of characters enclosed in square brackets. <b>[ABCD]</b> will match an <b>A</b> or a <b>B</b> or a <b>C</b> or a <b>D</b>. We can write this same expression as <b>[A-D]</b>, and an expression to match any capital letter in the English alphabet is written as <b>[A-Z]</b>.</p>
<p>A quantifier specifies the number of occurrences of an expression that must be matched. <b>x{1,1}</b> means match one and only one <b>x</b>. <b>x{1,5}</b> means match a sequence of <b>x</b> characters that contains at least one <b>x</b> but no more than five.</p>
<p>Note that in general regexps cannot be used to check for balanced brackets or tags. For example, a regexp can be written to match an opening html <code translate="no">&lt;b&gt;</code> and its closing <code translate="no">&lt;/b&gt;</code>, if the <code translate="no">&lt;b&gt;</code> tags are not nested, but if the <code translate="no">&lt;b&gt;</code> tags are nested, that same regexp will match an opening <code translate="no">&lt;b&gt;</code> tag with the wrong closing <code translate="no">&lt;/b&gt;</code>. For the fragment <code translate="no">&lt;b&gt;bold &lt;b&gt;bolder&lt;/b&gt;&lt;/b&gt;</code>, the first <code translate="no">&lt;b&gt;</code> would be matched with the first <code translate="no">&lt;/b&gt;</code>, which is not correct. However, it is possible to write a regexp that will match nested brackets or tags correctly, but only if the number of nesting levels is fixed and known. If the number of nesting levels is not fixed and known, it is impossible to write a regexp that will not fail.</p>
<p>Suppose we want a regexp to match integers in the range 0 to 99. At least one digit is required, so we start with the expression <b>[0-9]{1,1}</b>, which matches a single digit exactly once. This regexp matches integers in the range 0 to 9. To match integers up to 99, increase the maximum number of occurrences to 2, so the regexp becomes <b>[0-9]{1,2}</b>. This regexp satisfies the original requirement to match integers from 0 to 99, but it will also match integers that occur in the middle of strings. If we want the matched integer to be the whole string, we must use the anchor assertions, <b>^</b> (caret) and <b>$</b> (dollar). When <b>^</b> is the first character in a regexp, it means the regexp must match from the beginning of the string. When <b>$</b> is the last character of the regexp, it means the regexp must match to the end of the string. The regexp becomes <b>^[0-9]{1,2}$</b>. Note that assertions, e.g&#x2e; <b>^</b> and <b>$</b>, do not match characters but locations in the string.</p>
<p>If you have seen regexps described elsewhere, they may have looked different from the ones shown here. This is because some sets of characters and some quantifiers are so common that they have been given special symbols to represent them. <b>[0-9]</b> can be replaced with the symbol <b>\d</b>. The quantifier to match exactly one occurrence, <b>{1,1}</b>, can be replaced with the expression itself, i.e&#x2e; <b>x{1,1}</b> is the same as <b>x</b>. So our 0 to 99 matcher could be written as <b>^\d{1,2}$</b>. It can also be written <b>^\d\d{0,1}$</b>, i.e&#x2e; <i>From the start of the string, match a digit, followed immediately by 0 or 1 digits</i>. In practice, it would be written as <b>^\d\d?$</b>. The <b>?</b> is shorthand for the quantifier <b>{0,1}</b>, i.e&#x2e; 0 or 1 occurrences. <b>?</b> makes an expression optional. The regexp <b>^\d\d?$</b> means <i>From the beginning of the string, match one digit, followed immediately by 0 or 1 more digit, followed immediately by end of string</i>.</p>
<p>To write a regexp that matches one of the words 'mail' <i>or</i> 'letter' <i>or</i> 'correspondence' but does not match words that contain these words, e.g&#x2e;, 'email', 'mailman', 'mailer', and 'letterbox', start with a regexp that matches 'mail'. Expressed fully, the regexp is <b>m{1,1}a{1,1}i{1,1}l{1,1}</b>, but because a character expression is automatically quantified by <b>{1,1}</b>, we can simplify the regexp to <b>mail</b>, i.e&#x2e;, an 'm' followed by an 'a' followed by an 'i' followed by an 'l'. Now we can use the vertical bar <b>|</b>, which means <b>or</b>, to include the other two words, so our regexp for matching any of the three words becomes <b>mail|letter|correspondence</b>. Match 'mail' <b>or</b> 'letter' <b>or</b> 'correspondence'. While this regexp will match one of the three words we want to match, it will also match words we don't want to match, e.g&#x2e;, 'email'. To prevent the regexp from matching unwanted words, we must tell it to begin and end the match at word boundaries. First we enclose our regexp in parentheses, <b>(mail|letter|correspondence)</b>. Parentheses group expressions together, and they identify a part of the regexp that we wish to <a href="qregexp.html#capturing-text" translate="no">capture</a>. Enclosing the expression in parentheses allows us to use it as a component in more complex regexps. It also allows us to examine which of the three words was actually matched. To force the match to begin and end on word boundaries, we enclose the regexp in <b>\b</b> <i>word boundary</i> assertions: <b>\b(mail|letter|correspondence)\b</b>. Now the regexp means: <i>Match a word boundary, followed by the regexp in parentheses, followed by a word boundary</i>. The <b>\b</b> assertion matches a <i>position</i> in the regexp, not a <i>character</i>. A word boundary is any non-word character, e.g&#x2e;, a space, newline, or the beginning or ending of a string.</p>
<p>If we want to replace ampersand characters with the HTML entity <b>&amp;amp;</b>, the regexp to match is simply <b>&amp;</b>. But this regexp will also match ampersands that have already been converted to HTML entities. We want to replace only ampersands that are not already followed by <b>amp;</b>. For this, we need the negative lookahead assertion, <b>(?!</b>__<b>)</b>. The regexp can then be written as <b>&amp;(?!amp;)</b>, i.e&#x2e; <i>Match an ampersand that is</i> <b>not</b> <i>followed by</i> <b>amp;</b>.</p>
<p>If we want to count all the occurrences of 'Eric' and 'Eirik' in a string, two valid solutions are <b>\b(Eric|Eirik)\b</b> and <b>\bEi?ri[ck]\b</b>. The word boundary assertion '\b' is required to avoid matching words that contain either name, e.g&#x2e; 'Ericsson'. Note that the second regexp matches more spellings than we want: 'Eric', 'Erik', 'Eiric' and 'Eirik'.</p>
<p>Some of the examples discussed above are implemented in the <a href="qregexp.html#code-examples" translate="no">code examples</a> section.</p>
<span id="characters-and-abbreviations-for-sets-of-characters"></span><h3 id="characters-and-abbreviations-for-sets-of-characters">Characters and Abbreviations for Sets of Characters</h3>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Element</th><th >Meaning</th></tr></thead>
<tr valign="top" class="odd"><td ><b>c</b></td><td >A character represents itself unless it has a special regexp meaning. e.g&#x2e; <b>c</b> matches the character <i>c</i>.</td></tr>
<tr valign="top" class="even"><td ><b>\c</b></td><td >A character that follows a backslash matches the character itself, except as specified below. e.g&#x2e;, To match a literal caret at the beginning of a string, write <b>\^</b>.</td></tr>
<tr valign="top" class="odd"><td ><b>\a</b></td><td >Matches the ASCII bell (BEL, 0x07).</td></tr>
<tr valign="top" class="even"><td ><b>\f</b></td><td >Matches the ASCII form feed (FF, 0x0C).</td></tr>
<tr valign="top" class="odd"><td ><b>\n</b></td><td >Matches the ASCII line feed (LF, 0x0A, Unix newline).</td></tr>
<tr valign="top" class="even"><td ><b>\r</b></td><td >Matches the ASCII carriage return (CR, 0x0D).</td></tr>
<tr valign="top" class="odd"><td ><b>\t</b></td><td >Matches the ASCII horizontal tab (HT, 0x09).</td></tr>
<tr valign="top" class="even"><td ><b>\v</b></td><td >Matches the ASCII vertical tab (VT, 0x0B).</td></tr>
<tr valign="top" class="odd"><td ><b>\x<i>hhhh</i></b></td><td >Matches the Unicode character corresponding to the hexadecimal number <i>hhhh</i> (between 0x0000 and 0xFFFF).</td></tr>
<tr valign="top" class="even"><td ><b>\0<i>ooo</i></b> (i.e&#x2e;, \zero <i>ooo</i>)</td><td >matches the ASCII/Latin1 character for the octal number <i>ooo</i> (between 0 and 0377).</td></tr>
<tr valign="top" class="odd"><td ><b>. (dot)</b></td><td >Matches any character (including newline).</td></tr>
<tr valign="top" class="even"><td ><b>\d</b></td><td >Matches a digit (<a href="../qtcore/qchar.html#isDigit" translate="no">QChar::isDigit</a>()).</td></tr>
<tr valign="top" class="odd"><td ><b>\D</b></td><td >Matches a non-digit.</td></tr>
<tr valign="top" class="even"><td ><b>\s</b></td><td >Matches a whitespace character (<a href="../qtcore/qchar.html#isSpace" translate="no">QChar::isSpace</a>()).</td></tr>
<tr valign="top" class="odd"><td ><b>\S</b></td><td >Matches a non-whitespace character.</td></tr>
<tr valign="top" class="even"><td ><b>\w</b></td><td >Matches a word character (<a href="../qtcore/qchar.html#isLetterOrNumber" translate="no">QChar::isLetterOrNumber</a>(), <a href="../qtcore/qchar.html#isMark" translate="no">QChar::isMark</a>(), or '_').</td></tr>
<tr valign="top" class="odd"><td ><b>\W</b></td><td >Matches a non-word character.</td></tr>
<tr valign="top" class="even"><td ><b>\<i>n</i></b></td><td >The <i>n</i>-th backreference, e.g&#x2e; \1, \2, etc.</td></tr>
</table></div>
<p><b>Note:</b> The C++ compiler transforms backslashes in strings. To include a <b>\</b> in a regexp, enter it twice, i.e&#x2e; <code translate="no">\\</code>. To match the backslash character itself, enter it four times, i.e&#x2e; <code translate="no">\\\\</code>.</p>
<span id="sets-of-characters"></span><h3 id="sets-of-characters">Sets of Characters</h3>
<p>Square brackets mean match any character contained in the square brackets. The character set abbreviations described above can appear in a character set in square brackets. Except for the character set abbreviations and the following two exceptions, characters do not have special meanings in square brackets.</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td ><b>^</b></td><td >The caret negates the character set if it occurs as the first character (i.e&#x2e; immediately after the opening square bracket). <b>[abc]</b> matches 'a' or 'b' or 'c', but <b>[^abc]</b> matches anything <i>but</i> 'a' or 'b' or 'c'.</td></tr>
<tr valign="top" class="even"><td ><b>-</b></td><td >The dash indicates a range of characters. <b>[W-Z]</b> matches 'W' or 'X' or 'Y' or 'Z'.</td></tr>
</table></div>
<p>Using the predefined character set abbreviations is more portable than using character ranges across platforms and languages. For example, <b>[0-9]</b> matches a digit in Western alphabets but <b>\d</b> matches a digit in <i>any</i> alphabet.</p>
<p>Note: In other regexp documentation, sets of characters are often called &quot;character classes&quot;.</p>
<span id="quantifiers"></span><h3 id="quantifiers">Quantifiers</h3>
<p>By default, an expression is automatically quantified by <b>{1,1}</b>, i.e&#x2e; it should occur exactly once. In the following list, <b><i>E</i></b> stands for expression. An expression is a character, or an abbreviation for a set of characters, or a set of characters in square brackets, or an expression in parentheses.</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td ><b><i>E</i>?</b></td><td >Matches zero or one occurrences of <i>E</i>. This quantifier means <i>The previous expression is optional</i>, because it will match whether or not the expression is found. <b><i>E</i>?</b> is the same as <b><i>E</i>{0,1}</b>. e.g&#x2e;, <b>dents?</b> matches 'dent' or 'dents'.</td></tr>
<tr valign="top" class="even"><td ><b><i>E</i>+</b></td><td >Matches one or more occurrences of <i>E</i>. <b><i>E</i>+</b> is the same as <b><i>E</i>{1,}</b>. e.g&#x2e;, <b>0+</b> matches '0', '00', '000', etc.</td></tr>
<tr valign="top" class="odd"><td ><b><i>E</i>*</b></td><td >Matches zero or more occurrences of <i>E</i>. It is the same as <b><i>E</i>{0,}</b>. The <b>*</b> quantifier is often used in error where <b>+</b> should be used. For example, if <b>\s*$</b> is used in an expression to match strings that end in whitespace, it will match every string because <b>\s*$</b> means <i>Match zero or more whitespaces followed by end of string</i>. The correct regexp to match strings that have at least one trailing whitespace character is <b>\s+$</b>.</td></tr>
<tr valign="top" class="even"><td ><b><i>E</i>{n}</b></td><td >Matches exactly <i>n</i> occurrences of <i>E</i>. <b><i>E</i>{n}</b> is the same as repeating <i>E</i> <i>n</i> times. For example, <b>x{5}</b> is the same as <b>xxxxx</b>. It is also the same as <b><i>E</i>{n,n}</b>, e.g&#x2e; <b>x{5,5}</b>.</td></tr>
<tr valign="top" class="odd"><td ><b><i>E</i>{n,}</b></td><td >Matches at least <i>n</i> occurrences of <i>E</i>.</td></tr>
<tr valign="top" class="even"><td ><b><i>E</i>{,m}</b></td><td >Matches at most <i>m</i> occurrences of <i>E</i>. <b><i>E</i>{,m}</b> is the same as <b><i>E</i>{0,m}</b>.</td></tr>
<tr valign="top" class="odd"><td ><b><i>E</i>{n,m}</b></td><td >Matches at least <i>n</i> and at most <i>m</i> occurrences of <i>E</i>.</td></tr>
</table></div>
<p>To apply a quantifier to more than just the preceding character, use parentheses to group characters together in an expression. For example, <b>tag+</b> matches a 't' followed by an 'a' followed by at least one 'g', whereas <b>(tag)+</b> matches at least one occurrence of 'tag'.</p>
<p>Note: Quantifiers are normally &quot;greedy&quot;. They always match as much text as they can. For example, <b>0+</b> matches the first zero it finds and all the consecutive zeros after the first zero. Applied to '20005', it matches '2<u>000</u>5'. Quantifiers can be made non-greedy, see <a href="qregexp.html#setMinimal" translate="no">setMinimal</a>().</p>
<span id="capturing-parentheses"></span><span id="backreferences"></span><h3 id="capturing-text">Capturing Text</h3>
<p>Parentheses allow us to group elements together so that we can quantify and capture them. For example if we have the expression <b>mail|letter|correspondence</b> that matches a string we know that <i>one</i> of the words matched but not which one. Using parentheses allows us to &quot;capture&quot; whatever is matched within their bounds, so if we used <b>(mail|letter|correspondence)</b> and matched this regexp against the string &quot;I sent you some email&quot; we can use the <a href="qregexp.html#cap" translate="no">cap</a>() or <a href="qregexp.html#capturedTexts" translate="no">capturedTexts</a>() functions to extract the matched characters, in this case 'mail'.</p>
<p>We can use captured text within the regexp itself. To refer to the captured text we use <i>backreferences</i> which are indexed from 1, the same as for <a href="qregexp.html#cap" translate="no">cap</a>(). For example we could search for duplicate words in a string using <b>\b(\w+)\W+\1\b</b> which means match a word boundary followed by one or more word characters followed by one or more non-word characters followed by the same text as the first parenthesized expression followed by a word boundary.</p>
<p>If we want to use parentheses purely for grouping and not for capturing we can use the non-capturing syntax, e.g&#x2e; <b>(?:green|blue)</b>. Non-capturing parentheses begin '(?:' and end ')'. In this example we match either 'green' or 'blue' but we do not capture the match so we only know whether or not we matched but not which color we actually found. Using non-capturing parentheses is more efficient than using capturing parentheses since the regexp engine has to do less book-keeping.</p>
<p>Both capturing and non-capturing parentheses may be nested.</p>
<span id="greedy-quantifiers"></span><p>For historical reasons, quantifiers (e.g&#x2e; <b>*</b>) that apply to capturing parentheses are more &quot;greedy&quot; than other quantifiers. For example, <b>a*(a*)</b> will match &quot;aaa&quot; with cap(1) == &quot;aaa&quot;. This behavior is different from what other regexp engines do (notably, Perl). To obtain a more intuitive capturing behavior, specify <a href="qregexp.html#PatternSyntax-enum" translate="no">QRegExp::RegExp2</a> to the QRegExp constructor or call <a href="qregexp.html#setPatternSyntax" translate="no">setPatternSyntax</a>(<a href="qregexp.html#PatternSyntax-enum" translate="no">QRegExp::RegExp2</a>).</p>
<span id="cap-in-a-loop"></span><p>When the number of matches cannot be determined in advance, a common idiom is to use <a href="qregexp.html#cap" translate="no">cap</a>() in a loop. For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> rx(<span class="string">&quot;(\\d+)&quot;</span>);
 <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;Offsets: 12 14 99 231 7&quot;</span>;
 <span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> list;
 <span class="type">int</span> pos <span class="operator">=</span> <span class="number">0</span>;

 <span class="keyword">while</span> ((pos <span class="operator">=</span> rx<span class="operator">.</span>indexIn(str<span class="operator">,</span> pos)) <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) {
     list <span class="operator">&lt;</span><span class="operator">&lt;</span> rx<span class="operator">.</span>cap(<span class="number">1</span>);
     pos <span class="operator">+</span><span class="operator">=</span> rx<span class="operator">.</span>matchedLength();
 }
 <span class="comment">// list: [&quot;12&quot;, &quot;14&quot;, &quot;99&quot;, &quot;231&quot;, &quot;7&quot;]</span>
</pre>
<span id="assertions"></span><h3 id="assertions">Assertions</h3>
<p>Assertions make some statement about the text at the point where they occur in the regexp but they do not match any characters. In the following list <b><i>E</i></b> stands for any expression.</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td ><b>^</b></td><td >The caret signifies the beginning of the string. If you wish to match a literal <code translate="no">^</code> you must escape it by writing <code translate="no">\\^</code>. For example, <b>^#include</b> will only match strings which <i>begin</i> with the characters '#include'. (When the caret is the first character of a character set it has a special meaning, see <a href="qregexp.html#sets-of-characters" translate="no">Sets of Characters</a>.)</td></tr>
<tr valign="top" class="even"><td ><b>$</b></td><td >The dollar signifies the end of the string. For example <b>\d\s*$</b> will match strings which end with a digit optionally followed by whitespace. If you wish to match a literal <code translate="no">$</code> you must escape it by writing <code translate="no">\\$</code>.</td></tr>
<tr valign="top" class="odd"><td ><b>\b</b></td><td >A word boundary. For example the regexp <b>\bOK\b</b> means match immediately after a word boundary (e.g&#x2e; start of string or whitespace) the letter 'O' then the letter 'K' immediately before another word boundary (e.g&#x2e; end of string or whitespace). But note that the assertion does not actually match any whitespace so if we write <b>(\bOK\b)</b> and we have a match it will only contain 'OK' even if the string is &quot;It's <u>OK</u> now&quot;.</td></tr>
<tr valign="top" class="even"><td ><b>\B</b></td><td >A non-word boundary. This assertion is true wherever <b>\b</b> is false. For example if we searched for <b>\Bon\B</b> in &quot;Left on&quot; the match would fail (space and end of string aren't non-word boundaries), but it would match in &quot;t<u>on</u>ne&quot;.</td></tr>
<tr valign="top" class="odd"><td ><b>(?=<i>E</i>)</b></td><td >Positive lookahead. This assertion is true if the expression matches at this point in the regexp. For example, <b>const(?=\s+char)</b> matches 'const' whenever it is followed by 'char', as in 'static <u>const</u> char *'. (Compare with <b>const\s+char</b>, which matches 'static <u>const char</u> *'.)</td></tr>
<tr valign="top" class="even"><td ><b>(?!<i>E</i>)</b></td><td >Negative lookahead. This assertion is true if the expression does not match at this point in the regexp. For example, <b>const(?!\s+char)</b> matches 'const' <i>except</i> when it is followed by 'char'.</td></tr>
</table></div>
<span id="qregexp-wildcard-matching"></span><h3 id="wildcard-matching">Wildcard Matching</h3>
<p>Most command shells such as <i>bash</i> or <i>cmd.exe</i> support &quot;file globbing&quot;, the ability to identify a group of files by using wildcards. The <a href="qregexp.html#setPatternSyntax" translate="no">setPatternSyntax</a>() function is used to switch between regexp and wildcard mode. Wildcard matching is much simpler than full regexps and has only four features:</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td ><b>c</b></td><td >Any character represents itself apart from those mentioned below. Thus <b>c</b> matches the character <i>c</i>.</td></tr>
<tr valign="top" class="even"><td ><b>?</b></td><td >Matches any single character. It is the same as <b>.</b> in full regexps.</td></tr>
<tr valign="top" class="odd"><td ><b>*</b></td><td >Matches zero or more of any characters. It is the same as <b>.*</b> in full regexps.</td></tr>
<tr valign="top" class="even"><td ><b>[..&#x2e;]</b></td><td >Sets of characters can be represented in square brackets, similar to full regexps. Within the character class, like outside, backslash has no special meaning.</td></tr>
</table></div>
<p>In the mode Wildcard, the wildcard characters cannot be escaped. In the mode <a href="qregexp.html#PatternSyntax-enum" translate="no">WildcardUnix</a>, the character '\' escapes the wildcard.</p>
<p>For example if we are in wildcard mode and have strings which contain filenames we could identify HTML files with <b>*.html</b>. This will match zero or more characters followed by a dot followed by 'h', 't', 'm' and 'l'.</p>
<p>To test a string against a wildcard expression, use <a href="qregexp.html#exactMatch" translate="no">exactMatch</a>(). For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> rx(<span class="string">&quot;*.txt&quot;</span>);
 rx<span class="operator">.</span>setPatternSyntax(<span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span><span class="operator">::</span>Wildcard);
 rx<span class="operator">.</span>exactMatch(<span class="string">&quot;README.txt&quot;</span>);        <span class="comment">// returns true</span>
 rx<span class="operator">.</span>exactMatch(<span class="string">&quot;welcome.txt.bak&quot;</span>);   <span class="comment">// returns false</span>
</pre>
<span id="perl-users"></span><h3 id="notes-for-perl-users">Notes for Perl Users</h3>
<p>Most of the character class abbreviations supported by Perl are supported by QRegExp, see <a href="qregexp.html#characters-and-abbreviations-for-sets-of-characters" translate="no">characters and abbreviations for sets of characters</a>.</p>
<p>In QRegExp, apart from within character classes, <code translate="no">^</code> always signifies the start of the string, so carets must always be escaped unless used for that purpose. In Perl the meaning of caret varies automagically depending on where it occurs so escaping it is rarely necessary. The same applies to <code translate="no">$</code> which in QRegExp always signifies the end of the string.</p>
<p>QRegExp's quantifiers are the same as Perl's greedy quantifiers (but see the <a href="qregexp.html#greedy-quantifiers" translate="no">note above</a>). Non-greedy matching cannot be applied to individual quantifiers, but can be applied to all the quantifiers in the pattern. For example, to match the Perl regexp <b>ro+?m</b> requires:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> rx(<span class="string">&quot;ro+m&quot;</span>);
 rx<span class="operator">.</span>setMinimal(<span class="keyword">true</span>);
</pre>
<p>The equivalent of Perl's <code translate="no">/i</code> option is <a href="qregexp.html#setCaseSensitivity" translate="no">setCaseSensitivity</a>(<a href="../qtcore/qt.html#CaseSensitivity-enum" translate="no">Qt::CaseInsensitive</a>).</p>
<p>Perl's <code translate="no">/g</code> option can be emulated using a <a href="qregexp.html#cap-in-a-loop" translate="no">loop</a>.</p>
<p>In QRegExp <b>.</b> matches any character, therefore all QRegExp regexps have the equivalent of Perl's <code translate="no">/s</code> option. QRegExp does not have an equivalent to Perl's <code translate="no">/m</code> option, but this can be emulated in various ways for example by splitting the input into lines or by looping with a regexp that searches for newlines.</p>
<p>Because QRegExp is string oriented, there are no \A, \Z, or \z assertions. The \G assertion is not supported but can be emulated in a loop.</p>
<p>Perl's $&amp; is cap(0) or <a href="qregexp.html#capturedTexts" translate="no">capturedTexts</a>()[0]. There are no QRegExp equivalents for $`, $' or $+. Perl's capturing variables, $1, $2, ..&#x2e; correspond to cap(1) or <a href="qregexp.html#capturedTexts" translate="no">capturedTexts</a>()[1], cap(2) or <a href="qregexp.html#capturedTexts" translate="no">capturedTexts</a>()[2], etc.</p>
<p>To substitute a pattern use <a href="../qtcore/qstring.html#replace" translate="no">QString::replace</a>().</p>
<p>Perl's extended <code translate="no">/x</code> syntax is not supported, nor are directives, e.g&#x2e; (?i), or regexp comments, e.g&#x2e; (?#comment). On the other hand, C++'s rules for literal strings can be used to achieve the same:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> mark(<span class="string">&quot;\\b&quot;</span>      <span class="comment">// word boundary</span>
               <span class="string">&quot;[Mm]ark&quot;</span> <span class="comment">// the word we want to match</span>
             );
</pre>
<p>Both zero-width positive and zero-width negative lookahead assertions (?=pattern) and (?!pattern) are supported with the same syntax as Perl. Perl's lookbehind assertions, &quot;independent&quot; subexpressions and conditional expressions are not supported.</p>
<p>Non-capturing parentheses are also supported, with the same (?:pattern) syntax.</p>
<p>See <a href="../qtcore/qstring.html#split" translate="no">QString::split</a>() and <a href="../qtcore/qstringlist.html#join" translate="no">QStringList::join</a>() for equivalents to Perl's split and join functions.</p>
<p>Note: because C++ transforms \'s they must be written <i>twice</i> in code, e.g&#x2e; <b>\b</b> must be written <b>\\b</b>.</p>
<span id="code-examples"></span><h3 id="code-examples">Code Examples</h3>
<pre class="cpp" translate="no">
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> rx(<span class="string">&quot;^\\d\\d?$&quot;</span>);    <span class="comment">// match integers 0 to 99</span>
 rx<span class="operator">.</span>indexIn(<span class="string">&quot;123&quot;</span>);          <span class="comment">// returns -1 (no match)</span>
 rx<span class="operator">.</span>indexIn(<span class="string">&quot;-6&quot;</span>);           <span class="comment">// returns -1 (no match)</span>
 rx<span class="operator">.</span>indexIn(<span class="string">&quot;6&quot;</span>);            <span class="comment">// returns 0 (matched at position 0)</span>
</pre>
<p>The third string matches '<u>6</u>'. This is a simple validation regexp for integers in the range 0 to 99.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> rx(<span class="string">&quot;^\\S+$&quot;</span>);       <span class="comment">// match strings without whitespace</span>
 rx<span class="operator">.</span>indexIn(<span class="string">&quot;Hello world&quot;</span>);  <span class="comment">// returns -1 (no match)</span>
 rx<span class="operator">.</span>indexIn(<span class="string">&quot;This_is-OK&quot;</span>);   <span class="comment">// returns 0 (matched at position 0)</span>
</pre>
<p>The second string matches '<u>This_is-OK</u>'. We've used the character set abbreviation '\S' (non-whitespace) and the anchors to match strings which contain no whitespace.</p>
<p>In the following example we match strings containing 'mail' or 'letter' or 'correspondence' but only match whole words i.e&#x2e; not 'email'</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> rx(<span class="string">&quot;\\b(mail|letter|correspondence)\\b&quot;</span>);
 rx<span class="operator">.</span>indexIn(<span class="string">&quot;I sent you an email&quot;</span>);     <span class="comment">// returns -1 (no match)</span>
 rx<span class="operator">.</span>indexIn(<span class="string">&quot;Please write the letter&quot;</span>); <span class="comment">// returns 17</span>
</pre>
<p>The second string matches &quot;Please write the <u>letter</u>&quot;. The word 'letter' is also captured (because of the parentheses). We can see what text we've captured like this:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> captured <span class="operator">=</span> rx<span class="operator">.</span>cap(<span class="number">1</span>); <span class="comment">// captured == &quot;letter&quot;</span>
</pre>
<p>This will capture the text from the first set of capturing parentheses (counting capturing left parentheses from left to right). The parentheses are counted from 1 since cap(0) is the whole matched regexp (equivalent to '&amp;' in most regexp engines).</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> rx(<span class="string">&quot;&amp;(?!amp;)&quot;</span>);      <span class="comment">// match ampersands but not &amp;amp;</span>
 <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> line1 <span class="operator">=</span> <span class="string">&quot;This &amp; that&quot;</span>;
 line1<span class="operator">.</span>replace(rx<span class="operator">,</span> <span class="string">&quot;&amp;amp;&quot;</span>);
 <span class="comment">// line1 == &quot;This &amp;amp; that&quot;</span>
 <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> line2 <span class="operator">=</span> <span class="string">&quot;His &amp;amp; hers &amp; theirs&quot;</span>;
 line2<span class="operator">.</span>replace(rx<span class="operator">,</span> <span class="string">&quot;&amp;amp;&quot;</span>);
 <span class="comment">// line2 == &quot;His &amp;amp; hers &amp;amp; theirs&quot;</span>
</pre>
<p>Here we've passed the QRegExp to <a href="../qtcore/qstring.html" translate="no">QString</a>'s replace() function to replace the matched text with new text.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;One Eric another Eirik, and an Ericsson. &quot;</span>
               <span class="string">&quot;How many Eiriks, Eric?&quot;</span>;
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> rx(<span class="string">&quot;\\b(Eric|Eirik)\\b&quot;</span>); <span class="comment">// match Eric or Eirik</span>
 <span class="type">int</span> pos <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// where we are in the string</span>
 <span class="type">int</span> count <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// how many Eric and Eirik's we've counted</span>
 <span class="keyword">while</span> (pos <span class="operator">&gt;</span><span class="operator">=</span> <span class="number">0</span>) {
     pos <span class="operator">=</span> rx<span class="operator">.</span>indexIn(str<span class="operator">,</span> pos);
     <span class="keyword">if</span> (pos <span class="operator">&gt;</span><span class="operator">=</span> <span class="number">0</span>) {
         <span class="operator">+</span><span class="operator">+</span>pos;      <span class="comment">// move along in str</span>
         <span class="operator">+</span><span class="operator">+</span>count;    <span class="comment">// count our Eric or Eirik</span>
     }
 }
</pre>
<p>We've used the <a href="qregexp.html#indexIn" translate="no">indexIn</a>() function to repeatedly match the regexp in the string. Note that instead of moving forward by one character at a time <code translate="no">pos++</code> we could have written <code translate="no">pos += rx.matchedLength()</code> to skip over the already matched string. The count will equal 3, matching 'One <u>Eric</u> another <u>Eirik</u>, and an Ericsson. How many Eiriks, <u>Eric</u>?'; it doesn't match 'Ericsson' or 'Eiriks' because they are not bounded by non-word boundaries.</p>
<p>One common use of regexps is to split lines of delimited data into their component fields.</p>
<pre class="cpp" translate="no">
 str <span class="operator">=</span> <span class="string">&quot;The Qt Company Ltd\tqt.io\tFinland&quot;</span>;
 <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> company<span class="operator">,</span> web<span class="operator">,</span> country;
 rx<span class="operator">.</span>setPattern(<span class="string">&quot;^([^\t]+)\t([^\t]+)\t([^\t]+)$&quot;</span>);
 <span class="keyword">if</span> (rx<span class="operator">.</span>indexIn(str) <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) {
     company <span class="operator">=</span> rx<span class="operator">.</span>cap(<span class="number">1</span>);
     web <span class="operator">=</span> rx<span class="operator">.</span>cap(<span class="number">2</span>);
     country <span class="operator">=</span> rx<span class="operator">.</span>cap(<span class="number">3</span>);
 }
</pre>
<p>In this example our input lines have the format company name, web address and country. Unfortunately the regexp is rather long and not very versatile &ndash; the code will break if we add any more fields. A simpler and better solution is to look for the separator, '\t' in this case, and take the surrounding text. The <a href="../qtcore/qstring.html#split" translate="no">QString::split</a>() function can take a separator string or regexp as an argument and split a string accordingly.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> field <span class="operator">=</span> str<span class="operator">.</span>split(<span class="string">&quot;\t&quot;</span>);
</pre>
<p>Here field[0] is the company, field[1] the web address and so on.</p>
<p>To imitate the matching of a shell we can use wildcard mode.</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> rx(<span class="string">&quot;*.html&quot;</span>);
 rx<span class="operator">.</span>setPatternSyntax(<span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span><span class="operator">::</span>Wildcard);
 rx<span class="operator">.</span>exactMatch(<span class="string">&quot;index.html&quot;</span>);                <span class="comment">// returns true</span>
 rx<span class="operator">.</span>exactMatch(<span class="string">&quot;default.htm&quot;</span>);               <span class="comment">// returns false</span>
 rx<span class="operator">.</span>exactMatch(<span class="string">&quot;readme.txt&quot;</span>);                <span class="comment">// returns false</span>
</pre>
<p>Wildcard matching can be convenient because of its simplicity, but any wildcard regexp can be defined using full regexps, e.g&#x2e; <b>.*\.html$</b>. Notice that we can't match both <code translate="no">.html</code> and <code translate="no">.htm</code> files with a wildcard unless we use <b>*.htm*</b> which will also match 'test.html.bak'. A full regexp gives us the precision we need, <b>.*\.html?$</b>.</p>
<p>QRegExp can match case insensitively using <a href="qregexp.html#setCaseSensitivity" translate="no">setCaseSensitivity</a>(), and can use non-greedy matching, see <a href="qregexp.html#setMinimal" translate="no">setMinimal</a>(). By default QRegExp uses full regexps but this can be changed with <a href="qregexp.html#setPatternSyntax" translate="no">setPatternSyntax</a>(). Searching can be done forward with <a href="qregexp.html#indexIn" translate="no">indexIn</a>() or backward with <a href="qregexp.html#lastIndexIn" translate="no">lastIndexIn</a>(). Captured text can be accessed using <a href="qregexp.html#capturedTexts" translate="no">capturedTexts</a>() which returns a string list of all captured strings, or using <a href="qregexp.html#cap" translate="no">cap</a>() which returns the captured string for the given index. The <a href="qregexp.html#pos" translate="no">pos</a>() function takes a match index and returns the position in the string where the match was made (or -1 if there was no match).</p>
<h3 id="porting-to-qregularexpression">Porting to QRegularExpression</h3>
<p>The <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a> class introduced in Qt 5 implements Perl-compatible regular expressions and is a big improvement upon QRegExp in terms of APIs offered, supported pattern syntax, and speed of execution. The biggest difference is that <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a> simply holds a regular expression, and it's <i>not</i> modified when a match is requested. Instead, a <a href="../qtcore/qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a> object is returned, to check the result of a match and extract the captured substring. The same applies to global matching and <a href="../qtcore/qregularexpressionmatchiterator.html" translate="no">QRegularExpressionMatchIterator</a>.</p>
<p>Other differences are outlined below.</p>
<div class="admonition note">
<p><b>Note: </b><a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a> does not support all the features available in Perl-compatible regular expressions. The most notable one is the fact that duplicated names for capturing groups are not supported, and using them can lead to undefined behavior. This may change in a future version of Qt.</p>
</div>
<h5 id="different-pattern-syntax">Different pattern syntax</h5>
<p>Porting a regular expression from QRegExp to <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a> may require changes to the pattern itself.</p>
<p>In specific scenarios, QRegExp was too lenient and accepted patterns that are simply invalid when using <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a>. These are easy to detect, because the <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a> objects built with these patterns are not valid (see <a href="../qtcore/qregularexpression.html#isValid" translate="no">QRegularExpression::isValid</a>()).</p>
<p>In other cases, a pattern ported from QRegExp to <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a> may silently change semantics. Therefore, it is necessary to review the patterns used. The most notable cases of silent incompatibility are:</p>
<ul>
<li>Curly braces are needed to use a hexadecimal escape like <code translate="no">\xHHHH</code> with more than 2 digits. A pattern like <code translate="no">\x2022</code> needs to be ported to <code translate="no">\x{2022}</code>, or it will match a space (<code translate="no">0x20</code>) followed by the string <code translate="no">&quot;22&quot;</code>. In general, it is highly recommended to always use curly braces with the <code translate="no">\x</code> escape, no matter the number of digits specified.</li>
<li>A 0-to-n quantification like <code translate="no">{,n}</code> needs to be ported to <code translate="no">{0,n}</code> to preserve semantics. Otherwise, a pattern such as <code translate="no">\d{,3}</code> would match a digit followed by the exact string <code translate="no">&quot;{,3}&quot;</code>.</li>
<li>QRegExp by default does Unicode-aware matching, while <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a> requires a separate option; see below for more details.</li>
<li>c{.} in QRegExp does by default match all characters, including the newline character. <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a> excludes the newline character by default. To include the newline character, set the <a href="../qtcore/qregularexpression.html#PatternOption-enum" translate="no">QRegularExpression::DotMatchesEverythingOption</a> pattern option.</li>
</ul>
<p>For an overview of the regular expression syntax supported by <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a>, please refer to the <a href="https://pcre.org/original/doc/html/pcrepattern.html" translate="no">pcrepattern(3)</a> man page, describing the pattern syntax supported by PCRE (the reference implementation of Perl-compatible regular expressions).</p>
<h5 id="porting-from-qregexp-exactmatch">Porting from QRegExp::exactMatch()</h5>
<p><a href="qregexp.html#exactMatch" translate="no">QRegExp::exactMatch</a>() served two purposes: it exactly matched a regular expression against a subject string, and it implemented partial matching.</p>
<h6 id="porting-from-qregexp-s-exact-matching">Porting from QRegExp's Exact Matching</h6>
<p>Exact matching indicates whether the regular expression matches the entire subject string. For example, the classes yield on the subject string <code translate="no">&quot;abc123&quot;</code>:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th ></th><th ><a href="qregexp.html#exactMatch" translate="no">QRegExp::exactMatch</a>()</th><th ><a href="../qtcore/qregularexpressionmatch.html#hasMatch" translate="no">QRegularExpressionMatch::hasMatch</a>()</th></tr></thead>
<tr valign="top" class="odd"><td ><code translate="no">&quot;\\d+&quot;</code></td><td ><b>false</b></td><td ><b>true</b></td></tr>
<tr valign="top" class="even"><td ><code translate="no">&quot;[a-z]+\\d+&quot;</code></td><td ><b>true</b></td><td ><b>true</b></td></tr>
</table></div>
<p>Exact matching is not reflected in <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a>. If you want to be sure that the subject string matches the regular expression exactly, you can wrap the pattern using the <a href="../qtcore/qregularexpression.html#anchoredPattern" translate="no">QRegularExpression::anchoredPattern</a>() function:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> p(<span class="string">&quot;a .*|pattern&quot;</span>);

 <span class="comment">// re matches exactly the pattern string p</span>
 <span class="type"><a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a></span> re(<span class="type"><a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a></span><span class="operator">::</span>anchoredPattern(p));
</pre>
<h6 id="porting-from-qregexp-s-partial-matching">Porting from QRegExp's Partial Matching</h6>
<p>When using <a href="qregexp.html#exactMatch" translate="no">QRegExp::exactMatch</a>(), if an exact match was not found, one could still find out how much of the subject string was matched by the regular expression by calling <a href="qregexp.html#matchedLength" translate="no">QRegExp::matchedLength</a>(). If the returned length was equal to the subject string's length, then one could conclude that a partial match was found.</p>
<p><a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a> supports partial matching explicitly by means of the appropriate <a href="../qtcore/qregularexpression.html#MatchType-enum" translate="no">QRegularExpression::MatchType</a>.</p>
<h5 id="global-matching">Global matching</h5>
<p>Due to limitations of the QRegExp API, it was impossible to implement global matching correctly (that is, like Perl does). In particular, patterns that can match 0 characters (like <code translate="no">&quot;a*&quot;</code>) are problematic.</p>
<p><a href="../qtcore/qregularexpression.html#globalMatch" translate="no">QRegularExpression::globalMatch</a>() implements Perl global match correctly, and the returned iterator can be used to examine each result.</p>
<p>For example, if you have code like:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> subject(<span class="string">&quot;the quick fox&quot;</span>);

 <span class="type">int</span> offset <span class="operator">=</span> <span class="number">0</span>;
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> re(<span class="string">&quot;(\\w+)&quot;</span>);
 <span class="keyword">while</span> ((offset <span class="operator">=</span> re<span class="operator">.</span>indexIn(subject<span class="operator">,</span> offset)) <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) {
     offset <span class="operator">+</span><span class="operator">=</span> re<span class="operator">.</span>matchedLength();
     <span class="comment">// ...</span>
 }
</pre>
<p>You can rewrite it as:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> subject(<span class="string">&quot;the quick fox&quot;</span>);

 <span class="type"><a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a></span> re(<span class="string">&quot;(\\w+)&quot;</span>);
 <span class="type"><a href="../qtcore/qregularexpressionmatchiterator.html" translate="no">QRegularExpressionMatchIterator</a></span> i <span class="operator">=</span> re<span class="operator">.</span>globalMatch(subject);
 <span class="keyword">while</span> (i<span class="operator">.</span>hasNext()) {
     <span class="type"><a href="../qtcore/qregularexpressionmatch.html" translate="no">QRegularExpressionMatch</a></span> match <span class="operator">=</span> i<span class="operator">.</span>next();
     <span class="comment">// ...</span>
 }
</pre>
<h5 id="unicode-properties-support">Unicode properties support</h5>
<p>When using QRegExp, character classes such as <code translate="no">\w</code>, <code translate="no">\d</code>, etc. match characters with the corresponding Unicode property: for instance, <code translate="no">\d</code> matches any character with the Unicode <code translate="no">Nd</code> (decimal digit) property.</p>
<p>Those character classes only match ASCII characters by default when using <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a>: for instance, <code translate="no">\d</code> matches exactly a character in the <code translate="no">0-9</code> ASCII range. It is possible to change this behavior by using the <a href="../qtcore/qregularexpression.html#PatternOption-enum" translate="no">QRegularExpression::UseUnicodePropertiesOption</a> pattern option.</p>
<h5 id="wildcard-matching">Wildcard matching</h5>
<p>There is no direct way to do wildcard matching in <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a>. However, the <a href="../qtcore/qregularexpression.html#wildcardToRegularExpression" translate="no">QRegularExpression::wildcardToRegularExpression</a>() method is provided to translate glob patterns into a Perl-compatible regular expression that can be used for that purpose.</p>
<p>For example, if you have code like:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> wildcard(<span class="string">&quot;*.txt&quot;</span>);
 wildcard<span class="operator">.</span>setPatternSyntax(<span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span><span class="operator">::</span>Wildcard);
</pre>
<p>You can rewrite it as:</p>
<pre class="cpp" translate="no">
 <span class="keyword">auto</span> wildcard <span class="operator">=</span> <span class="type"><a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a></span>(<span class="type"><a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a></span><span class="operator">::</span>wildcardToRegularExpression(<span class="string">&quot;*.txt&quot;</span>));
</pre>
<p>Please note though that some shell-like wildcard patterns might not be translated to what you expect. The following example code will silently break if simply converted using the above-mentioned function:</p>
<pre class="cpp" translate="no">
 <span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> fp1(<span class="string">&quot;C:/Users/dummy/files/content.txt&quot;</span>);
 <span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> fp2(<span class="string">&quot;/home/dummy/files/content.txt&quot;</span>);

 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> re1(<span class="string">&quot;*/files/*&quot;</span>);
 re1<span class="operator">.</span>setPatternSyntax(<span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span><span class="operator">::</span>Wildcard);
 re1<span class="operator">.</span>exactMatch(fp1); <span class="comment">// returns true</span>
 re1<span class="operator">.</span>exactMatch(fp2); <span class="comment">// returns true</span>

 <span class="comment">// but converted with QRegularExpression::wildcardToRegularExpression()</span>

 <span class="type"><a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a></span> re2(<span class="type"><a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a></span><span class="operator">::</span>wildcardToRegularExpression(<span class="string">&quot;*/files/*&quot;</span>));
 re2<span class="operator">.</span>match(fp1)<span class="operator">.</span>hasMatch(); <span class="comment">// returns false</span>
 re2<span class="operator">.</span>match(fp2)<span class="operator">.</span>hasMatch(); <span class="comment">// returns false</span>
</pre>
<p>This is because, by default, the regular expression returned by <a href="../qtcore/qregularexpression.html#wildcardToRegularExpression" translate="no">QRegularExpression::wildcardToRegularExpression</a>() is fully anchored. To get a regular expression that is not anchored, pass <a href="../qtcore/qregularexpression.html#WildcardConversionOption-enum" translate="no">QRegularExpression::UnanchoredWildcardConversion</a> as the conversion options:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a></span> re3(<span class="type"><a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a></span><span class="operator">::</span>wildcardToRegularExpression(
                            <span class="string">&quot;*/files/*&quot;</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a></span><span class="operator">::</span>UnanchoredWildcardConversion));
 re3<span class="operator">.</span>match(fp1)<span class="operator">.</span>hasMatch(); <span class="comment">// returns true</span>
 re3<span class="operator">.</span>match(fp2)<span class="operator">.</span>hasMatch(); <span class="comment">// returns true</span>
</pre>
<h5 id="minimal-matching">Minimal matching</h5>
<p><a href="qregexp.html#setMinimal" translate="no">QRegExp::setMinimal</a>() implemented minimal matching by simply reversing the greediness of the quantifiers (QRegExp did not support lazy quantifiers, like <code translate="no">*?</code>, <code translate="no">+?</code>, etc.)&#x2e; <a href="../qtcore/qregularexpression.html" translate="no">QRegularExpression</a> instead does support greedy, lazy, and possessive quantifiers. The <a href="../qtcore/qregularexpression.html#PatternOption-enum" translate="no">QRegularExpression::InvertedGreedinessOption</a> pattern option can be useful to emulate the effects of <a href="qregexp.html#setMinimal" translate="no">QRegExp::setMinimal</a>(): if enabled, it inverts the greediness of quantifiers (greedy ones become lazy and vice versa).</p>
<h5 id="caret-modes">Caret modes</h5>
<p>The <a href="../qtcore/qregularexpression.html#MatchOption-enum" translate="no">QRegularExpression::AnchorAtOffsetMatchOption</a> match option can be used to emulate the <a href="qregexp.html#CaretMode-enum" translate="no">QRegExp::CaretAtOffset</a> behavior. There is no equivalent for the other <a href="qregexp.html#CaretMode-enum" translate="no">QRegExp::CaretMode</a> modes.</p>
</div>
<p><b>See also </b><a href="../qtcore/qstring.html" translate="no">QString</a>, <a href="../qtcore/qstringlist.html" translate="no">QStringList</a>, and <a href="../qtcore/qsortfilterproxymodel.html" translate="no">QSortFilterProxyModel</a>.</p>
<!-- @@@QRegExp -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$CaretMode$$$CaretAtZero$$$CaretAtOffset$$$CaretWontMatch -->
<h3 class="fn" translate="no" id="CaretMode-enum">enum QRegExp::<span class="name">CaretMode</span></h3>
<p>The CaretMode enum defines the different meanings of the caret (<b>^</b>) in a regular expression. The possible values are:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRegExp::CaretAtZero</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The caret corresponds to index 0 in the searched string.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegExp::CaretAtOffset</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The caret corresponds to the start offset of the search.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegExp::CaretWontMatch</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The caret never matches.</td></tr>
</table></div>
<!-- @@@CaretMode -->
<!-- $$$PatternSyntax$$$RegExp$$$Wildcard$$$FixedString$$$RegExp2$$$WildcardUnix$$$W3CXmlSchema11 -->
<h3 class="fn" translate="no" id="PatternSyntax-enum">enum QRegExp::<span class="name">PatternSyntax</span></h3>
<p>The syntax used to interpret the meaning of the pattern.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRegExp::RegExp</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">A rich Perl-like pattern matching syntax. This is the default.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegExp::RegExp2</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">Like RegExp, but with <a href="qregexp.html#greedy-quantifiers" translate="no">greedy quantifiers</a>. (Introduced in Qt 4.2&#x2e;)</td></tr>
<tr><td class="topAlign"><code translate="no">QRegExp::Wildcard</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">This provides a simple pattern matching syntax similar to that used by shells (command interpreters) for &quot;file globbing&quot;. See <a href="qregexp.html#qregexp-wildcard-matching" translate="no">QRegExp wildcard matching</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegExp::WildcardUnix</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">This is similar to Wildcard but with the behavior of a Unix shell. The wildcard characters can be escaped with the character &quot;\&quot;.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegExp::FixedString</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The pattern is a fixed string. This is equivalent to using the RegExp pattern on a string in which all metacharacters are escaped using <a href="qregexp.html#escape" translate="no">escape</a>().</td></tr>
<tr><td class="topAlign"><code translate="no">QRegExp::W3CXmlSchema11</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">The pattern is a regular expression as defined by the W3C XML Schema 1.1 specification.</td></tr>
</table></div>
<p><b>See also </b><a href="qregexp.html#setPatternSyntax" translate="no">setPatternSyntax</a>().</p>
<!-- @@@PatternSyntax -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QRegExp[overload1]$$$QRegExp -->
<h3 class="fn" translate="no" id="QRegExp">QRegExp::<span class="name">QRegExp</span>()</h3>
<p>Constructs an empty regexp.</p>
<p><b>See also </b><a href="qregexp.html#isValid" translate="no">isValid</a>() and <a href="qregexp.html#errorString" translate="no">errorString</a>().</p>
<!-- @@@QRegExp -->
<!-- $$$QRegExp$$$QRegExpconstQString&Qt::CaseSensitivityPatternSyntax -->
<h3 class="fn" translate="no" id="QRegExp-1"><code translate="no">[explicit] </code>QRegExp::<span class="name">QRegExp</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>pattern</i>, <span class="type"><a href="../qtcore/qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive, <span class="type"><a href="qregexp.html#PatternSyntax-enum" translate="no">PatternSyntax</a></span> <i>syntax</i> = RegExp)</h3>
<p>Constructs a regular expression object for the given <i translate="no">pattern</i> string. The pattern must be given using wildcard notation if <i translate="no">syntax</i> is <a href="qregexp.html#PatternSyntax-enum" translate="no">Wildcard</a>; the default is <a href="qregexp.html#PatternSyntax-enum" translate="no">RegExp</a>. The pattern is case sensitive, unless <i translate="no">cs</i> is <a href="../qtcore/qt.html#CaseSensitivity-enum" translate="no">Qt::CaseInsensitive</a>. Matching is greedy (maximal), but can be changed by calling <a href="qregexp.html#setMinimal" translate="no">setMinimal</a>().</p>
<p><b>See also </b><a href="qregexp.html#setPattern" translate="no">setPattern</a>(), <a href="qregexp.html#setCaseSensitivity" translate="no">setCaseSensitivity</a>(), and <a href="qregexp.html#setPatternSyntax" translate="no">setPatternSyntax</a>().</p>
<!-- @@@QRegExp -->
<!-- $$$QRegExp$$$QRegExpconstQRegExp& -->
<h3 class="fn" translate="no" id="QRegExp-2">QRegExp::<span class="name">QRegExp</span>(const <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> &amp;<i>rx</i>)</h3>
<p>Constructs a regular expression as a copy of <i translate="no">rx</i>.</p>
<p><b>See also </b><a href="qregexp.html#operator-eq" translate="no">operator=</a>().</p>
<!-- @@@QRegExp -->
<!-- $$$~QRegExp[overload1]$$$~QRegExp -->
<h3 class="fn" translate="no" id="dtor.QRegExp"><code translate="no">[noexcept] </code>QRegExp::<span class="name">~QRegExp</span>()</h3>
<p>Destroys the regular expression and cleans up its internal data.</p>
<!-- @@@~QRegExp -->
<!-- $$$cap[overload1]$$$capint -->
<h3 class="fn" translate="no" id="cap"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QRegExp::<span class="name">cap</span>(<span class="type">int</span> <i>nth</i> = 0) const</h3>
<p>Returns the text captured by the <i translate="no">nth</i> subexpression. The entire match has index 0 and the parenthesized subexpressions have indexes starting from 1 (excluding non-capturing parentheses).</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> rxlen(<span class="string">&quot;(\\d+)(?:\\s*)(cm|inch)&quot;</span>);
 <span class="type">int</span> pos <span class="operator">=</span> rxlen<span class="operator">.</span>indexIn(<span class="string">&quot;Length: 189cm&quot;</span>);
 <span class="keyword">if</span> (pos <span class="operator">&gt;</span> <span class="operator">-</span><span class="number">1</span>) {
     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> value <span class="operator">=</span> rxlen<span class="operator">.</span>cap(<span class="number">1</span>); <span class="comment">// &quot;189&quot;</span>
     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> unit <span class="operator">=</span> rxlen<span class="operator">.</span>cap(<span class="number">2</span>);  <span class="comment">// &quot;cm&quot;</span>
     <span class="comment">// ...</span>
 }
</pre>
<p>The order of elements matched by cap() is as follows. The first element, cap(0), is the entire matching string. Each subsequent element corresponds to the next capturing open left parentheses. Thus cap(1) is the text of the first capturing parentheses, cap(2) is the text of the second, and so on.</p>
<p><b>See also </b><a href="qregexp.html#capturedTexts" translate="no">capturedTexts</a>() and <a href="qregexp.html#pos" translate="no">pos</a>().</p>
<!-- @@@cap -->
<!-- $$$captureCount[overload1]$$$captureCount -->
<h3 class="fn" translate="no" id="captureCount"><span class="type">int</span> QRegExp::<span class="name">captureCount</span>() const</h3>
<p>Returns the number of captures contained in the regular expression.</p>
<!-- @@@captureCount -->
<!-- $$$capturedTexts[overload1]$$$capturedTexts -->
<h3 class="fn" translate="no" id="capturedTexts"><span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> QRegExp::<span class="name">capturedTexts</span>() const</h3>
<p>Returns a list of the captured text strings.</p>
<p>The first string in the list is the entire matched string. Each subsequent list element contains a string that matched a (capturing) subexpression of the regexp.</p>
<p>For example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> rx(<span class="string">&quot;(\\d+)(\\s*)(cm|inch(es)?)&quot;</span>);
 <span class="type">int</span> pos <span class="operator">=</span> rx<span class="operator">.</span>indexIn(<span class="string">&quot;Length: 36 inches&quot;</span>);
 <span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> list <span class="operator">=</span> rx<span class="operator">.</span>capturedTexts();
 <span class="comment">// list is now (&quot;36 inches&quot;, &quot;36&quot;, &quot; &quot;, &quot;inches&quot;, &quot;es&quot;)</span>
</pre>
<p>The above example also captures elements that may be present but which we have no interest in. This problem can be solved by using non-capturing parentheses:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> rx(<span class="string">&quot;(\\d+)(?:\\s*)(cm|inch(?:es)?)&quot;</span>);
 <span class="type">int</span> pos <span class="operator">=</span> rx<span class="operator">.</span>indexIn(<span class="string">&quot;Length: 36 inches&quot;</span>);
 <span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> list <span class="operator">=</span> rx<span class="operator">.</span>capturedTexts();
 <span class="comment">// list is now (&quot;36 inches&quot;, &quot;36&quot;, &quot;inches&quot;)</span>
</pre>
<p>Note that if you want to iterate over the list, you should iterate over a copy, e.g&#x2e;</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> list <span class="operator">=</span> rx<span class="operator">.</span>capturedTexts();
 <span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span><span class="operator">::</span>iterator it <span class="operator">=</span> list<span class="operator">.</span>begin();
 <span class="keyword">while</span> (it <span class="operator">!</span><span class="operator">=</span> list<span class="operator">.</span>end()) {
     myProcessing(<span class="operator">*</span>it);
     <span class="operator">+</span><span class="operator">+</span>it;
 }
</pre>
<p>Some regexps can match an indeterminate number of times. For example if the input string is &quot;Offsets: 12 14 99 231 7&quot; and the regexp, <code translate="no">rx</code>, is <b>(\d+)+</b>, we would hope to get a list of all the numbers matched. However, after calling <code translate="no">rx.indexIn(str)</code>, capturedTexts() will return the list (&quot;12&quot;, &quot;12&quot;), i.e&#x2e; the entire match was &quot;12&quot; and the first subexpression matched was &quot;12&quot;. The correct approach is to use <a href="qregexp.html#cap" translate="no">cap</a>() in a <a href="qregexp.html#cap-in-a-loop" translate="no">loop</a>.</p>
<p>The order of elements in the string list is as follows. The first element is the entire matching string. Each subsequent element corresponds to the next capturing open left parentheses. Thus capturedTexts()[1] is the text of the first capturing parentheses, capturedTexts()[2] is the text of the second and so on (corresponding to $1, $2, etc., in some other regexp languages).</p>
<p><b>See also </b><a href="qregexp.html#cap" translate="no">cap</a>() and <a href="qregexp.html#pos" translate="no">pos</a>().</p>
<!-- @@@capturedTexts -->
<!-- $$$caseSensitivity[overload1]$$$caseSensitivity -->
<h3 class="fn" translate="no" id="caseSensitivity"><span class="type"><a href="../qtcore/qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> QRegExp::<span class="name">caseSensitivity</span>() const</h3>
<p>Returns <a href="../qtcore/qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a> if the regexp is matched case sensitively; otherwise returns <a href="../qtcore/qt.html#CaseSensitivity-enum" translate="no">Qt::CaseInsensitive</a>.</p>
<p><b>See also </b><a href="qregexp.html#setCaseSensitivity" translate="no">setCaseSensitivity</a>(), <a href="qregexp.html#patternSyntax" translate="no">patternSyntax</a>(), <a href="qregexp.html#pattern" translate="no">pattern</a>(), and <a href="qregexp.html#isMinimal" translate="no">isMinimal</a>().</p>
<!-- @@@caseSensitivity -->
<!-- $$$countIn[overload1]$$$countInconstQString& -->
<h3 class="fn" translate="no" id="countIn"><span class="type">int</span> QRegExp::<span class="name">countIn</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>str</i>) const</h3>
<p>Returns the number of times this regular expression matches in <i translate="no">str</i>.</p>
<p><b>See also </b><a href="qregexp.html#indexIn" translate="no">indexIn</a>(), <a href="qregexp.html#lastIndexIn" translate="no">lastIndexIn</a>(), and <a href="qregexp.html#replaceIn" translate="no">replaceIn</a>().</p>
<!-- @@@countIn -->
<!-- $$$errorString[overload1]$$$errorString -->
<h3 class="fn" translate="no" id="errorString"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QRegExp::<span class="name">errorString</span>() const</h3>
<p>Returns a text string that explains why a regexp pattern is invalid the case being; otherwise returns &quot;no error occurred&quot;.</p>
<p><b>See also </b><a href="qregexp.html#isValid" translate="no">isValid</a>().</p>
<!-- @@@errorString -->
<!-- $$$escape[overload1]$$$escapeconstQString& -->
<h3 class="fn" translate="no" id="escape"><code translate="no">[static] </code><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QRegExp::<span class="name">escape</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>str</i>)</h3>
<p>Returns the string <i translate="no">str</i> with every regexp special character escaped with a backslash. The special characters are $, (,), *, +, ., ?, [, ,], ^, {, | and }.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 s1 <span class="operator">=</span> <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span><span class="operator">::</span>escape(<span class="string">&quot;bingo&quot;</span>);   <span class="comment">// s1 == &quot;bingo&quot;</span>
 s2 <span class="operator">=</span> <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span><span class="operator">::</span>escape(<span class="string">&quot;f(x)&quot;</span>);    <span class="comment">// s2 == &quot;f\\(x\\)&quot;</span>
</pre>
<p>This function is useful to construct regexp patterns dynamically:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> rx(<span class="string">&quot;(&quot;</span> <span class="operator">+</span> <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span><span class="operator">::</span>escape(name) <span class="operator">+</span>
            <span class="string">&quot;|&quot;</span> <span class="operator">+</span> <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span><span class="operator">::</span>escape(alias) <span class="operator">+</span> <span class="string">&quot;)&quot;</span>);
</pre>
<p><b>See also </b><a href="qregexp.html#setPatternSyntax" translate="no">setPatternSyntax</a>().</p>
<!-- @@@escape -->
<!-- $$$exactMatch[overload1]$$$exactMatchconstQString& -->
<h3 class="fn" translate="no" id="exactMatch"><span class="type">bool</span> QRegExp::<span class="name">exactMatch</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>str</i>) const</h3>
<p>Returns <code translate="no">true</code> if <i translate="no">str</i> is matched exactly by this regular expression; otherwise returns <code translate="no">false</code>. You can determine how much of the string was matched by calling <a href="qregexp.html#matchedLength" translate="no">matchedLength</a>().</p>
<p>For a given regexp string R, exactMatch(&quot;R&quot;) is the equivalent of <a href="qregexp.html#indexIn" translate="no">indexIn</a>(&quot;^R$&quot;) since exactMatch() effectively encloses the regexp in the start of string and end of string anchors, except that it sets <a href="qregexp.html#matchedLength" translate="no">matchedLength</a>() differently.</p>
<p>For example, if the regular expression is <b>blue</b>, then exactMatch() returns <code translate="no">true</code> only for input <code translate="no">blue</code>. For inputs <code translate="no">bluebell</code>, <code translate="no">blutak</code> and <code translate="no">lightblue</code>, exactMatch() returns <code translate="no">false</code> and <a href="qregexp.html#matchedLength" translate="no">matchedLength</a>() will return 4, 3 and 0 respectively.</p>
<p>Although const, this function sets <a href="qregexp.html#matchedLength" translate="no">matchedLength</a>(), <a href="qregexp.html#capturedTexts" translate="no">capturedTexts</a>(), and <a href="qregexp.html#pos" translate="no">pos</a>().</p>
<p><b>See also </b><a href="qregexp.html#indexIn" translate="no">indexIn</a>() and <a href="qregexp.html#lastIndexIn" translate="no">lastIndexIn</a>().</p>
<!-- @@@exactMatch -->
<!-- $$$filterList[overload1]$$$filterListconstQStringList& -->
<h3 class="fn" translate="no" id="filterList"><span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> QRegExp::<span class="name">filterList</span>(const <span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> &amp;<i>stringList</i>) const</h3>
<p>Returns a list of all the strings that match this regular expression in <i translate="no">stringList</i>.</p>
<!-- @@@filterList -->
<!-- $$$indexIn[overload1]$$$indexInconstQString&intCaretMode -->
<h3 class="fn" translate="no" id="indexIn"><span class="type">int</span> QRegExp::<span class="name">indexIn</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>str</i>, <span class="type">int</span> <i>offset</i> = 0, <span class="type"><a href="qregexp.html#CaretMode-enum" translate="no">CaretMode</a></span> <i>caretMode</i> = CaretAtZero) const</h3>
<p>Attempts to find a match in <i translate="no">str</i> from position <i translate="no">offset</i> (0 by default). If <i translate="no">offset</i> is -1, the search starts at the last character; if -2, at the next to last character; etc.</p>
<p>Returns the position of the first match, or -1 if there was no match.</p>
<p>The <i translate="no">caretMode</i> parameter can be used to instruct whether <b>^</b> should match at index 0 or at <i translate="no">offset</i>.</p>
<p>You might prefer to use <a href="../qtcore/qstring.html#indexOf" translate="no">QString::indexOf</a>(), <a href="../qtcore/qstring.html#contains" translate="no">QString::contains</a>(), or even <a href="../qtcore/qstringlist.html#filter" translate="no">QStringList::filter</a>(). To replace matches use <a href="../qtcore/qstring.html#replace" translate="no">QString::replace</a>().</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> str <span class="operator">=</span> <span class="string">&quot;offsets: 1.23 .50 71.00 6.00&quot;</span>;
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> rx(<span class="string">&quot;\\d*\\.\\d+&quot;</span>);    <span class="comment">// primitive floating point matching</span>
 <span class="type">int</span> count <span class="operator">=</span> <span class="number">0</span>;
 <span class="type">int</span> pos <span class="operator">=</span> <span class="number">0</span>;
 <span class="keyword">while</span> ((pos <span class="operator">=</span> rx<span class="operator">.</span>indexIn(str<span class="operator">,</span> pos)) <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) {
     <span class="operator">+</span><span class="operator">+</span>count;
     pos <span class="operator">+</span><span class="operator">=</span> rx<span class="operator">.</span>matchedLength();
 }
 <span class="comment">// pos will be 9, 14, 18 and finally 24; count will end up as 4</span>
</pre>
<p>Although const, this function sets <a href="qregexp.html#matchedLength" translate="no">matchedLength</a>(), <a href="qregexp.html#capturedTexts" translate="no">capturedTexts</a>() and <a href="qregexp.html#pos" translate="no">pos</a>().</p>
<p>If the <a href="qregexp.html" translate="no">QRegExp</a> is a wildcard expression (see <a href="qregexp.html#setPatternSyntax" translate="no">setPatternSyntax</a>()) and want to test a string against the whole wildcard expression, use <a href="qregexp.html#exactMatch" translate="no">exactMatch</a>() instead of this function.</p>
<p><b>See also </b><a href="qregexp.html#lastIndexIn" translate="no">lastIndexIn</a>() and <a href="qregexp.html#exactMatch" translate="no">exactMatch</a>().</p>
<!-- @@@indexIn -->
<!-- $$$indexIn$$$indexInconstQStringList&int -->
<h3 class="fn" translate="no" id="indexIn-1"><span class="type">int</span> QRegExp::<span class="name">indexIn</span>(const <span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> &amp;<i>list</i>, <span class="type">int</span> <i>from</i>) const</h3>
<p>Returns the index position of the first exact match of this regexp in <i translate="no">list</i>, searching forward from index position <i translate="no">from</i>. Returns -1 if no item matched.</p>
<p><b>See also </b><a href="qregexp.html#lastIndexIn" translate="no">lastIndexIn</a>() and <a href="qregexp.html#exactMatch" translate="no">exactMatch</a>().</p>
<!-- @@@indexIn -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" translate="no" id="isEmpty"><span class="type">bool</span> QRegExp::<span class="name">isEmpty</span>() const</h3>
<p>Returns <code translate="no">true</code> if the pattern string is empty; otherwise returns false.</p>
<p>If you call <a href="qregexp.html#exactMatch" translate="no">exactMatch</a>() with an empty pattern on an empty string it will return true; otherwise it returns <code translate="no">false</code> since it operates over the whole string. If you call <a href="qregexp.html#indexIn" translate="no">indexIn</a>() with an empty pattern on <i>any</i> string it will return the start offset (0 by default) because the empty pattern matches the 'emptiness' at the start of the string. In this case the length of the match returned by <a href="qregexp.html#matchedLength" translate="no">matchedLength</a>() will be 0.</p>
<p>See <a href="../qtcore/qstring.html#isEmpty" translate="no">QString::isEmpty</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$isMinimal[overload1]$$$isMinimal -->
<h3 class="fn" translate="no" id="isMinimal"><span class="type">bool</span> QRegExp::<span class="name">isMinimal</span>() const</h3>
<p>Returns <code translate="no">true</code> if minimal (non-greedy) matching is enabled; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qregexp.html#caseSensitivity" translate="no">caseSensitivity</a>() and <a href="qregexp.html#setMinimal" translate="no">setMinimal</a>().</p>
<!-- @@@isMinimal -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" translate="no" id="isValid"><span class="type">bool</span> QRegExp::<span class="name">isValid</span>() const</h3>
<p>Returns <code translate="no">true</code> if the regular expression is valid; otherwise returns false. An invalid regular expression never matches.</p>
<p>The pattern <b>[a-z</b> is an example of an invalid pattern, since it lacks a closing square bracket.</p>
<p>Note that the validity of a regexp may also depend on the setting of the wildcard flag, for example <b>*.html</b> is a valid wildcard regexp but an invalid full regexp.</p>
<p><b>See also </b><a href="qregexp.html#errorString" translate="no">errorString</a>().</p>
<!-- @@@isValid -->
<!-- $$$lastIndexIn[overload1]$$$lastIndexInconstQString&intCaretMode -->
<h3 class="fn" translate="no" id="lastIndexIn"><span class="type">int</span> QRegExp::<span class="name">lastIndexIn</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>str</i>, <span class="type">int</span> <i>offset</i> = -1, <span class="type"><a href="qregexp.html#CaretMode-enum" translate="no">CaretMode</a></span> <i>caretMode</i> = CaretAtZero) const</h3>
<p>Attempts to find a match backwards in <i translate="no">str</i> from position <i translate="no">offset</i>. If <i translate="no">offset</i> is -1 (the default), the search starts at the last character; if -2, at the next to last character; etc.</p>
<p>Returns the position of the first match, or -1 if there was no match.</p>
<p>The <i translate="no">caretMode</i> parameter can be used to instruct whether <b>^</b> should match at index 0 or at <i translate="no">offset</i>.</p>
<p>Although const, this function sets <a href="qregexp.html#matchedLength" translate="no">matchedLength</a>(), <a href="qregexp.html#capturedTexts" translate="no">capturedTexts</a>() and <a href="qregexp.html#pos" translate="no">pos</a>().</p>
<div class="admonition warning">
<p><b>Warning: </b>Searching backwards is much slower than searching forwards.</p>
</div>
<p><b>See also </b><a href="qregexp.html#indexIn" translate="no">indexIn</a>() and <a href="qregexp.html#exactMatch" translate="no">exactMatch</a>().</p>
<!-- @@@lastIndexIn -->
<!-- $$$lastIndexIn$$$lastIndexInconstQStringList&int -->
<h3 class="fn" translate="no" id="lastIndexIn-1"><span class="type">int</span> QRegExp::<span class="name">lastIndexIn</span>(const <span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> &amp;<i>list</i>, <span class="type">int</span> <i>from</i>) const</h3>
<p>Returns the index position of the last exact match of this regexp in <i translate="no">list</i>, searching backward from index position <i translate="no">from</i>. If <i translate="no">from</i> is -1 (the default), the search starts at the last item. Returns -1 if no item matched.</p>
<p><b>See also </b><a href="qregexp.html#exactMatch" translate="no">QRegExp::exactMatch</a>().</p>
<!-- @@@lastIndexIn -->
<!-- $$$matchedLength[overload1]$$$matchedLength -->
<h3 class="fn" translate="no" id="matchedLength"><span class="type">int</span> QRegExp::<span class="name">matchedLength</span>() const</h3>
<p>Returns the length of the last matched string, or -1 if there was no match.</p>
<p><b>See also </b><a href="qregexp.html#exactMatch" translate="no">exactMatch</a>(), <a href="qregexp.html#indexIn" translate="no">indexIn</a>(), and <a href="qregexp.html#lastIndexIn" translate="no">lastIndexIn</a>().</p>
<!-- @@@matchedLength -->
<!-- $$$pattern[overload1]$$$pattern -->
<h3 class="fn" translate="no" id="pattern"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QRegExp::<span class="name">pattern</span>() const</h3>
<p>Returns the pattern string of the regular expression. The pattern has either regular expression syntax or wildcard syntax, depending on <a href="qregexp.html#patternSyntax" translate="no">patternSyntax</a>().</p>
<p><b>See also </b><a href="qregexp.html#setPattern" translate="no">setPattern</a>(), <a href="qregexp.html#patternSyntax" translate="no">patternSyntax</a>(), and <a href="qregexp.html#caseSensitivity" translate="no">caseSensitivity</a>().</p>
<!-- @@@pattern -->
<!-- $$$patternSyntax[overload1]$$$patternSyntax -->
<h3 class="fn" translate="no" id="patternSyntax"><span class="type"><a href="qregexp.html#PatternSyntax-enum" translate="no">PatternSyntax</a></span> QRegExp::<span class="name">patternSyntax</span>() const</h3>
<p>Returns the syntax used by the regular expression. The default is <a href="qregexp.html#PatternSyntax-enum" translate="no">QRegExp::RegExp</a>.</p>
<p><b>See also </b><a href="qregexp.html#setPatternSyntax" translate="no">setPatternSyntax</a>(), <a href="qregexp.html#pattern" translate="no">pattern</a>(), and <a href="qregexp.html#caseSensitivity" translate="no">caseSensitivity</a>().</p>
<!-- @@@patternSyntax -->
<!-- $$$pos[overload1]$$$posint -->
<h3 class="fn" translate="no" id="pos"><span class="type">int</span> QRegExp::<span class="name">pos</span>(<span class="type">int</span> <i>nth</i> = 0) const</h3>
<p>Returns the position of the <i translate="no">nth</i> captured text in the searched string. If <i translate="no">nth</i> is 0 (the default), pos() returns the position of the whole match.</p>
<p>Example:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> rx(<span class="string">&quot;/([a-z]+)/([a-z]+)&quot;</span>);
 rx<span class="operator">.</span>indexIn(<span class="string">&quot;Output /dev/null&quot;</span>);   <span class="comment">// returns 7 (position of /dev/null)</span>
 rx<span class="operator">.</span>pos(<span class="number">0</span>);                        <span class="comment">// returns 7 (position of /dev/null)</span>
 rx<span class="operator">.</span>pos(<span class="number">1</span>);                        <span class="comment">// returns 8 (position of dev)</span>
 rx<span class="operator">.</span>pos(<span class="number">2</span>);                        <span class="comment">// returns 12 (position of null)</span>
</pre>
<p>For zero-length matches, pos() always returns -1. (For example, if cap(4) would return an empty string, pos(4) returns -1.) This is a feature of the implementation.</p>
<p><b>See also </b><a href="qregexp.html#cap" translate="no">cap</a>() and <a href="qregexp.html#capturedTexts" translate="no">capturedTexts</a>().</p>
<!-- @@@pos -->
<!-- $$$removeIn[overload1]$$$removeInconstQString& -->
<h3 class="fn" translate="no" id="removeIn"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QRegExp::<span class="name">removeIn</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>str</i>) const</h3>
<p>Removes every occurrence of this regular expression <i translate="no">str</i>, and returns the result</p>
<p>Does the same as <a href="qregexp.html#replaceIn" translate="no">replaceIn</a>(str, QString()).</p>
<p><b>See also </b><a href="qregexp.html#indexIn" translate="no">indexIn</a>(), <a href="qregexp.html#lastIndexIn" translate="no">lastIndexIn</a>(), and <a href="qregexp.html#replaceIn" translate="no">replaceIn</a>().</p>
<!-- @@@removeIn -->
<!-- $$$replaceIn[overload1]$$$replaceInconstQString&constQString& -->
<h3 class="fn" translate="no" id="replaceIn"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QRegExp::<span class="name">replaceIn</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>str</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>after</i>) const</h3>
<p>Replaces every occurrence of this regular expression in <i translate="no">str</i> with <i translate="no">after</i> and returns the result.</p>
<p>For regular expressions containing <a href="qregexp.html#capturing-parentheses" translate="no">capturing parentheses</a>, occurrences of <b>\1</b>, <b>\2</b>, ..&#x2e;, in <i translate="no">after</i> are replaced with <code translate="no">rx</code>.cap(1), cap(2), ..&#x2e;</p>
<p><b>See also </b><a href="qregexp.html#indexIn" translate="no">indexIn</a>(), <a href="qregexp.html#lastIndexIn" translate="no">lastIndexIn</a>(), and <a href="qregexp.html#cap" translate="no">QRegExp::cap</a>().</p>
<!-- @@@replaceIn -->
<!-- $$$replaceIn$$$replaceInconstQStringList&constQString& -->
<h3 class="fn" translate="no" id="replaceIn-1"><span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> QRegExp::<span class="name">replaceIn</span>(const <span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> &amp;<i>stringList</i>, const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>after</i>) const</h3>
<p>Replaces every occurrence of this regexp, in each of <i translate="no">stringList</i>'s with <i translate="no">after</i>. Returns a reference to the string list.</p>
<!-- @@@replaceIn -->
<!-- $$$setCaseSensitivity[overload1]$$$setCaseSensitivityQt::CaseSensitivity -->
<h3 class="fn" translate="no" id="setCaseSensitivity"><span class="type">void</span> QRegExp::<span class="name">setCaseSensitivity</span>(<span class="type"><a href="../qtcore/qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i>)</h3>
<p>Sets case sensitive matching to <i translate="no">cs</i>.</p>
<p>If <i translate="no">cs</i> is <a href="../qtcore/qt.html#CaseSensitivity-enum" translate="no">Qt::CaseSensitive</a>, <b>\.txt$</b> matches <code translate="no">readme.txt</code> but not <code translate="no">README.TXT</code>.</p>
<p><b>See also </b><a href="qregexp.html#caseSensitivity" translate="no">caseSensitivity</a>(), <a href="qregexp.html#setPatternSyntax" translate="no">setPatternSyntax</a>(), <a href="qregexp.html#setPattern" translate="no">setPattern</a>(), and <a href="qregexp.html#setMinimal" translate="no">setMinimal</a>().</p>
<!-- @@@setCaseSensitivity -->
<!-- $$$setMinimal[overload1]$$$setMinimalbool -->
<h3 class="fn" translate="no" id="setMinimal"><span class="type">void</span> QRegExp::<span class="name">setMinimal</span>(<span class="type">bool</span> <i>minimal</i>)</h3>
<p>Enables or disables minimal matching. If <i translate="no">minimal</i> is false, matching is greedy (maximal) which is the default.</p>
<p>For example, suppose we have the input string &quot;We must be &lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;!&quot; and the pattern <b>&lt;b&gt;.*&lt;/b&gt;</b>. With the default greedy (maximal) matching, the match is &quot;We must be <u>&lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;</u>!&quot;. But with minimal (non-greedy) matching, the first match is: &quot;We must be <u>&lt;b&gt;bold&lt;/b&gt;</u>, very &lt;b&gt;bold&lt;/b&gt;!&quot; and the second match is &quot;We must be &lt;b&gt;bold&lt;/b&gt;, very <u>&lt;b&gt;bold&lt;/b&gt;</u>!&quot;. In practice we might use the pattern <b>&lt;b&gt;[^&lt;]*&lt;/b&gt;</b> instead, although this will still fail for nested tags.</p>
<p><b>See also </b><a href="qregexp.html#isMinimal" translate="no">isMinimal</a>() and <a href="qregexp.html#setCaseSensitivity" translate="no">setCaseSensitivity</a>().</p>
<!-- @@@setMinimal -->
<!-- $$$setPattern[overload1]$$$setPatternconstQString& -->
<h3 class="fn" translate="no" id="setPattern"><span class="type">void</span> QRegExp::<span class="name">setPattern</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>pattern</i>)</h3>
<p>Sets the pattern string to <i translate="no">pattern</i>. The case sensitivity, wildcard, and minimal matching options are not changed.</p>
<p><b>See also </b><a href="qregexp.html#pattern" translate="no">pattern</a>(), <a href="qregexp.html#setPatternSyntax" translate="no">setPatternSyntax</a>(), and <a href="qregexp.html#setCaseSensitivity" translate="no">setCaseSensitivity</a>().</p>
<!-- @@@setPattern -->
<!-- $$$setPatternSyntax[overload1]$$$setPatternSyntaxPatternSyntax -->
<h3 class="fn" translate="no" id="setPatternSyntax"><span class="type">void</span> QRegExp::<span class="name">setPatternSyntax</span>(<span class="type"><a href="qregexp.html#PatternSyntax-enum" translate="no">PatternSyntax</a></span> <i>syntax</i>)</h3>
<p>Sets the syntax mode for the regular expression. The default is <a href="qregexp.html#PatternSyntax-enum" translate="no">QRegExp::RegExp</a>.</p>
<p>Setting <i translate="no">syntax</i> to <a href="qregexp.html#PatternSyntax-enum" translate="no">QRegExp::Wildcard</a> enables simple shell-like <a href="qregexp.html#qregexp-wildcard-matching" translate="no">QRegExp wildcard matching</a>. For example, <b>r*.txt</b> matches the string <code translate="no">readme.txt</code> in wildcard mode, but does not match <code translate="no">readme</code>.</p>
<p>Setting <i translate="no">syntax</i> to <a href="qregexp.html#PatternSyntax-enum" translate="no">QRegExp::FixedString</a> means that the pattern is interpreted as a plain string. Special characters (e.g&#x2e;, backslash) don't need to be escaped then.</p>
<p><b>See also </b><a href="qregexp.html#patternSyntax" translate="no">patternSyntax</a>(), <a href="qregexp.html#setPattern" translate="no">setPattern</a>(), <a href="qregexp.html#setCaseSensitivity" translate="no">setCaseSensitivity</a>(), and <a href="qregexp.html#escape" translate="no">escape</a>().</p>
<!-- @@@setPatternSyntax -->
<!-- $$$splitString[overload1]$$$splitStringconstQString&Qt::SplitBehavior -->
<h3 class="fn" translate="no" id="splitString"><span class="type"><a href="../qtcore/qstringlist.html" translate="no">QStringList</a></span> QRegExp::<span class="name">splitString</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>str</i>, <span class="type"><a href="../qtcore/qt.html#SplitBehaviorFlags-enum" translate="no">Qt::SplitBehavior</a></span> <i>behavior</i> = Qt::KeepEmptyParts) const</h3>
<p>Splits <i translate="no">str</i> into substrings wherever this regular expression matches, and returns the list of those strings. If this regular expression does not match anywhere in the string, split() returns a single-element list containing <i translate="no">str</i>.</p>
<p>If <i translate="no">behavior</i> is set to <a href="../qtcore/qt.html#SplitBehaviorFlags-enum" translate="no">Qt::KeepEmptyParts</a>, empty fields are included in the resulting list.</p>
<p><b>See also </b><a href="../qtcore/qstringlist.html#join" translate="no">QStringList::join</a>() and <a href="../qtcore/qstring.html#split" translate="no">QString::split</a>().</p>
<!-- @@@splitString -->
<!-- $$$swap[overload1]$$$swapQRegExp& -->
<h3 class="fn" translate="no" id="swap"><code translate="no">[noexcept] </code><span class="type">void</span> QRegExp::<span class="name">swap</span>(<span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> &amp;<i>other</i>)</h3>
<p>Swaps regular expression <i translate="no">other</i> with this regular expression. This operation is very fast and never fails.</p>
<!-- @@@swap -->
<!-- $$$operator QVariant[overload1]$$$operator QVariant -->
<h3 class="fn" translate="no" id="operator-QVariant"><span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span> QRegExp::<span class="name">operator QVariant</span>() const</h3>
<p>Returns the regexp as a <a href="../qtcore/qvariant.html" translate="no">QVariant</a></p>
<!-- @@@operator QVariant -->
<!-- $$$operator!=[overload1]$$$operator!=constQRegExp& -->
<h3 class="fn" translate="no" id="operator-not-eq"><span class="type">bool</span> QRegExp::<span class="name">operator!=</span>(const <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> &amp;<i>rx</i>) const</h3>
<p>Returns <code translate="no">true</code> if this regular expression is not equal to <i translate="no">rx</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="qregexp.html#operator-eq-eq" translate="no">operator==</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator=[overload1]$$$operator=constQRegExp& -->
<h3 class="fn" translate="no" id="operator-eq"><span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> &amp;QRegExp::<span class="name">operator=</span>(const <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> &amp;<i>rx</i>)</h3>
<p>Copies the regular expression <i translate="no">rx</i> and returns a reference to the copy. The case sensitivity, wildcard, and minimal matching options are also copied.</p>
<!-- @@@operator= -->
<!-- $$$operator=$$$operator=QRegExp&& -->
<h3 class="fn" translate="no" id="operator-eq-1"><code translate="no">[noexcept] </code><span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> &amp;QRegExp::<span class="name">operator=</span>(<span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> &amp;&amp;<i>other</i>)</h3>
<p>Move-assigns <i translate="no">other</i> to this <a href="qregexp.html" translate="no">QRegExp</a> instance.</p>
<!-- @@@operator= -->
<!-- $$$operator==[overload1]$$$operator==constQRegExp& -->
<h3 class="fn" translate="no" id="operator-eq-eq"><span class="type">bool</span> QRegExp::<span class="name">operator==</span>(const <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> &amp;<i>rx</i>) const</h3>
<p>Returns <code translate="no">true</code> if this regular expression is equal to <i translate="no">rx</i>; otherwise returns <code translate="no">false</code>.</p>
<p>Two <a href="qregexp.html" translate="no">QRegExp</a> objects are equal if they have the same pattern strings and the same settings for case sensitivity, wildcard and minimal matching.</p>
<!-- @@@operator== -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qHash[overload1]$$$qHashconstQRegExp&size_t -->
<h3 class="fn" translate="no" id="qHash"><code translate="no">[noexcept] </code><span class="type">size_t</span> <span class="name">qHash</span>(const <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> &amp;<i>key</i>, <span class="type">size_t</span> <i>seed</i> = 0)</h3>
<p>Returns the hash value for <i translate="no">key</i>, using <i translate="no">seed</i> to seed the calculation.</p>
<!-- @@@qHash -->
<!-- $$$operator<<[overload1]$$$operator<<QDataStream&constQRegExp& -->
<h3 class="fn" translate="no" id="operator-lt-lt"><span class="type"><a href="../qtcore/qdatastream.html" translate="no">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="../qtcore/qdatastream.html" translate="no">QDataStream</a></span> &amp;<i>out</i>, const <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> &amp;<i>regExp</i>)</h3>
<p>Writes the regular expression <i translate="no">regExp</i> to stream <i translate="no">out</i>.</p>
<p><b>See also </b><a href="../qtcore/datastreamformat.html" translate="no">Serializing Qt Data Types</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator>>[overload1]$$$operator>>QDataStream&QRegExp& -->
<h3 class="fn" translate="no" id="operator-gt-gt"><span class="type"><a href="../qtcore/qdatastream.html" translate="no">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="../qtcore/qdatastream.html" translate="no">QDataStream</a></span> &amp;<i>in</i>, <span class="type"><a href="qregexp.html#QRegExp" translate="no">QRegExp</a></span> &amp;<i>regExp</i>)</h3>
<p>Reads a regular expression from stream <i translate="no">in</i> into <i translate="no">regExp</i>.</p>
<p><b>See also </b><a href="../qtcore/datastreamformat.html" translate="no">Serializing Qt Data Types</a>.</p>
<!-- @@@operator>> -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2023 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
