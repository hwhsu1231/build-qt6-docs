<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qtprotobuf.qdoc -->
  <meta name="description" content="A collection of examples for Qt Protobuf">
  <title>Qt Protobuf QML types | Qt Protobuf 6.6.2</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.6</a></li>
<li><a href="qtprotobuf-index.html" translate="no">Qt Protobuf</a></li>
<li>Qt Protobuf QML types</li>
<li id="buildversion"><a href="qtprotobuf-index.html" translate="no">Qt 6.6.2 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level2"><a href="#protobuf-message-duplicates">Protobuf message duplicates</a></li>
<li class="level2"><a href="#qml-keywords-handling">QML keywords handling</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Qt Protobuf QML types</h1>
<!-- $$$QtProtobuf-description -->
<div class="descr" id="details">
<p>With the <a href="qtprotobufgen-qt-tool.html" translate="no">generator plugin</a>, you can register protobuf messages in the QML. To register the type, use the <code translate="no">QML</code> and <code translate="no">QML_URI</code> generation keys. See API details in <a href="qt-add-protobuf.html" translate="no">qt_add_protobuf</a> command and API usage example <a href="qtprotobufgen-qt-tool.html#qml-extended-protobuf-example" translate="no">QML extended protobuf</a>.</p>
<p>Registered protobuf messages are available in the QML, like built-in <a href="../qtcore/qobject.html#Q_GADGET" translate="no">Q_GADGET</a> types. The registration is done via the QML module.</p>
<h3 id="protobuf-message-duplicates">Protobuf message duplicates</h3>
<p>You should avoid declaration of protobuf message duplicates in your <code translate="no">*.proto</code> files or do it wisely. In case your application uses several identical protobuf message names declared inside different protobuf packages, they can contradict each other in auto-generated code. In example below, 2 different proto packages <code translate="no">qtprotobufnamespace</code> and <code translate="no">qtprotobufnamespace1.nested</code> use the same proto message <code translate="no">NestedFieldMessage</code>. The file <code translate="no">nested.proto</code>:</p>
<pre class="cpp plain" translate="no">
 syntax = &quot;proto3&quot;;

 package qtprotobufnamespace;
 import &quot;externalpackage.proto&quot;;

 message NestedFieldMessage {
     sint32 testFieldInt = 1;
 }
</pre>
<p>The file <code translate="no">nestedspace1.proto</code>:</p>
<pre class="cpp plain" translate="no">
 syntax = &quot;proto3&quot;;

 package qtprotobufnamespace1.nested;

 message NestedFieldMessage {
     message NestedMessage {
         sint32 field = 1;
     }
     NestedMessage nested = 1;
 }
</pre>
<p>In case there is no possibility to avoid name duplicates among packages, then put duplicated messages in different QML modules and use a &lt;Qualifier&gt; for each QML module import, see <a href="../qtqml/qtqml-syntax-imports.html#module-namespace-imports" translate="no">Module (Namespace) Imports</a>. Below the example how to add protobuf packages into different QML modules:</p>
<pre class="cpp plain" translate="no">
 # qtprotobufnamespace QML module
 qt_add_protobuf(nestedtypes_qtprotobuf_qml
     PROTO_FILES
         nested.proto
     QML
     QML_URI
         qtprotobufnamespace
     OUTPUT_DIRECTORY &quot;${CMAKE_CURRENT_BINARY_DIR}/qt_protobuf_gen1&quot;
 )

 ....................................

 # qtprotobufnamespace1.nested QML module
 qt_add_protobuf(nestedspace_qml
     PROTO_FILES
         nestedspace1.proto
     QML
     QML_URI
         qtprotobufnamespace1.nested
     OUTPUT_DIRECTORY &quot;${CMAKE_CURRENT_BINARY_DIR}/qt_protobuf_gen2&quot;
 )
</pre>
<p>The &lt;Qualifier&gt; usage example:</p>
<pre class="cpp plain" translate="no">
 import qtprotobufnamespace as NestedFieldMessages
 import qtprotobufnamespace1.nested as FieldMessages_Nested1

 .....................................
 .....................................
 .....................................

 property NestedFieldMessages.nestedFieldMessage fieldMsg1;
 property FieldMessages_Nested1.nestedFieldMessage fieldMsg2;
</pre>
<div class="admonition note">
<p><b>Note: </b>The usage of duplicates will trigger a warning at compilation time.</p>
</div>
<h3 id="qml-keywords-handling">QML keywords handling</h3>
<p>Pay attention to the keywords that are reserved in QML or JavaScript context, but not reserved in *.proto context. Fields with names that are reserved by QML will be silently extended by <code translate="no">_proto</code> suffix by the <a href="qtprotobufgen-qt-tool.html" translate="no">generator plugin</a>. For example, <code translate="no">id</code>, <code translate="no">property</code>, and <code translate="no">import</code> are reserved keywords. They will be replaced by <code translate="no">id_proto</code>, <code translate="no">property_proto</code>, <code translate="no">import_proto</code>:</p>
<pre class="cpp plain" translate="no">
 message MessageUpperCaseReserved {
     sint32 Import = 1;
     sint32 Property = 2;
     sint32 Id = 3;
 }
</pre>
<p>Generated code output:</p>
<pre class="cpp" translate="no">
 Q_PROPERTY(<span class="type"><a href="qtprotobuf.html" translate="no">QtProtobuf</a></span><span class="operator">::</span>sint32 import_proto READ import_proto <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>)
 Q_PROPERTY(<span class="type"><a href="qtprotobuf.html" translate="no">QtProtobuf</a></span><span class="operator">::</span>sint32 property_proto READ property_proto <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>)
 Q_PROPERTY(<span class="type"><a href="qtprotobuf.html" translate="no">QtProtobuf</a></span><span class="operator">::</span>sint32 id_proto READ id_proto <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>)
</pre>
<p>Also, enum values cannot begin with a lower case letter. The <a href="qtprotobufgen-qt-tool.html" translate="no">generator plugin</a> will capitalize the first letter in code output. See the <code translate="no">*.proto</code> example below:</p>
<pre class="cpp plain" translate="no">
 enum LowerCaseEnum {
     enumValue0 = 0;
     enumValue1 = 1;
     enumValue2 = 2;
 }
</pre>
<p>Generated code output:</p>
<pre class="cpp" translate="no">
 <span class="keyword">enum</span> LowerCaseEnum {
     EnumValue0 <span class="operator">=</span> <span class="number">0</span><span class="operator">,</span>
     EnumValue1 <span class="operator">=</span> <span class="number">1</span><span class="operator">,</span>
     EnumValue2 <span class="operator">=</span> <span class="number">2</span><span class="operator">,</span>
 };
 Q_ENUM(LowerCaseEnum)
</pre>
<p>Also, enum fields cannot begin with an underscore symbol. Such fields will be generated as is, but will be undefined in the QML, unless the QML engine will allow registering them in the future. See the <code translate="no">*.proto</code> example below:</p>
<pre class="cpp plain" translate="no">
 enum UnderScoreEnum {
     _enumUnderscoreValue0 = 0;
     _EnumUnderscoreValue1 = 1;
 }
</pre>
<p>Generated output:</p>
<pre class="cpp" translate="no">
 <span class="keyword">enum</span> UnderScoreEnum {
     _enumUnderscoreValue0 <span class="operator">=</span> <span class="number">0</span><span class="operator">,</span>
     _EnumUnderscoreValue1 <span class="operator">=</span> <span class="number">1</span><span class="operator">,</span>
 };
 Q_ENUM(UnderScoreEnum)
</pre>
<p>For more information about the QML properties syntax, check <a href="../qtqml/qtqml-syntax-objectattributes.html#defining-property-attributes" translate="no">Defining Property Attributes</a>.</p>
</div>
<!-- @@@QtProtobuf -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
