<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qmodbusclient.cpp -->
  <meta name="description" content="The QModbusClient class is the interface to send Modbus requests.">
  <title>QModbusClient Class | Qt Serial Bus 6.6.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.6</a></li>
<li><a href="qtserialbus-index.html" translate="no">Qt Serial Bus</a></li>
<li><a href="qtserialbus-module.html" translate="no">C++ Classes</a></li>
<li>QModbusClient</li>
<li id="buildversion"><a href="qtserialbus-index.html" translate="no">Qt 6.6&#x2e;0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QModbusClient Class</h1>
<!-- $$$QModbusClient-brief -->
<p>The QModbusClient class is the interface to send Modbus requests. <a href="#details">More...</a></p>
<!-- @@@QModbusClient -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QModbusClient&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS SerialBus) <br/>
target_link_libraries(mytarget PRIVATE Qt6::SerialBus)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += serialbus</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qmodbusdevice.html" translate="no">QModbusDevice</a></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="qmodbusrtuserialclient.html" translate="no">QModbusRtuSerialClient</a> and <a href="qmodbustcpclient.html" translate="no">QModbusTcpClient</a></p>
</td></tr>
</table></div>
<ul>
<li><a href="qmodbusclient-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#QModbusClient" translate="no">QModbusClient</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#numberOfRetries" translate="no">numberOfRetries</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QModbusReply *</td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#sendRawRequest" translate="no">sendRawRequest</a></b>(const QModbusRequest &amp;<i>request</i>, int <i>serverAddress</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QModbusReply *</td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#sendReadRequest" translate="no">sendReadRequest</a></b>(const QModbusDataUnit &amp;<i>read</i>, int <i>serverAddress</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QModbusReply *</td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#sendReadWriteRequest" translate="no">sendReadWriteRequest</a></b>(const QModbusDataUnit &amp;<i>read</i>, const QModbusDataUnit &amp;<i>write</i>, int <i>serverAddress</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QModbusReply *</td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#sendWriteRequest" translate="no">sendWriteRequest</a></b>(const QModbusDataUnit &amp;<i>write</i>, int <i>serverAddress</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#setNumberOfRetries" translate="no">setNumberOfRetries</a></b>(int <i>number</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#setTimeout" translate="no">setTimeout</a></b>(int <i>newTimeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#timeout" translate="no">timeout</a></b>() const</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#timeoutChanged" translate="no">timeoutChanged</a></b>(int <i>newTimeout</i>)</td></tr>
</table></div>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#processPrivateResponse" translate="no">processPrivateResponse</a></b>(const QModbusResponse &amp;<i>response</i>, QModbusDataUnit *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#processResponse" translate="no">processResponse</a></b>(const QModbusResponse &amp;<i>response</i>, QModbusDataUnit *<i>data</i>)</td></tr>
</table></div>
<!-- $$$QModbusClient-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The QModbusClient API is constructed around one QModbusClient object, which holds the common configuration and settings for the requests it sends. One QModbusClient should be enough for the whole Qt application.</p>
<p>Once a QModbusClient object has been created, the application can use it to send requests. The returned object is used to obtain any data returned in response to the corresponding request.</p>
<p>QModbusClient has an asynchronous API. When the finished slot is called, the parameter it takes is the <a href="qmodbusreply.html" translate="no">QModbusReply</a> object containing the PDU as well as meta-data (Addressing, etc.)&#x2e;</p>
<p>Note: QModbusClient queues the requests it receives. The number of requests executed in parallel is dependent on the protocol. For example, the HTTP protocol on desktop platforms issues 6 requests in parallel for one host/port combination.</p>
</div>
<!-- @@@QModbusClient -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QModbusClient[overload1]$$$QModbusClientQObject* -->
<h3 class="fn" translate="no" id="QModbusClient"><code translate="no">[explicit] </code>QModbusClient::<span class="name">QModbusClient</span>(<span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a Modbus client device with the specified <i translate="no">parent</i>.</p>
<!-- @@@QModbusClient -->
<!-- $$$numberOfRetries[overload1]$$$numberOfRetries -->
<h3 class="fn" translate="no" id="numberOfRetries"><span class="type">int</span> QModbusClient::<span class="name">numberOfRetries</span>() const</h3>
<p>Returns the number of retries a client will perform before a request fails. The default value is set to <code translate="no">3</code>.</p>
<p><b>See also </b><a href="qmodbusclient.html#setNumberOfRetries" translate="no">setNumberOfRetries</a>().</p>
<!-- @@@numberOfRetries -->
<!-- $$$processPrivateResponse[overload1]$$$processPrivateResponseconstQModbusResponse&QModbusDataUnit* -->
<h3 class="fn" translate="no" id="processPrivateResponse"><code translate="no">[virtual protected] </code><span class="type">bool</span> QModbusClient::<span class="name">processPrivateResponse</span>(const <span class="type"><a href="qmodbusresponse.html" translate="no">QModbusResponse</a></span> &amp;<i>response</i>, <span class="type"><a href="qmodbusdataunit.html" translate="no">QModbusDataUnit</a></span> *<i>data</i>)</h3>
<p>To be implemented by custom Modbus client implementation. The default implementation ignores <i translate="no">response</i> and <i translate="no">data</i>. It always returns false to indicate error.</p>
<!-- @@@processPrivateResponse -->
<!-- $$$processResponse[overload1]$$$processResponseconstQModbusResponse&QModbusDataUnit* -->
<h3 class="fn" translate="no" id="processResponse"><code translate="no">[virtual protected] </code><span class="type">bool</span> QModbusClient::<span class="name">processResponse</span>(const <span class="type"><a href="qmodbusresponse.html" translate="no">QModbusResponse</a></span> &amp;<i>response</i>, <span class="type"><a href="qmodbusdataunit.html" translate="no">QModbusDataUnit</a></span> *<i>data</i>)</h3>
<p>Processes a Modbus server <i translate="no">response</i> and stores the decoded information in <i translate="no">data</i>. Returns <code translate="no">true</code> on success; otherwise <code translate="no">false</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The default implementation does not support all <a href="qmodbuspdu.html#FunctionCode-enum" translate="no">FunctionCode</a>s. Override this method in a custom Modbus client implementations to handle the needed functions.</p>
</div>
<!-- @@@processResponse -->
<!-- $$$sendRawRequest[overload1]$$$sendRawRequestconstQModbusRequest&int -->
<h3 class="fn" translate="no" id="sendRawRequest"><span class="type"><a href="qmodbusreply.html" translate="no">QModbusReply</a></span> *QModbusClient::<span class="name">sendRawRequest</span>(const <span class="type"><a href="qmodbusrequest.html" translate="no">QModbusRequest</a></span> &amp;<i>request</i>, <span class="type">int</span> <i>serverAddress</i>)</h3>
<p>Sends a raw Modbus <i translate="no">request</i>. A raw request can contain anything that fits inside the Modbus PDU data section and has a valid function code. The only check performed before sending is therefore the validity check, see <a href="qmodbuspdu.html#isValid" translate="no">QModbusPdu::isValid</a>. If no error occurred the function returns a new valid <a href="qmodbusreply.html" translate="no">QModbusReply</a>; nullptr otherwise. Modbus networks may have multiple servers, each server has a unique <i translate="no">serverAddress</i>.</p>
<p><b>See also </b><a href="qmodbusreply.html#rawResult" translate="no">QModbusReply::rawResult</a>().</p>
<!-- @@@sendRawRequest -->
<!-- $$$sendReadRequest[overload1]$$$sendReadRequestconstQModbusDataUnit&int -->
<h3 class="fn" translate="no" id="sendReadRequest"><span class="type"><a href="qmodbusreply.html" translate="no">QModbusReply</a></span> *QModbusClient::<span class="name">sendReadRequest</span>(const <span class="type"><a href="qmodbusdataunit.html" translate="no">QModbusDataUnit</a></span> &amp;<i>read</i>, <span class="type">int</span> <i>serverAddress</i>)</h3>
<p>Sends a request to read the contents of the data pointed by <i translate="no">read</i>. Returns a new valid <a href="qmodbusreply.html" translate="no">QModbusReply</a> object if no error occurred, otherwise nullptr. Modbus network may have multiple servers, each server has unique <i translate="no">serverAddress</i>.</p>
<!-- @@@sendReadRequest -->
<!-- $$$sendReadWriteRequest[overload1]$$$sendReadWriteRequestconstQModbusDataUnit&constQModbusDataUnit&int -->
<h3 class="fn" translate="no" id="sendReadWriteRequest"><span class="type"><a href="qmodbusreply.html" translate="no">QModbusReply</a></span> *QModbusClient::<span class="name">sendReadWriteRequest</span>(const <span class="type"><a href="qmodbusdataunit.html" translate="no">QModbusDataUnit</a></span> &amp;<i>read</i>, const <span class="type"><a href="qmodbusdataunit.html" translate="no">QModbusDataUnit</a></span> &amp;<i>write</i>, <span class="type">int</span> <i>serverAddress</i>)</h3>
<p>Sends a request to read the contents of the data pointed by <i translate="no">read</i> and to modify the contents of the data pointed by <i translate="no">write</i> using Modbus function code <a href="qmodbuspdu.html#FunctionCode-enum" translate="no">QModbusPdu::ReadWriteMultipleRegisters</a>. Returns a new valid <a href="qmodbusreply.html" translate="no">QModbusReply</a> object if no error occurred, otherwise nullptr. Modbus network may have multiple servers, each server has unique <i translate="no">serverAddress</i>.</p>
<div class="admonition note">
<p><b>Note: </b>: Sending this kind of request is only valid of both <i translate="no">read</i> and <i translate="no">write</i> are of type <a href="qmodbusdataunit.html#RegisterType-enum" translate="no">QModbusDataUnit::HoldingRegisters</a>.</p>
</div>
<!-- @@@sendReadWriteRequest -->
<!-- $$$sendWriteRequest[overload1]$$$sendWriteRequestconstQModbusDataUnit&int -->
<h3 class="fn" translate="no" id="sendWriteRequest"><span class="type"><a href="qmodbusreply.html" translate="no">QModbusReply</a></span> *QModbusClient::<span class="name">sendWriteRequest</span>(const <span class="type"><a href="qmodbusdataunit.html" translate="no">QModbusDataUnit</a></span> &amp;<i>write</i>, <span class="type">int</span> <i>serverAddress</i>)</h3>
<p>Sends a request to modify the contents of the data pointed by <i translate="no">write</i>. Returns a new valid <a href="qmodbusreply.html" translate="no">QModbusReply</a> object if no error occurred, otherwise nullptr. Modbus network may have multiple servers, each server has unique <i translate="no">serverAddress</i>.</p>
<!-- @@@sendWriteRequest -->
<!-- $$$setNumberOfRetries[overload1]$$$setNumberOfRetriesint -->
<h3 class="fn" translate="no" id="setNumberOfRetries"><span class="type">void</span> QModbusClient::<span class="name">setNumberOfRetries</span>(<span class="type">int</span> <i>number</i>)</h3>
<p>Sets the <i translate="no">number</i> of retries a client will perform before a request fails. The default value is set to <code translate="no">3</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The new value must be greater than or equal to <code translate="no">0</code>. Changing this property will only effect new requests, not already scheduled ones.</p>
</div>
<p><b>See also </b><a href="qmodbusclient.html#numberOfRetries" translate="no">numberOfRetries</a>().</p>
<!-- @@@setNumberOfRetries -->
<!-- $$$setTimeout[overload1]$$$setTimeoutint -->
<h3 class="fn" translate="no" id="setTimeout"><span class="type">void</span> QModbusClient::<span class="name">setTimeout</span>(<span class="type">int</span> <i>newTimeout</i>)</h3>
<p>Sets the <i translate="no">newTimeout</i> for this <a href="qmodbusclient.html" translate="no">QModbusClient</a> instance. The minimum timeout is 10 ms.</p>
<p>The timeout is used by the client to determine how long it waits for a response from the server. If the response is not received within the required timeout, the <a href="qmodbusdevice.html#Error-enum" translate="no">TimeoutError</a> is set.</p>
<p>Already active/running timeouts are not affected by such timeout duration changes.</p>
<p><b>See also </b><a href="qmodbusclient.html#timeout" translate="no">timeout</a> and <a href="qmodbusclient.html#timeoutChanged" translate="no">timeoutChanged</a>().</p>
<!-- @@@setTimeout -->
<!-- $$$timeout[overload1]$$$timeout -->
<h3 class="fn" translate="no" id="timeout"><span class="type">int</span> QModbusClient::<span class="name">timeout</span>() const</h3>
<p>Returns the timeout value used by this <a href="qmodbusclient.html" translate="no">QModbusClient</a> instance in ms. A timeout is indicated by a <a href="qmodbusdevice.html#Error-enum" translate="no">TimeoutError</a>. The default value is 1000 ms.</p>
<p><b>See also </b><a href="qmodbusclient.html#setTimeout" translate="no">setTimeout</a> and <a href="qmodbusclient.html#timeoutChanged" translate="no">timeoutChanged</a>().</p>
<!-- @@@timeout -->
<!-- $$$timeoutChanged[overload1]$$$timeoutChangedint -->
<h3 class="fn" translate="no" id="timeoutChanged"><code translate="no">[signal] </code><span class="type">void</span> QModbusClient::<span class="name">timeoutChanged</span>(<span class="type">int</span> <i>newTimeout</i>)</h3>
<p>This signal is emitted when the timeout used by this <a href="qmodbusclient.html" translate="no">QModbusClient</a> instance is changed. The new response timeout for the device is passed as <i translate="no">newTimeout</i>.</p>
<p><b>See also </b><a href="qmodbusclient.html#setTimeout" translate="no">setTimeout</a>().</p>
<!-- @@@timeoutChanged -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2023 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
