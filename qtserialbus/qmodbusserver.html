<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qmodbusserver.cpp -->
  <meta name="description" content="The QModbusServer class is the interface to receive and process Modbus requests.">
  <title>QModbusServer Class | Qt Serial Bus 6.6.2</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.6</a></li>
<li><a href="qtserialbus-index.html" translate="no">Qt Serial Bus</a></li>
<li><a href="qtserialbus-module.html" translate="no">C++ Classes</a></li>
<li>QModbusServer</li>
<li id="buildversion"><a href="qtserialbus-index.html" translate="no">Qt 6.6.2 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QModbusServer Class</h1>
<!-- $$$QModbusServer-brief -->
<p>The QModbusServer class is the interface to receive and process Modbus requests. <a href="#details">More...</a></p>
<!-- @@@QModbusServer -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QModbusServer&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS SerialBus) <br/>
target_link_libraries(mytarget PRIVATE Qt6::SerialBus)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += serialbus</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qmodbusdevice.html" translate="no">QModbusDevice</a></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="qmodbusrtuserialserver.html" translate="no">QModbusRtuSerialServer</a> and <a href="qmodbustcpserver.html" translate="no">QModbusTcpServer</a></p>
</td></tr>
</table></div>
<ul>
<li><a href="qmodbusserver-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#Option-enum" translate="no">Option</a></b> { DiagnosticRegister, ExceptionStatusOffset, DeviceBusy, AsciiInputDelimiter, ListenOnlyMode, &hellip;, UserOption }</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#QModbusServer" translate="no">QModbusServer</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#data" translate="no">data</a></b>(QModbusDataUnit *<i>newData</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#data-1" translate="no">data</a></b>(QModbusDataUnit::RegisterType <i>table</i>, quint16 <i>address</i>, quint16 *<i>data</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#processesBroadcast" translate="no">processesBroadcast</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#serverAddress" translate="no">serverAddress</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#setData" translate="no">setData</a></b>(const QModbusDataUnit &amp;<i>newData</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#setData-1" translate="no">setData</a></b>(QModbusDataUnit::RegisterType <i>table</i>, quint16 <i>address</i>, quint16 <i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#setMap" translate="no">setMap</a></b>(const QModbusDataUnitMap &amp;<i>map</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#setServerAddress" translate="no">setServerAddress</a></b>(int <i>serverAddress</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#setValue" translate="no">setValue</a></b>(int <i>option</i>, const QVariant &amp;<i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QVariant </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#value" translate="no">value</a></b>(int <i>option</i>) const</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#dataWritten" translate="no">dataWritten</a></b>(QModbusDataUnit::RegisterType <i>table</i>, int <i>address</i>, int <i>size</i>)</td></tr>
</table></div>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QModbusResponse </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#processPrivateRequest" translate="no">processPrivateRequest</a></b>(const QModbusPdu &amp;<i>request</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QModbusResponse </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#processRequest" translate="no">processRequest</a></b>(const QModbusPdu &amp;<i>request</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#readData" translate="no">readData</a></b>(QModbusDataUnit *<i>newData</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusserver.html#writeData" translate="no">writeData</a></b>(const QModbusDataUnit &amp;<i>newData</i>)</td></tr>
</table></div>
<!-- $$$QModbusServer-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>Modbus networks can have multiple Modbus servers. Modbus Servers are read/written by a Modbus client represented by <a href="qmodbusclient.html" translate="no">QModbusClient</a>. QModbusServer communicates with a Modbus backend, providing users with a convenient API.</p>
</div>
<!-- @@@QModbusServer -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Option$$$DiagnosticRegister$$$ExceptionStatusOffset$$$DeviceBusy$$$AsciiInputDelimiter$$$ListenOnlyMode$$$ServerIdentifier$$$RunIndicatorStatus$$$AdditionalData$$$DeviceIdentification$$$UserOption -->
<h3 class="fn" translate="no" id="Option-enum">enum QModbusServer::<span class="name">Option</span></h3>
<p>Each Modbus server has a set of values associated with it, each with its own option.</p>
<p>The general purpose options (and the associated types) are:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QModbusServer::DiagnosticRegister</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The diagnostic register of the server. <code translate="no">quint16</code></td></tr>
<tr><td class="topAlign"><code translate="no">QModbusServer::ExceptionStatusOffset</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The exception status byte offset of the server. <code translate="no">quint16</code></td></tr>
<tr><td class="topAlign"><code translate="no">QModbusServer::DeviceBusy</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Flag to signal the server is engaged in processing a long-duration program command. <code translate="no">quint16</code></td></tr>
<tr><td class="topAlign"><code translate="no">QModbusServer::AsciiInputDelimiter</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">The Modbus ASCII end of message delimiter. <code translate="no">char</code></td></tr>
<tr><td class="topAlign"><code translate="no">QModbusServer::ListenOnlyMode</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">Flag to set listen only mode of the server. This function is typically supported only by Modbus serial devices. <code translate="no">bool</code></td></tr>
<tr><td class="topAlign"><code translate="no">QModbusServer::ServerIdentifier</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">The identifier of the server, <b>not</b> the server address. <code translate="no">quint8</code></td></tr>
<tr><td class="topAlign"><code translate="no">QModbusServer::RunIndicatorStatus</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">The run indicator of the server. <code translate="no">quint8</code></td></tr>
<tr><td class="topAlign"><code translate="no">QModbusServer::AdditionalData</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">The additional data of the server. <code translate="no">QByteArray</code></td></tr>
<tr><td class="topAlign"><code translate="no">QModbusServer::DeviceIdentification</code></td><td class="topAlign tblval"><code translate="no">8</code></td><td class="topAlign">The physical and functional description of the server. <code translate="no">QModbusDeviceIdentification</code></td></tr>
</table></div>
<p>User options:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="even"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QModbusServer::UserOption</code></td><td class="topAlign tblval"><code translate="no">0x100</code></td><td class="topAlign">The first option that can be used for user-specific purposes.</td></tr>
</table></div>
<p>For user options, it is up to the developer to decide which types to use and ensure that components use the correct types when accessing and setting values.</p>
<!-- @@@Option -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QModbusServer[overload1]$$$QModbusServerQObject* -->
<h3 class="fn" translate="no" id="QModbusServer"><code translate="no">[explicit] </code>QModbusServer::<span class="name">QModbusServer</span>(<span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a Modbus server with the specified <i translate="no">parent</i>.</p>
<!-- @@@QModbusServer -->
<!-- $$$data[overload1]$$$dataQModbusDataUnit* -->
<h3 class="fn" translate="no" id="data"><span class="type">bool</span> QModbusServer::<span class="name">data</span>(<span class="type"><a href="qmodbusdataunit.html" translate="no">QModbusDataUnit</a></span> *<i>newData</i>) const</h3>
<p>Returns the values in the register range given by <i translate="no">newData</i>.</p>
<p><i translate="no">newData</i> must provide a valid register type, start address and valueCount. The returned <i translate="no">newData</i> will contain the register values associated with the given range.</p>
<p>If <i translate="no">newData</i> contains a valid register type but a negative start address the entire register map is returned and <i translate="no">newData</i> appropriately sized.</p>
<p><b>See also </b><a href="qmodbusserver.html#setData" translate="no">setData</a>().</p>
<!-- @@@data -->
<!-- $$$data$$$dataQModbusDataUnit::RegisterTypequint16quint16* -->
<h3 class="fn" translate="no" id="data-1"><span class="type">bool</span> QModbusServer::<span class="name">data</span>(<span class="type"><a href="qmodbusdataunit.html#RegisterType-enum" translate="no">QModbusDataUnit::RegisterType</a></span> <i>table</i>, <span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> <i>address</i>, <span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> *<i>data</i>) const</h3>
<p>Reads data stored in the Modbus server. A Modbus server has four tables (<i translate="no">table</i>) and each have a unique <i translate="no">address</i> field, which is used to read <i translate="no">data</i> from the desired field. See <a href="qmodbusdataunit.html#RegisterType-enum" translate="no">QModbusDataUnit::RegisterType</a> for more information about the different tables. Returns <code translate="no">false</code> if address is outside of the map range or the register type is not even defined.</p>
<p><b>See also </b><a href="qmodbusdataunit.html#RegisterType-enum" translate="no">QModbusDataUnit::RegisterType</a> and <a href="qmodbusserver.html#setData" translate="no">setData</a>().</p>
<!-- @@@data -->
<!-- $$$dataWritten[overload1]$$$dataWrittenQModbusDataUnit::RegisterTypeintint -->
<h3 class="fn" translate="no" id="dataWritten"><code translate="no">[signal] </code><span class="type">void</span> QModbusServer::<span class="name">dataWritten</span>(<span class="type"><a href="qmodbusdataunit.html#RegisterType-enum" translate="no">QModbusDataUnit::RegisterType</a></span> <i>table</i>, <span class="type">int</span> <i>address</i>, <span class="type">int</span> <i>size</i>)</h3>
<p>This signal is emitted when a Modbus client has written one or more fields of data to the Modbus server. The signal contains information about the fields that were written:</p>
<ul>
<li>Register type (<i translate="no">table</i>) that was written,</li>
<li><i translate="no">address</i> of the first field that was written,</li>
<li>and <i translate="no">size</i> of consecutive fields that were written starting from <i translate="no">address</i>.</li>
</ul>
<p>The signal is not emitted when the to-be-written fields have not changed due to no change in value.</p>
<!-- @@@dataWritten -->
<!-- $$$processPrivateRequest[overload1]$$$processPrivateRequestconstQModbusPdu& -->
<h3 class="fn" translate="no" id="processPrivateRequest"><code translate="no">[virtual protected] </code><span class="type"><a href="qmodbusresponse.html" translate="no">QModbusResponse</a></span> QModbusServer::<span class="name">processPrivateRequest</span>(const <span class="type"><a href="qmodbuspdu.html" translate="no">QModbusPdu</a></span> &amp;<i>request</i>)</h3>
<p>This function should be implemented by custom Modbus servers. It is called by <a href="qmodbusserver.html#processRequest" translate="no">processRequest</a>() if the given <i translate="no">request</i> is not a standard Modbus request.</p>
<p>Overwriting this function allows handling of additional function codes and subfunction-codes not specified in the Modbus Application Protocol Specification 1.1b. Reimplementations should call this function again to ensure an exception response is returned for all unknown function codes the custom Modbus implementation does not handle.</p>
<p>This default implementation returns a <code translate="no">QModbusExceptionResponse</code> with the <i translate="no">request</i> function code and error code set to illegal function.</p>
<p><b>See also </b><a href="qmodbusserver.html#processRequest" translate="no">processRequest</a>().</p>
<!-- @@@processPrivateRequest -->
<!-- $$$processRequest[overload1]$$$processRequestconstQModbusPdu& -->
<h3 class="fn" translate="no" id="processRequest"><code translate="no">[virtual protected] </code><span class="type"><a href="qmodbusresponse.html" translate="no">QModbusResponse</a></span> QModbusServer::<span class="name">processRequest</span>(const <span class="type"><a href="qmodbuspdu.html" translate="no">QModbusPdu</a></span> &amp;<i>request</i>)</h3>
<p>Processes a Modbus client <i translate="no">request</i> and returns a Modbus response. This function returns a <a href="qmodbusresponse.html" translate="no">QModbusResponse</a> or <a href="qmodbusexceptionresponse.html" translate="no">QModbusExceptionResponse</a> depending on the nature of the request.</p>
<p>The default implementation of this function handles all standard Modbus function codes as defined by the Modbus Application Protocol Specification 1.1b. All other Modbus function codes not included in the specification are forwarded to <a href="qmodbusserver.html#processPrivateRequest" translate="no">processPrivateRequest</a>().</p>
<p>The default handling of the standard Modbus function code requests can be overwritten by reimplementing this function. The override must handle the request type in question and return the appropriate <a href="qmodbusresponse.html" translate="no">QModbusResponse</a>. A common reason might be to filter out function code requests for data values to limit read/write access and function codes not desired in particular implementations such as serial line diagnostics on ethernet or Modbus Plus transport layers. Every other request type should be forwarded to this default implementation.</p>
<div class="admonition note">
<p><b>Note: </b>This function should not be overridden to provide a custom implementation for non-standard Modbus request types.</p>
</div>
<p><b>See also </b><a href="qmodbusserver.html#processPrivateRequest" translate="no">processPrivateRequest</a>().</p>
<!-- @@@processRequest -->
<!-- $$$processesBroadcast[overload1]$$$processesBroadcast -->
<h3 class="fn" translate="no" id="processesBroadcast"><code translate="no">[virtual] </code><span class="type">bool</span> QModbusServer::<span class="name">processesBroadcast</span>() const</h3>
<p>Subclasses should implement this function if the transport layer shall handle broadcasts. The implementation then should return <code translate="no">true</code> if the currently processed request is a broadcast request; otherwise <code translate="no">false</code>. The default implementation returns always <code translate="no">false</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The return value of this function only makes sense from within <a href="qmodbusserver.html#processRequest" translate="no">processRequest</a>() or <a href="qmodbusserver.html#processPrivateRequest" translate="no">processPrivateRequest</a>(), otherwise it can only tell that the last request processed was a broadcast request.</p>
</div>
<!-- @@@processesBroadcast -->
<!-- $$$readData[overload1]$$$readDataQModbusDataUnit* -->
<h3 class="fn" translate="no" id="readData"><code translate="no">[virtual protected] </code><span class="type">bool</span> QModbusServer::<span class="name">readData</span>(<span class="type"><a href="qmodbusdataunit.html" translate="no">QModbusDataUnit</a></span> *<i>newData</i>) const</h3>
<p>Reads the values in the register range given by <i translate="no">newData</i> and writes the data back to <i translate="no">newData</i>. Returns <code translate="no">true</code> on success or <code translate="no">false</code> if <i translate="no">newData</i> is <code translate="no">0</code>, the <i translate="no">newData</i> range is outside of the map range or the registerType() does not exist.</p>
<div class="admonition note">
<p><b>Note: </b>Sub-classes that implement reading from a different backing store then default one, also need to implement <a href="qmodbusserver.html#setMap" translate="no">setMap</a>() and <a href="qmodbusserver.html#writeData" translate="no">writeData</a>().</p>
</div>
<p><b>See also </b><a href="qmodbusserver.html#setMap" translate="no">setMap</a>() and <a href="qmodbusserver.html#writeData" translate="no">writeData</a>().</p>
<!-- @@@readData -->
<!-- $$$serverAddress[overload1]$$$serverAddress -->
<h3 class="fn" translate="no" id="serverAddress"><span class="type">int</span> QModbusServer::<span class="name">serverAddress</span>() const</h3>
<p>Returns the address of this Modbus server instance.</p>
<p><b>See also </b><a href="qmodbusserver.html#setServerAddress" translate="no">setServerAddress</a>().</p>
<!-- @@@serverAddress -->
<!-- $$$setData[overload1]$$$setDataconstQModbusDataUnit& -->
<h3 class="fn" translate="no" id="setData"><span class="type">bool</span> QModbusServer::<span class="name">setData</span>(const <span class="type"><a href="qmodbusdataunit.html" translate="no">QModbusDataUnit</a></span> &amp;<i>newData</i>)</h3>
<p>Writes <i translate="no">newData</i> to the Modbus server map. Returns <code translate="no">false</code> if the <i translate="no">newData</i> range is outside of the map range.</p>
<p>If the call was successful the <a href="qmodbusserver.html#dataWritten" translate="no">dataWritten</a>() signal is emitted. Note that the signal is not emitted when the addressed register has not changed. This may happen when <i translate="no">newData</i> contains exactly the same values as the register already. Nevertheless this function returns <code translate="no">true</code> in such cases.</p>
<p><b>See also </b><a href="qmodbusserver.html#data" translate="no">data</a>().</p>
<!-- @@@setData -->
<!-- $$$setData$$$setDataQModbusDataUnit::RegisterTypequint16quint16 -->
<h3 class="fn" translate="no" id="setData-1"><span class="type">bool</span> QModbusServer::<span class="name">setData</span>(<span class="type"><a href="qmodbusdataunit.html#RegisterType-enum" translate="no">QModbusDataUnit::RegisterType</a></span> <i>table</i>, <span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> <i>address</i>, <span class="type"><a href="../qtcore/qttypes.html#quint16-typedef" translate="no">quint16</a></span> <i>data</i>)</h3>
<p>Writes data to the Modbus server. A Modbus server has four tables (<i translate="no">table</i>) and each have a unique <i translate="no">address</i> field, which is used to write <i translate="no">data</i> to the desired field. Returns <code translate="no">false</code> if address outside of the map range.</p>
<p>If the call was successful the <a href="qmodbusserver.html#dataWritten" translate="no">dataWritten</a>() signal is emitted. Note that the signal is not emitted when <i translate="no">data</i> has not changed. Nevertheless this function returns <code translate="no">true</code> in such cases.</p>
<p><b>See also </b><a href="qmodbusdataunit.html#RegisterType-enum" translate="no">QModbusDataUnit::RegisterType</a>, <a href="qmodbusserver.html#data" translate="no">data</a>(), and <a href="qmodbusserver.html#dataWritten" translate="no">dataWritten</a>().</p>
<!-- @@@setData -->
<!-- $$$setMap[overload1]$$$setMapconstQModbusDataUnitMap& -->
<h3 class="fn" translate="no" id="setMap"><code translate="no">[virtual] </code><span class="type">bool</span> QModbusServer::<span class="name">setMap</span>(const <span class="type"><a href="qmodbusdataunit.html#QModbusDataUnitMap-typedef" translate="no">QModbusDataUnitMap</a></span> &amp;<i>map</i>)</h3>
<p>Sets the registered map structure for requests from other ModBus clients to <i translate="no">map</i>. The register values are initialized with zero. Returns <code translate="no">true</code> on success; otherwise <code translate="no">false</code>.</p>
<p>If this function is not called before connecting, a default register with zero entries is setup.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function discards any register value that was previously set.</p>
</div>
<!-- @@@setMap -->
<!-- $$$setServerAddress[overload1]$$$setServerAddressint -->
<h3 class="fn" translate="no" id="setServerAddress"><span class="type">void</span> QModbusServer::<span class="name">setServerAddress</span>(<span class="type">int</span> <i>serverAddress</i>)</h3>
<p>Sets the address for this Modbus server instance to <i translate="no">serverAddress</i>.</p>
<p><b>See also </b><a href="qmodbusserver.html#serverAddress" translate="no">serverAddress</a>().</p>
<!-- @@@setServerAddress -->
<!-- $$$setValue[overload1]$$$setValueintconstQVariant& -->
<h3 class="fn" translate="no" id="setValue"><code translate="no">[virtual] </code><span class="type">bool</span> QModbusServer::<span class="name">setValue</span>(<span class="type">int</span> <i>option</i>, const <span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span> &amp;<i>newValue</i>)</h3>
<p>Sets the <i translate="no">newValue</i> for <i translate="no">option</i> and returns <code translate="no">true</code> on success; <code translate="no">false</code> otherwise.</p>
<div class="admonition note">
<p><b>Note: </b>If the option's associated type is <code translate="no">quint8</code> or <code translate="no">quint16</code> and the type of <i translate="no">newValue</i> is larger, the data will be truncated or conversation will fail.</p>
</div>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Key</th><th >Description</th></tr></thead>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::DiagnosticRegister</a></td><td >Sets the diagnostic register of the server in a device specific encoding to <i translate="no">newValue</i>. The default value preset is <code translate="no">0x0000</code>. The bit values of the register need device specific documentation.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::ExceptionStatusOffset</a></td><td >Sets the exception status byte offset of the server to <i translate="no">newValue</i> which is the absolute offset address in the coils (0x register). Modbus register table starting with <code translate="no">0x0000h</code>. The default value preset is <code translate="no">0x0000</code>, using the exception status coils similar to Modicon 984 CPUs (coils 1-8).<p>The function returns <code translate="no">true</code> if the coils register contains the 8 bits required for storing and retrieving the status coils, otherwise <code translate="no">false</code>.</p>
</td></tr>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::DeviceBusy</a></td><td >Sets a flag that signals that the server is engaged in processing a long-duration program command. Valid values are <code translate="no">0x0000</code> (not busy) and <code translate="no">0xffff</code> (busy). The default value preset is <code translate="no">0x0000</code>.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::AsciiInputDelimiter</a></td><td >The <i translate="no">newValue</i> becomes the end of message delimiter for future Modbus ASCII messages. The default value preset is <code translate="no">\n</code>.</td></tr>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::ListenOnlyMode</a></td><td >Ss the server's listen only state to <i translate="no">newValue</i>. If listen only mode is set to <code translate="no">true</code>, messages are monitored but no response will be sent. The default value preset is <code translate="no">false</code>.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::ServerIdentifier</a></td><td >Sets the server's manufacturer identifier to <i translate="no">newValue</i>. Possible values are in the range of <code translate="no">0x00</code> to 0xff. The default value preset is <code translate="no">0x0a</code>.</td></tr>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::RunIndicatorStatus</a></td><td >Sets the servers' run indicator status to <i translate="no">newValue</i>. This data is used as addendum by the <a href="qmodbuspdu.html#FunctionCode-enum" translate="no">QModbusPdu::ReportServerId</a> function code. Valid values are <code translate="no">0x00</code> (OFF) and <code translate="no">0xff</code> (ON). The default value preset is <code translate="no">0xff</code> (ON).</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::AdditionalData</a></td><td >Sets the server's additional data to <i translate="no">newValue</i>. This data is used as addendum by the <a href="qmodbuspdu.html#FunctionCode-enum" translate="no">QModbusPdu::ReportServerId</a> function code. The maximum data size cannot exceed 249 bytes to match response message size restrictions. The default value preset is <code translate="no">Qt Modbus Server</code>.</td></tr>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::DeviceIdentification</a></td><td >Sets the server's physical and functional description. By default there is no additional device identification data set.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::UserOption</a></td><td >Sets the value of a user option to <i translate="no">newValue</i>.<div class="admonition note">
<p><b>Note: </b>For user options, it is up to the developer to decide which types to use and ensure that components use the correct types when accessing and setting values.</p>
</div>
</td></tr>
</table></div>
<p><b>See also </b><a href="qmodbusserver.html#value" translate="no">value</a>().</p>
<!-- @@@setValue -->
<!-- $$$value[overload1]$$$valueint -->
<h3 class="fn" translate="no" id="value"><code translate="no">[virtual] </code><span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span> QModbusServer::<span class="name">value</span>(<span class="type">int</span> <i>option</i>) const</h3>
<p>Returns the value for <i translate="no">option</i> or an invalid <code translate="no">QVariant</code> if the option is not set.</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Option</th><th >Description</th></tr></thead>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::DiagnosticRegister</a></td><td >Returns the diagnostic register value of the server. The diagnostic register contains device specific contents where each bit has a specific meaning.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::ExceptionStatusOffset</a></td><td >Returns the offset address of the exception status byte location in the coils register.</td></tr>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::DeviceBusy</a></td><td >Returns a flag that signals if the server is engaged in processing a long-duration program command.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::AsciiInputDelimiter</a></td><td >Returns a end of message delimiter of Modbus ASCII messages.</td></tr>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::ListenOnlyMode</a></td><td >Returns the server's listen only state. Messages are monitored but no response will be sent.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::ServerIdentifier</a></td><td >Returns the server manufacturer's identifier code. This can be an arbitrary value in the range of <code translate="no">0x00</code> to 0xff.</td></tr>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::RunIndicatorStatus</a></td><td >Returns the server's run indicator status. This data is used as addendum by the <a href="qmodbuspdu.html#FunctionCode-enum" translate="no">QModbusPdu::ReportServerId</a> function code.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::AdditionalData</a></td><td >Returns the server's additional data. This data is used as addendum by the <a href="qmodbuspdu.html#FunctionCode-enum" translate="no">QModbusPdu::ReportServerId</a> function code.</td></tr>
<tr valign="top" class="odd"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::DeviceIdentification</a></td><td >Returns the server's physical and functional description.</td></tr>
<tr valign="top" class="even"><td ><a href="qmodbusserver.html#Option-enum" translate="no">QModbusServer::UserOption</a></td><td >Returns the value of a user option.<div class="admonition note">
<p><b>Note: </b>For user options, it is up to the developer to decide which types to use and ensure that components use the correct types when accessing and setting values.</p>
</div>
</td></tr>
</table></div>
<p><b>See also </b><a href="qmodbusserver.html#setValue" translate="no">setValue</a>().</p>
<!-- @@@value -->
<!-- $$$writeData[overload1]$$$writeDataconstQModbusDataUnit& -->
<h3 class="fn" translate="no" id="writeData"><code translate="no">[virtual protected] </code><span class="type">bool</span> QModbusServer::<span class="name">writeData</span>(const <span class="type"><a href="qmodbusdataunit.html" translate="no">QModbusDataUnit</a></span> &amp;<i>newData</i>)</h3>
<p>Writes <i translate="no">newData</i> to the Modbus server map. Returns <code translate="no">true</code> on success, or <code translate="no">false</code> if the <i translate="no">newData</i> range is outside of the map range or the registerType() does not exist.</p>
<div class="admonition note">
<p><b>Note: </b>Sub-classes that implement writing to a different backing store then default one, also need to implement <a href="qmodbusserver.html#setMap" translate="no">setMap</a>() and <a href="qmodbusserver.html#readData" translate="no">readData</a>(). The <a href="qmodbusserver.html#dataWritten" translate="no">dataWritten</a>() signal needs to be emitted from within the functions implementation as well.</p>
</div>
<p><b>See also </b><a href="qmodbusserver.html#setMap" translate="no">setMap</a>(), <a href="qmodbusserver.html#readData" translate="no">readData</a>(), and <a href="qmodbusserver.html#dataWritten" translate="no">dataWritten</a>().</p>
<!-- @@@writeData -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
