<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qcanbusdevice.cpp -->
  <meta name="description" content="The QCanBusDevice class is the interface class for CAN bus.">
  <title>QCanBusDevice Class | Qt Serial Bus 6.6.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.6</a></li>
<li><a href="qtserialbus-index.html" translate="no">Qt Serial Bus</a></li>
<li><a href="qtserialbus-module.html" translate="no">C++ Classes</a></li>
<li>QCanBusDevice</li>
<li id="buildversion"><a href="qtserialbus-index.html" translate="no">Qt 6.6&#x2e;0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QCanBusDevice Class</h1>
<!-- $$$QCanBusDevice-brief -->
<p>The QCanBusDevice class is the interface class for CAN bus. <a href="#details">More...</a></p>
<!-- @@@QCanBusDevice -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QCanBusDevice&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS SerialBus) <br/>
target_link_libraries(mytarget PRIVATE Qt6::SerialBus)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += serialbus</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html" translate="no">QObject</a></td></tr>
</table></div>
<ul>
<li><a href="qcanbusdevice-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> struct </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice-filter.html" translate="no">Filter</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#CanBusDeviceState-enum" translate="no">CanBusDeviceState</a></b> { UnconnectedState, ConnectingState, ConnectedState, ClosingState }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#CanBusError-enum" translate="no">CanBusError</a></b> { NoError, ReadError, WriteError, ConnectionError, ConfigurationError, &hellip;, TimeoutError }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum class </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#CanBusStatus-enum" translate="no">CanBusStatus</a></b> { Unknown, Good, Warning, Error, BusOff }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#ConfigurationKey-enum" translate="no">ConfigurationKey</a></b> { RawFilterKey, ErrorFilterKey, LoopbackKey, ReceiveOwnKey, BitRateKey, &hellip;, UserKey }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#Direction-enum" translate="no">Direction</a></b> { Input, Output, AllDirections }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#Direction-enum" translate="no">Directions</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#QCanBusDevice-1" translate="no">QCanBusDevice</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QCanBusDevice::CanBusStatus </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#busStatus" translate="no">busStatus</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#clear" translate="no">clear</a></b>(QCanBusDevice::Directions <i>direction</i> = Direction::AllDirections)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QCanBusDevice::ConfigurationKey&gt; </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#configurationKeys" translate="no">configurationKeys</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariant </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#configurationParameter" translate="no">configurationParameter</a></b>(QCanBusDevice::ConfigurationKey <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#connectDevice" translate="no">connectDevice</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QCanBusDeviceInfo </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#deviceInfo" translate="no">deviceInfo</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#disconnectDevice" translate="no">disconnectDevice</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCanBusDevice::CanBusError </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#error" translate="no">error</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#errorString" translate="no">errorString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#framesAvailable" translate="no">framesAvailable</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#framesToWrite" translate="no">framesToWrite</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#hasBusStatus" translate="no">hasBusStatus</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QString </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#interpretErrorFrame" translate="no">interpretErrorFrame</a></b>(const QCanBusFrame &amp;<i>frame</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QCanBusFrame&gt; </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#readAllFrames" translate="no">readAllFrames</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCanBusFrame </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#readFrame" translate="no">readFrame</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#resetController" translate="no">resetController</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#setConfigurationParameter" translate="no">setConfigurationParameter</a></b>(QCanBusDevice::ConfigurationKey <i>key</i>, const QVariant &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCanBusDevice::CanBusDeviceState </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#state" translate="no">state</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#waitForFramesReceived" translate="no">waitForFramesReceived</a></b>(int <i>msecs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#waitForFramesWritten" translate="no">waitForFramesWritten</a></b>(int <i>msecs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#writeFrame" translate="no">writeFrame</a></b>(const QCanBusFrame &amp;<i>frame</i>) = 0</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#errorOccurred" translate="no">errorOccurred</a></b>(QCanBusDevice::CanBusError)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#framesReceived" translate="no">framesReceived</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#framesWritten" translate="no">framesWritten</a></b>(qint64 <i>framesCount</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#stateChanged" translate="no">stateChanged</a></b>(QCanBusDevice::CanBusDeviceState <i>state</i>)</td></tr>
</table></div>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#clearError" translate="no">clearError</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#close" translate="no">close</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCanBusFrame </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#dequeueOutgoingFrame" translate="no">dequeueOutgoingFrame</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#enqueueOutgoingFrame" translate="no">enqueueOutgoingFrame</a></b>(const QCanBusFrame &amp;<i>newFrame</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#enqueueReceivedFrames" translate="no">enqueueReceivedFrames</a></b>(const QList&lt;QCanBusFrame&gt; &amp;<i>newFrames</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#hasOutgoingFrames" translate="no">hasOutgoingFrames</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#open" translate="no">open</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#setError" translate="no">setError</a></b>(const QString &amp;<i>errorText</i>, QCanBusDevice::CanBusError <i>errorId</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qcanbusdevice.html#setState" translate="no">setState</a></b>(QCanBusDevice::CanBusDeviceState <i>newState</i>)</td></tr>
</table></div>
<!-- $$$QCanBusDevice-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>QCanBusDevice communicates with a CAN plugin providing users with a convenient API. The CAN plugin must be specified during the object creation.</p>
</div>
<!-- @@@QCanBusDevice -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$CanBusDeviceState$$$UnconnectedState$$$ConnectingState$$$ConnectedState$$$ClosingState -->
<h3 class="fn" translate="no" id="CanBusDeviceState-enum">enum QCanBusDevice::<span class="name">CanBusDeviceState</span></h3>
<p>This enum describes all possible device states.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::UnconnectedState</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The device is disconnected.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::ConnectingState</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The device is being connected.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::ConnectedState</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The device is connected to the CAN bus.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::ClosingState</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">The device is being closed.</td></tr>
</table></div>
<!-- @@@CanBusDeviceState -->
<!-- $$$CanBusError$$$NoError$$$ReadError$$$WriteError$$$ConnectionError$$$ConfigurationError$$$UnknownError$$$OperationError$$$TimeoutError -->
<h3 class="fn" translate="no" id="CanBusError-enum">enum QCanBusDevice::<span class="name">CanBusError</span></h3>
<p>This enum describes all the possible error conditions.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::NoError</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">No errors have occurred.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::ReadError</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">An error occurred during a read operation.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::WriteError</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">An error occurred during a write operation.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::ConnectionError</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">An error occurred when attempting to open the plugin.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::ConfigurationError</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">An error occurred when attempting to set a configuration parameter.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::UnknownError</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">An unknown error occurred.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::OperationError</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">An operation was attempted while the device was in a state that did not permit it. This enum was introduced in Qt 5.14.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::TimeoutError</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">An timeout occurred while waiting for frames written or received. This enum was introduced in Qt 5.14.</td></tr>
</table></div>
<!-- @@@CanBusError -->
<!-- $$$CanBusStatus$$$Unknown$$$Good$$$Warning$$$Error$$$BusOff -->
<h3 class="fn" translate="no" id="CanBusStatus-enum">enum class QCanBusDevice::<span class="name">CanBusStatus</span></h3>
<p>This enum describes possible CAN bus status values.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::CanBusStatus::Unknown</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The CAN bus status is unknown (e.g&#x2e; not supported by the CAN plugin).</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::CanBusStatus::Good</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The CAN controller is fully operational</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::CanBusStatus::Warning</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The CAN controller is in warning status</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::CanBusStatus::Error</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">The CAN controller is in error status (no longer sending CAN frames)</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::CanBusStatus::BusOff</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">The CAN controller is in bus off status (disconnected from the CAN bus)</td></tr>
</table></div>
<!-- @@@CanBusStatus -->
<!-- $$$ConfigurationKey$$$RawFilterKey$$$ErrorFilterKey$$$LoopbackKey$$$ReceiveOwnKey$$$BitRateKey$$$CanFdKey$$$DataBitRateKey$$$ProtocolKey$$$UserKey -->
<h3 class="fn" translate="no" id="ConfigurationKey-enum">enum QCanBusDevice::<span class="name">ConfigurationKey</span></h3>
<p>This enum describes the possible configuration options for the CAN bus connection.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::RawFilterKey</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">This configuration determines the type of CAN bus frames that the current device accepts. The expected value is <code translate="no">QList&lt;QCanBusDevice::Filter&gt;</code>. Passing an empty list clears all previously set filters including default filters. For more details see <a href="qcanbusdevice-filter.html" translate="no">QCanBusDevice::Filter</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::ErrorFilterKey</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">This key defines the type of error that should be forwarded via the current connection. The associated value should be of type <a href="qcanbusframe.html#FrameError-enum" translate="no">QCanBusFrame::FrameErrors</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::LoopbackKey</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">This key defines whether the CAN bus device should operate in loopback mode. Loopback means, whenever a CAN frame is transmitted on the CAN bus, a local echo of this frame is sent to all applications connected to this CAN device. The expected value for this key is <code translate="no">bool</code>.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::ReceiveOwnKey</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">This key defines whether this CAN device receives its own send frames. This can be used to check if the transmission was successful. The expected value for this key is <code translate="no">bool</code>.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::BitRateKey</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">This key defines the CAN bitrate in bits per second. With CAN FD, the payload can be transmitted at a higher data bitrate, if <a href="qcanbusframe.html#hasBitrateSwitch" translate="no">QCanBusFrame::hasBitrateSwitch</a>() is set. In this case, <code translate="no">QCanBusDevice::BitRateKey</code> is only used for the CAN ID arbitration phase. See also <code translate="no">QCanBusDevice::DataBitRateKey</code></td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::CanFdKey</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">This key defines whether sending and receiving of CAN FD frames should be enabled. The expected value for this key is <code translate="no">bool</code>.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::DataBitRateKey</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">This key defines the CAN FD payload bitrate in bits per second. CAN FD allows to transmit the payload of frames with <a href="qcanbusframe.html#hasBitrateSwitch" translate="no">QCanBusFrame::hasBitrateSwitch</a>() flag at a higher data bitrate, after the arbitration phase at the nominal bitrate is finished. This enum value was introduced in Qt 5.9&#x2e; See also <code translate="no">QCanBusDevice::BitRateKey</code></td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::ProtocolKey</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">This key allows to specify another protocol. For now, this parameter can only be set and used in the SocketCAN plugin. This enum value was introduced in Qt 5.14.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::UserKey</code></td><td class="topAlign tblval"><code translate="no">30</code></td><td class="topAlign">This key defines the range where custom keys start. Its most common purpose is to permit platform-specific configuration options.</td></tr>
</table></div>
<p><b>See also </b><a href="qcanbusdevice.html#configurationParameter" translate="no">configurationParameter</a>().</p>
<!-- @@@ConfigurationKey -->
<!-- $$$Direction$$$Input$$$Output$$$AllDirections -->
<h3 class="flags" id="Direction-enum">enum QCanBusDevice::<span class="name">Direction</span><br/>flags QCanBusDevice::<span class="name">Directions</span></h3>
<p>This enum describes possible data transmission directions.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::Input</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Input direction.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::Output</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Output direction.</td></tr>
<tr><td class="topAlign"><code translate="no">QCanBusDevice::AllDirections</code></td><td class="topAlign tblval"><code translate="no">Input | Output</code></td><td class="topAlign">Both directions, input and output.</td></tr>
</table></div>
<p>The Directions type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;Direction&gt;. It stores an OR combination of Direction values.</p>
<!-- @@@Direction -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QCanBusDevice$$$QCanBusDeviceQObject* -->
<h3 class="fn" translate="no" id="QCanBusDevice-1"><code translate="no">[explicit] </code>QCanBusDevice::<span class="name">QCanBusDevice</span>(<span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a serial bus device with the specified <i translate="no">parent</i>.</p>
<!-- @@@QCanBusDevice -->
<!-- $$$busStatus[overload1]$$$busStatus -->
<h3 class="fn" translate="no" id="busStatus"><code translate="no">[virtual] </code><span class="type"><a href="qcanbusdevice.html#CanBusStatus-enum" translate="no">QCanBusDevice::CanBusStatus</a></span> QCanBusDevice::<span class="name">busStatus</span>()</h3>
<p>Returns the current CAN bus status. If the status cannot be requested, QCanBusDevice::UnknownStatus is returned.</p>
<div class="admonition note">
<p><b>Note: </b>This function may not be implemented in all CAN plugins. Please refer to the plugins help pages for more information. The function <a href="qcanbusdevice.html#hasBusStatus" translate="no">hasBusStatus</a>() can be used at runtime to check if the used CAN plugin has support for requesting the CAN bus status.</p>
</div>
<p><b>See also </b><a href="qcanbusdevice.html#hasBusStatus" translate="no">hasBusStatus</a>() and <a href="qcanbusdevice.html#resetController" translate="no">resetController</a>().</p>
<!-- @@@busStatus -->
<!-- $$$clear[overload1]$$$clearQCanBusDevice::Directions -->
<h3 class="fn" translate="no" id="clear"><span class="type">void</span> QCanBusDevice::<span class="name">clear</span>(<span class="type"><a href="qcanbusdevice.html#Direction-enum" translate="no">QCanBusDevice::Directions</a></span> <i>direction</i> = Direction::AllDirections)</h3>
<p>Clears the devices input or output buffers, depending on <i translate="no">direction</i>.</p>
<p>This function only operates on <a href="qcanbusdevice.html" translate="no">QCanBusDevice</a> buffers. Frames that are already written to the CAN driver or CAN hardware layer, or that are not yet read from these layers, are not cleared by this function.</p>
<div class="admonition note">
<p><b>Note: </b>Clearing the output buffers is only possible for buffered devices.</p>
</div>
<p><b>See also </b><a href="qcanbusdevice.html#framesAvailable" translate="no">framesAvailable</a>(), <a href="qcanbusdevice.html#readFrame" translate="no">readFrame</a>(), <a href="qcanbusdevice.html#framesToWrite" translate="no">framesToWrite</a>(), and <a href="qcanbusdevice.html#writeFrame" translate="no">writeFrame</a>().</p>
<!-- @@@clear -->
<!-- $$$clearError[overload1]$$$clearError -->
<h3 class="fn" translate="no" id="clearError"><code translate="no">[protected] </code><span class="type">void</span> QCanBusDevice::<span class="name">clearError</span>()</h3>
<p>Clears the error id and the human readable description of the last device error.</p>
<p>CAN bus implementations must use this function to update the device's error state.</p>
<p><b>See also </b><a href="qcanbusdevice.html#error" translate="no">error</a>(), <a href="qcanbusdevice.html#errorOccurred" translate="no">errorOccurred</a>(), and <a href="qcanbusdevice.html#setError" translate="no">setError</a>().</p>
<!-- @@@clearError -->
<!-- $$$close[overload1]$$$close -->
<h3 class="fn" translate="no" id="close"><code translate="no">[pure virtual protected] </code><span class="type">void</span> QCanBusDevice::<span class="name">close</span>()</h3>
<p>This function is responsible for closing the CAN bus connection. The implementation must ensure that the instance's <a href="qcanbusdevice.html#state" translate="no">state</a>() is set to <a href="qcanbusdevice.html#CanBusDeviceState-enum" translate="no">QCanBusDevice::UnconnectedState</a>.</p>
<p>This function's most important task is to close the socket to the CAN device and to call <a href="qcanbusdevice.html#setState" translate="no">QCanBusDevice::setState</a>().</p>
<p><b>See also </b><a href="qcanbusdevice.html#disconnectDevice" translate="no">disconnectDevice</a>().</p>
<!-- @@@close -->
<!-- $$$configurationKeys[overload1]$$$configurationKeys -->
<h3 class="fn" translate="no" id="configurationKeys"><span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qcanbusdevice.html#ConfigurationKey-enum" translate="no">QCanBusDevice::ConfigurationKey</a></span>&gt; QCanBusDevice::<span class="name">configurationKeys</span>() const</h3>
<p>Returns the list of keys used by the CAN bus connection.</p>
<p>The meaning of the keys is equivalent to <a href="qcanbusdevice.html#ConfigurationKey-enum" translate="no">ConfigurationKey</a>. If a key is not explicitly mentioned, the platform's default setting for the relevant key is used.</p>
<!-- @@@configurationKeys -->
<!-- $$$configurationParameter[overload1]$$$configurationParameterQCanBusDevice::ConfigurationKey -->
<h3 class="fn" translate="no" id="configurationParameter"><span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span> QCanBusDevice::<span class="name">configurationParameter</span>(<span class="type"><a href="qcanbusdevice.html#ConfigurationKey-enum" translate="no">QCanBusDevice::ConfigurationKey</a></span> <i>key</i>) const</h3>
<p>Returns the current value assigned to the <a href="qcanbusdevice.html#ConfigurationKey-enum" translate="no">ConfigurationKey</a> <i translate="no">key</i>; otherwise an invalid <a href="../qtcore/qvariant.html" translate="no">QVariant</a>.</p>
<p><b>See also </b><a href="qcanbusdevice.html#setConfigurationParameter" translate="no">setConfigurationParameter</a>() and <a href="qcanbusdevice.html#configurationKeys" translate="no">configurationKeys</a>().</p>
<!-- @@@configurationParameter -->
<!-- $$$connectDevice[overload1]$$$connectDevice -->
<h3 class="fn" translate="no" id="connectDevice"><span class="type">bool</span> QCanBusDevice::<span class="name">connectDevice</span>()</h3>
<p>Connects the device to the CAN bus. Returns <code translate="no">true</code> on success; otherwise <code translate="no">false</code>.</p>
<p>This function calls <a href="qcanbusdevice.html#open" translate="no">open</a>() as part of its implementation.</p>
<p><b>See also </b><a href="qcanbusdevice.html#disconnectDevice" translate="no">disconnectDevice</a>().</p>
<!-- @@@connectDevice -->
<!-- $$$dequeueOutgoingFrame[overload1]$$$dequeueOutgoingFrame -->
<h3 class="fn" translate="no" id="dequeueOutgoingFrame"><code translate="no">[protected] </code><span class="type"><a href="qcanbusframe.html" translate="no">QCanBusFrame</a></span> QCanBusDevice::<span class="name">dequeueOutgoingFrame</span>()</h3>
<p>Returns the next <a href="qcanbusframe.html" translate="no">QCanBusFrame</a> from the internal list of outgoing frames; otherwise returns an invalid <a href="qcanbusframe.html" translate="no">QCanBusFrame</a>. The returned frame is removed from the internal list.</p>
<!-- @@@dequeueOutgoingFrame -->
<!-- $$$deviceInfo[overload1]$$$deviceInfo -->
<h3 class="fn" translate="no" id="deviceInfo"><code translate="no">[virtual, since 6.2] </code><span class="type"><a href="qcanbusdeviceinfo.html" translate="no">QCanBusDeviceInfo</a></span> QCanBusDevice::<span class="name">deviceInfo</span>() const</h3>
<p>Returns a <a href="qcanbusdeviceinfo.html" translate="no">QCanBusDeviceInfo</a> for the current <a href="qcanbusdevice.html" translate="no">QCanBusDevice</a>. If the function is not implemented by a sub-class of <a href="qcanbusdevice.html" translate="no">QCanBusDevice</a>, a default constructed object is returned.</p>
<p>This function was introduced in Qt 6.2.</p>
<!-- @@@deviceInfo -->
<!-- $$$disconnectDevice[overload1]$$$disconnectDevice -->
<h3 class="fn" translate="no" id="disconnectDevice"><span class="type">void</span> QCanBusDevice::<span class="name">disconnectDevice</span>()</h3>
<p>Disconnects the device from the CAN bus.</p>
<p>This function calls <a href="qcanbusdevice.html#close" translate="no">close</a>() as part of its implementation.</p>
<div class="admonition note">
<p><b>Note: </b>This function should only be called, if <a href="qcanbusdevice.html#connectDevice" translate="no">connectDevice</a>() returned <code translate="no">true</code>.</p>
</div>
<p><b>See also </b><a href="qcanbusdevice.html#connectDevice" translate="no">connectDevice</a>().</p>
<!-- @@@disconnectDevice -->
<!-- $$$enqueueOutgoingFrame[overload1]$$$enqueueOutgoingFrameconstQCanBusFrame& -->
<h3 class="fn" translate="no" id="enqueueOutgoingFrame"><code translate="no">[protected] </code><span class="type">void</span> QCanBusDevice::<span class="name">enqueueOutgoingFrame</span>(const <span class="type"><a href="qcanbusframe.html" translate="no">QCanBusFrame</a></span> &amp;<i>newFrame</i>)</h3>
<p>Appends <i translate="no">newFrame</i> to the internal list of outgoing frames which can be accessed by <a href="qcanbusdevice.html#writeFrame" translate="no">writeFrame</a>().</p>
<p>Subclasses must call this function when they write a new frame.</p>
<!-- @@@enqueueOutgoingFrame -->
<!-- $$$enqueueReceivedFrames[overload1]$$$enqueueReceivedFramesconstQList<QCanBusFrame>& -->
<h3 class="fn" translate="no" id="enqueueReceivedFrames"><code translate="no">[protected] </code><span class="type">void</span> QCanBusDevice::<span class="name">enqueueReceivedFrames</span>(const <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qcanbusframe.html" translate="no">QCanBusFrame</a></span>&gt; &amp;<i>newFrames</i>)</h3>
<p>Appends <i translate="no">newFrames</i> to the internal list of frames which can be accessed using <a href="qcanbusdevice.html#readFrame" translate="no">readFrame</a>() and emits the <a href="qcanbusdevice.html#framesReceived" translate="no">framesReceived</a>() signal.</p>
<p>Subclasses must call this function when they receive frames.</p>
<!-- @@@enqueueReceivedFrames -->
<!-- $$$error[overload1]$$$error -->
<h3 class="fn" translate="no" id="error"><span class="type"><a href="qcanbusdevice.html#CanBusError-enum" translate="no">QCanBusDevice::CanBusError</a></span> QCanBusDevice::<span class="name">error</span>() const</h3>
<p>Returns the last error that has occurred. The error value is always set to last error that occurred and it is never reset.</p>
<p><b>See also </b><a href="qcanbusdevice.html#setError" translate="no">setError</a>() and <a href="qcanbusdevice.html#errorString" translate="no">errorString</a>().</p>
<!-- @@@error -->
<!-- $$$errorOccurred[overload1]$$$errorOccurredQCanBusDevice::CanBusError -->
<h3 class="fn" translate="no" id="errorOccurred"><code translate="no">[signal] </code><span class="type">void</span> QCanBusDevice::<span class="name">errorOccurred</span>(<span class="type"><a href="qcanbusdevice.html#CanBusError-enum" translate="no">QCanBusDevice::CanBusError</a></span>)</h3>
<p>This signal is emitted when an error occurs.</p>
<!-- @@@errorOccurred -->
<!-- $$$errorString[overload1]$$$errorString -->
<h3 class="fn" translate="no" id="errorString"><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QCanBusDevice::<span class="name">errorString</span>() const</h3>
<p>Returns a human-readable description of the last device error that occurred.</p>
<p><b>See also </b><a href="qcanbusdevice.html#error" translate="no">error</a>().</p>
<!-- @@@errorString -->
<!-- $$$framesAvailable[overload1]$$$framesAvailable -->
<h3 class="fn" translate="no" id="framesAvailable"><span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QCanBusDevice::<span class="name">framesAvailable</span>() const</h3>
<p>Returns the number of available frames. If no frames are available, this function returns 0.</p>
<p><b>See also </b><a href="qcanbusdevice.html#clear" translate="no">clear</a>(), <a href="qcanbusdevice.html#readFrame" translate="no">readFrame</a>(), and <a href="qcanbusdevice.html#readAllFrames" translate="no">readAllFrames</a>().</p>
<!-- @@@framesAvailable -->
<!-- $$$framesReceived[overload1]$$$framesReceived -->
<h3 class="fn" translate="no" id="framesReceived"><code translate="no">[signal] </code><span class="type">void</span> QCanBusDevice::<span class="name">framesReceived</span>()</h3>
<p>This signal is emitted when one or more frames have been received. The frames should be read using <a href="qcanbusdevice.html#readFrame" translate="no">readFrame</a>() and <a href="qcanbusdevice.html#framesAvailable" translate="no">framesAvailable</a>().</p>
<!-- @@@framesReceived -->
<!-- $$$framesToWrite[overload1]$$$framesToWrite -->
<h3 class="fn" translate="no" id="framesToWrite"><span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> QCanBusDevice::<span class="name">framesToWrite</span>() const</h3>
<p>For buffered devices, this function returns the number of frames waiting to be written. For unbuffered devices, this function always returns zero.</p>
<div class="admonition note">
<p><b>Note: </b>There may be additional buffering in the CAN driver and CAN hardware layer. Therefore, if this function returns zero, that does not mean all CAN frames are already written to the CAN bus.</p>
</div>
<p><b>See also </b><a href="qcanbusdevice.html#clear" translate="no">clear</a>() and <a href="qcanbusdevice.html#writeFrame" translate="no">writeFrame</a>().</p>
<!-- @@@framesToWrite -->
<!-- $$$framesWritten[overload1]$$$framesWrittenqint64 -->
<h3 class="fn" translate="no" id="framesWritten"><code translate="no">[signal] </code><span class="type">void</span> QCanBusDevice::<span class="name">framesWritten</span>(<span class="type"><a href="../qtcore/qttypes.html#qint64-typedef" translate="no">qint64</a></span> <i>framesCount</i>)</h3>
<p>This signal is emitted every time a payload of frames has been written to the CAN bus. The <i translate="no">framesCount</i> argument is set to the number of frames that were written in this payload.</p>
<!-- @@@framesWritten -->
<!-- $$$hasBusStatus[overload1]$$$hasBusStatus -->
<h3 class="fn" translate="no" id="hasBusStatus"><code translate="no">[virtual] </code><span class="type">bool</span> QCanBusDevice::<span class="name">hasBusStatus</span>() const</h3>
<p>Return true, if the CAN plugin supports requesting the CAN bus status.</p>
<p><b>See also </b><a href="qcanbusdevice.html#busStatus" translate="no">busStatus</a>().</p>
<!-- @@@hasBusStatus -->
<!-- $$$hasOutgoingFrames[overload1]$$$hasOutgoingFrames -->
<h3 class="fn" translate="no" id="hasOutgoingFrames"><code translate="no">[protected] </code><span class="type">bool</span> QCanBusDevice::<span class="name">hasOutgoingFrames</span>() const</h3>
<p>Returns <code translate="no">true</code> if the internal list of outgoing frames is not empty; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@hasOutgoingFrames -->
<!-- $$$interpretErrorFrame[overload1]$$$interpretErrorFrameconstQCanBusFrame& -->
<h3 class="fn" translate="no" id="interpretErrorFrame"><code translate="no">[pure virtual] </code><span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> QCanBusDevice::<span class="name">interpretErrorFrame</span>(const <span class="type"><a href="qcanbusframe.html" translate="no">QCanBusFrame</a></span> &amp;<i>frame</i>)</h3>
<p>Interprets <i translate="no">frame</i> as error frame and returns a human readable description of the error.</p>
<p>If <i translate="no">frame</i> is not an error frame, the returned string is empty.</p>
<!-- @@@interpretErrorFrame -->
<!-- $$$open[overload1]$$$open -->
<h3 class="fn" translate="no" id="open"><code translate="no">[pure virtual protected] </code><span class="type">bool</span> QCanBusDevice::<span class="name">open</span>()</h3>
<p>This function is called by <a href="qcanbusdevice.html#connectDevice" translate="no">connectDevice</a>(). Subclasses must provide an implementation which returns <code translate="no">true</code> if the CAN bus connection could be established; otherwise <code translate="no">false</code>. The <a href="qcanbusdevice.html" translate="no">QCanBusDevice</a> implementation ensures upon entry of this function that the device's <a href="qcanbusdevice.html#state" translate="no">state</a>() is set to <a href="qcanbusdevice.html#CanBusDeviceState-enum" translate="no">QCanBusDevice::ConnectingState</a> already.</p>
<p>The implementation must ensure that upon success the instance's <a href="qcanbusdevice.html#state" translate="no">state</a>() is set to <a href="qcanbusdevice.html#CanBusDeviceState-enum" translate="no">QCanBusDevice::ConnectedState</a>; otherwise <a href="qcanbusdevice.html#CanBusDeviceState-enum" translate="no">QCanBusDevice::UnconnectedState</a>. <a href="qcanbusdevice.html#setState" translate="no">setState</a>() must be used to set the new device state.</p>
<p>The custom implementation is responsible for opening the socket, instanciation of a potentially required <a href="../qtcore/qsocketnotifier.html" translate="no">QSocketNotifier</a> and the application of custom and default <a href="qcanbusdevice.html#configurationParameter" translate="no">QCanBusDevice::configurationParameter</a>().</p>
<p><b>See also </b><a href="qcanbusdevice.html#connectDevice" translate="no">connectDevice</a>().</p>
<!-- @@@open -->
<!-- $$$readAllFrames[overload1]$$$readAllFrames -->
<h3 class="fn" translate="no" id="readAllFrames"><span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qcanbusframe.html" translate="no">QCanBusFrame</a></span>&gt; QCanBusDevice::<span class="name">readAllFrames</span>()</h3>
<p>Returns all <a href="qcanbusframe.html" translate="no">QCanBusFrame</a>s from the queue; otherwise returns an empty <a href="../qtcore/qlist.html" translate="no">QList</a>. The returned frames are removed from the queue.</p>
<p>The queue operates according to the FIFO principle.</p>
<p><b>See also </b><a href="qcanbusdevice.html#clear" translate="no">clear</a>(), <a href="qcanbusdevice.html#framesAvailable" translate="no">framesAvailable</a>(), and <a href="qcanbusdevice.html#readFrame" translate="no">readFrame</a>().</p>
<!-- @@@readAllFrames -->
<!-- $$$readFrame[overload1]$$$readFrame -->
<h3 class="fn" translate="no" id="readFrame"><span class="type"><a href="qcanbusframe.html" translate="no">QCanBusFrame</a></span> QCanBusDevice::<span class="name">readFrame</span>()</h3>
<p>Returns the next <a href="qcanbusframe.html" translate="no">QCanBusFrame</a> from the queue; otherwise returns an empty <a href="qcanbusframe.html" translate="no">QCanBusFrame</a>. The returned frame is removed from the queue.</p>
<p>The queue operates according to the FIFO principle.</p>
<p><b>See also </b><a href="qcanbusdevice.html#clear" translate="no">clear</a>(), <a href="qcanbusdevice.html#framesAvailable" translate="no">framesAvailable</a>(), and <a href="qcanbusdevice.html#readAllFrames" translate="no">readAllFrames</a>().</p>
<!-- @@@readFrame -->
<!-- $$$resetController[overload1]$$$resetController -->
<h3 class="fn" translate="no" id="resetController"><code translate="no">[virtual] </code><span class="type">void</span> QCanBusDevice::<span class="name">resetController</span>()</h3>
<p>Performs a CAN controller reset to release the CAN controller from bus off state, if possible.</p>
<div class="admonition note">
<p><b>Note: </b>CAN controller resets disturb the running communication and may take up to one second to complete. Only call this function to recover from bus errors.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function may not be implemented in all CAN plugins. Please refer to the plugins help pages for more information.</p>
</div>
<p><b>See also </b><a href="qcanbusdevice.html#busStatus" translate="no">busStatus</a>().</p>
<!-- @@@resetController -->
<!-- $$$setConfigurationParameter[overload1]$$$setConfigurationParameterQCanBusDevice::ConfigurationKeyconstQVariant& -->
<h3 class="fn" translate="no" id="setConfigurationParameter"><code translate="no">[virtual] </code><span class="type">void</span> QCanBusDevice::<span class="name">setConfigurationParameter</span>(<span class="type"><a href="qcanbusdevice.html#ConfigurationKey-enum" translate="no">QCanBusDevice::ConfigurationKey</a></span> <i>key</i>, const <span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span> &amp;<i>value</i>)</h3>
<p>Sets the configuration parameter <i translate="no">key</i> for the CAN bus connection to <i translate="no">value</i>. The potential keys are represented by <a href="qcanbusdevice.html#ConfigurationKey-enum" translate="no">ConfigurationKey</a>.</p>
<p>A parameter can be unset by setting an invalid <a href="../qtcore/qvariant.html" translate="no">QVariant</a>. Unsetting a parameter implies that the configuration is reset to its default setting.</p>
<div class="admonition note">
<p><b>Note: </b>In most cases, configuration changes only take effect after a reconnect.</p>
</div>
<p><b>See also </b><a href="qcanbusdevice.html#configurationParameter" translate="no">configurationParameter</a>().</p>
<!-- @@@setConfigurationParameter -->
<!-- $$$setError[overload1]$$$setErrorconstQString&QCanBusDevice::CanBusError -->
<h3 class="fn" translate="no" id="setError"><code translate="no">[protected] </code><span class="type">void</span> QCanBusDevice::<span class="name">setError</span>(const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> &amp;<i>errorText</i>, <span class="type"><a href="qcanbusdevice.html#CanBusError-enum" translate="no">QCanBusDevice::CanBusError</a></span> <i>errorId</i>)</h3>
<p>Sets the human readable description of the last device error to <i translate="no">errorText</i>. <i translate="no">errorId</i> categorizes the type of error.</p>
<p>CAN bus implementations must use this function to update the device's error state.</p>
<p><b>See also </b><a href="qcanbusdevice.html#error" translate="no">error</a>(), <a href="qcanbusdevice.html#errorOccurred" translate="no">errorOccurred</a>(), and <a href="qcanbusdevice.html#clearError" translate="no">clearError</a>().</p>
<!-- @@@setError -->
<!-- $$$setState[overload1]$$$setStateQCanBusDevice::CanBusDeviceState -->
<h3 class="fn" translate="no" id="setState"><code translate="no">[protected] </code><span class="type">void</span> QCanBusDevice::<span class="name">setState</span>(<span class="type"><a href="qcanbusdevice.html#CanBusDeviceState-enum" translate="no">QCanBusDevice::CanBusDeviceState</a></span> <i>newState</i>)</h3>
<p>Sets the state of the device to <i translate="no">newState</i>. CAN bus implementations must use this function to update the device state.</p>
<p><b>See also </b><a href="qcanbusdevice.html#state" translate="no">state</a>().</p>
<!-- @@@setState -->
<!-- $$$state[overload1]$$$state -->
<h3 class="fn" translate="no" id="state"><span class="type"><a href="qcanbusdevice.html#CanBusDeviceState-enum" translate="no">QCanBusDevice::CanBusDeviceState</a></span> QCanBusDevice::<span class="name">state</span>() const</h3>
<p>Returns the current state of the device.</p>
<p><b>See also </b><a href="qcanbusdevice.html#setState" translate="no">setState</a>() and <a href="qcanbusdevice.html#stateChanged" translate="no">stateChanged</a>().</p>
<!-- @@@state -->
<!-- $$$stateChanged[overload1]$$$stateChangedQCanBusDevice::CanBusDeviceState -->
<h3 class="fn" translate="no" id="stateChanged"><code translate="no">[signal] </code><span class="type">void</span> QCanBusDevice::<span class="name">stateChanged</span>(<span class="type"><a href="qcanbusdevice.html#CanBusDeviceState-enum" translate="no">QCanBusDevice::CanBusDeviceState</a></span> <i>state</i>)</h3>
<p>This signal is emitted every time the state of the device changes. The new state is represented by <i translate="no">state</i>.</p>
<p><b>See also </b><a href="qcanbusdevice.html#setState" translate="no">setState</a>() and <a href="qcanbusdevice.html#state" translate="no">state</a>().</p>
<!-- @@@stateChanged -->
<!-- $$$waitForFramesReceived[overload1]$$$waitForFramesReceivedint -->
<h3 class="fn" translate="no" id="waitForFramesReceived"><code translate="no">[virtual] </code><span class="type">bool</span> QCanBusDevice::<span class="name">waitForFramesReceived</span>(<span class="type">int</span> <i>msecs</i>)</h3>
<p>Blocks until new frames are available for reading and the <a href="qcanbusdevice.html#framesReceived" translate="no">framesReceived</a>() signal has been emitted, or until <i translate="no">msecs</i> milliseconds have passed. If <i translate="no">msecs</i> is <code translate="no">-1</code>, this function will not time out.</p>
<p>Returns <code translate="no">true</code> if new frames are available for reading and the <a href="qcanbusdevice.html#framesReceived" translate="no">framesReceived</a>() signal is emitted; otherwise returns <code translate="no">false</code> (if the operation timed out or if an error occurred).</p>
<div class="admonition note">
<p><b>Note: </b>This function will start a local event loop. This may lead to scenarios whereby other application slots may be called while the execution of this function scope is blocking. To avoid problems, the signals for this class should not be connected to slots. Similarly this function must never be called in response to the <a href="qcanbusdevice.html#framesReceived" translate="no">framesReceived</a>() or <a href="qcanbusdevice.html#errorOccurred" translate="no">errorOccurred</a>() signals.</p>
</div>
<p><b>See also </b><a href="qcanbusdevice.html#waitForFramesWritten" translate="no">waitForFramesWritten</a>().</p>
<!-- @@@waitForFramesReceived -->
<!-- $$$waitForFramesWritten[overload1]$$$waitForFramesWrittenint -->
<h3 class="fn" translate="no" id="waitForFramesWritten"><code translate="no">[virtual] </code><span class="type">bool</span> QCanBusDevice::<span class="name">waitForFramesWritten</span>(<span class="type">int</span> <i>msecs</i>)</h3>
<p>For buffered devices, this function waits until all buffered frames have been written to the device and the <a href="qcanbusdevice.html#framesWritten" translate="no">framesWritten</a>() signal has been emitted, or until <i translate="no">msecs</i> milliseconds have passed. If <i translate="no">msecs</i> is -1, this function will not time out. For unbuffered devices, it returns immediately with <code translate="no">false</code> as <a href="qcanbusdevice.html#writeFrame" translate="no">writeFrame</a>() does not require a write buffer.</p>
<p>Returns <code translate="no">true</code> if the <a href="qcanbusdevice.html#framesWritten" translate="no">framesWritten</a>() signal is emitted; otherwise returns <code translate="no">false</code> (i.e&#x2e; if the operation timed out, or if an error occurred).</p>
<div class="admonition note">
<p><b>Note: </b>This function will start a local event loop. This may lead to scenarios whereby other application slots may be called while the execution of this function scope is blocking. To avoid problems, the signals for this class should not be connected to slots. Similarly this function must never be called in response to the <a href="qcanbusdevice.html#framesWritten" translate="no">framesWritten</a>() or <a href="qcanbusdevice.html#errorOccurred" translate="no">errorOccurred</a>() signals.</p>
</div>
<p><b>See also </b><a href="qcanbusdevice.html#waitForFramesReceived" translate="no">waitForFramesReceived</a>().</p>
<!-- @@@waitForFramesWritten -->
<!-- $$$writeFrame[overload1]$$$writeFrameconstQCanBusFrame& -->
<h3 class="fn" translate="no" id="writeFrame"><code translate="no">[pure virtual] </code><span class="type">bool</span> QCanBusDevice::<span class="name">writeFrame</span>(const <span class="type"><a href="qcanbusframe.html" translate="no">QCanBusFrame</a></span> &amp;<i>frame</i>)</h3>
<p>Writes <i translate="no">frame</i> to the CAN bus and returns <code translate="no">true</code> on success; otherwise <code translate="no">false</code>.</p>
<p>On some platforms, the frame may be put into a queue and the return value may only indicate a successful insertion into the queue. The actual frame will be send later on. Therefore the <a href="qcanbusdevice.html#framesWritten" translate="no">framesWritten</a>() signal is the final confirmation that the frame has been handed off to the transport layer. If an error occurs the <a href="qcanbusdevice.html#errorOccurred" translate="no">errorOccurred</a>() is emitted.</p>
<p>As per CAN bus specification, frames of type <a href="qcanbusframe.html#FrameType-enum" translate="no">remote transfer request (RTR)</a> do not have a payload, but a length from 0 to 8 (including). This length indicates the expected response payload length from the remote party. Therefore when sending a RTR frame using this function it may still be required to set an arbitrary payload on <i translate="no">frame</i>. The length of the arbitrary payload is what is set as size expectation for the RTR frame.</p>
<p><b>See also </b><a href="qcanbusframe.html#setPayload" translate="no">QCanBusFrame::setPayload</a>().</p>
<!-- @@@writeFrame -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2023 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
