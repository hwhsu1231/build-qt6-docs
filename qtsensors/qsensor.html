<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qsensor.cpp -->
  <meta name="description" content="The QSensor class represents a single hardware sensor.">
  <title>QSensor Class | Qt Sensors 6.6.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.6</a></li>
<li><a href="qtsensors-index.html" translate="no">Qt Sensors</a></li>
<li><a href="qtsensors-module.html" translate="no">C++ Classes</a></li>
<li>QSensor</li>
<li id="buildversion"><a href="qtsensors-index.html" translate="no">Qt 6.6&#x2e;0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#public-slots">Public Slots</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#related-non-members">Related Non-Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
<li class="level2"><a href="#orientation">Orientation</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QSensor Class</h1>
<!-- $$$QSensor-brief -->
<p>The QSensor class represents a single hardware sensor. <a href="#details">More...</a></p>
<!-- @@@QSensor -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QSensor&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS Sensors) <br/>
target_link_libraries(mytarget PRIVATE Qt6::Sensors)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += sensors</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html" translate="no">QObject</a></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="qaccelerometer.html" translate="no">QAccelerometer</a>, <a href="qambientlightsensor.html" translate="no">QAmbientLightSensor</a>, <a href="qambienttemperaturesensor.html" translate="no">QAmbientTemperatureSensor</a>, <a href="qcompass.html" translate="no">QCompass</a>, <a href="qgyroscope.html" translate="no">QGyroscope</a>, <a href="qhumiditysensor.html" translate="no">QHumiditySensor</a>, <a href="qlightsensor.html" translate="no">QLightSensor</a>, <a href="qmagnetometer.html" translate="no">QMagnetometer</a>, <a href="qorientationsensor.html" translate="no">QOrientationSensor</a>, <a href="qpressuresensor.html" translate="no">QPressureSensor</a>, <a href="qproximitysensor.html" translate="no">QProximitySensor</a>, <a href="qrotationsensor.html" translate="no">QRotationSensor</a>, and <a href="qtiltsensor.html" translate="no">QTiltSensor</a></p>
</td></tr>
</table></div>
<ul>
<li><a href="qsensor-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#AxesOrientationMode-enum" translate="no">AxesOrientationMode</a></b> { FixedOrientation, AutomaticOrientation, UserOrientation }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#Feature-enum" translate="no">Feature</a></b> { Buffering, AlwaysOn, SkipDuplicates, GeoValues, FieldOfView, &hellip;, AxesOrientation }</td></tr>
</table></div>
<h2 id="properties">Properties</h2>
<div class="table"><table class="propsummary" translate="no">
<tr><td class="topAlign"><ul>
<li class="fn" translate="no"><b><a href="qsensor.html#active-prop" translate="no">active</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qsensor.html#alwaysOn-prop" translate="no">alwaysOn</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qsensor.html#availableDataRates-prop" translate="no">availableDataRates</a></b> : const qrangelist</li>
<li class="fn" translate="no"><b><a href="qsensor.html#axesOrientationMode-prop" translate="no">axesOrientationMode</a></b> : AxesOrientationMode</li>
<li class="fn" translate="no"><b><a href="qsensor.html#bufferSize-prop" translate="no">bufferSize</a></b> : int</li>
<li class="fn" translate="no"><b><a href="qsensor.html#busy-prop" translate="no">busy</a></b> : const bool</li>
<li class="fn" translate="no"><b><a href="qsensor.html#connectedToBackend-prop" translate="no">connectedToBackend</a></b> : const bool</li>
<li class="fn" translate="no"><b><a href="qsensor.html#currentOrientation-prop" translate="no">currentOrientation</a></b> : const int</li>
<li class="fn" translate="no"><b><a href="qsensor.html#dataRate-prop" translate="no">dataRate</a></b> : int</li>
<li class="fn" translate="no"><b><a href="qsensor.html#description-prop" translate="no">description</a></b> : const QString</li>
</ul></td><td class="topAlign"><ul>
<li class="fn" translate="no"><b><a href="qsensor.html#efficientBufferSize-prop" translate="no">efficientBufferSize</a></b> : const int</li>
<li class="fn" translate="no"><b><a href="qsensor.html#error-prop" translate="no">error</a></b> : const int</li>
<li class="fn" translate="no"><b><a href="qsensor.html#identifier-prop" translate="no">identifier</a></b> : QByteArray</li>
<li class="fn" translate="no"><b><a href="qsensor.html#maxBufferSize-prop" translate="no">maxBufferSize</a></b> : const int</li>
<li class="fn" translate="no"><b><a href="qsensor.html#outputRange-prop" translate="no">outputRange</a></b> : int</li>
<li class="fn" translate="no"><b><a href="qsensor.html#outputRanges-prop" translate="no">outputRanges</a></b> : const qoutputrangelist</li>
<li class="fn" translate="no"><b><a href="qsensor.html#reading-prop" translate="no">reading</a></b> : QSensorReading* const</li>
<li class="fn" translate="no"><b><a href="qsensor.html#skipDuplicates-prop" translate="no">skipDuplicates</a></b> : bool</li>
<li class="fn" translate="no"><b><a href="qsensor.html#type-prop" translate="no">type</a></b> : const QByteArray</li>
<li class="fn" translate="no"><b><a href="qsensor.html#userOrientation-prop" translate="no">userOrientation</a></b> : int</li>
</ul>
</td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#QSensor" translate="no">QSensor</a></b>(const QByteArray &amp;<i>type</i>, QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#dtor.QSensor" translate="no">~QSensor</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#addFilter" translate="no">addFilter</a></b>(QSensorFilter *<i>filter</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qrangelist </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#availableDataRates-prop" translate="no">availableDataRates</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSensor::AxesOrientationMode </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#axesOrientationMode-prop" translate="no">axesOrientationMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#bufferSize-prop" translate="no">bufferSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#connectToBackend" translate="no">connectToBackend</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#currentOrientation-prop" translate="no">currentOrientation</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#dataRate-prop" translate="no">dataRate</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#description-prop" translate="no">description</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#efficientBufferSize-prop" translate="no">efficientBufferSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#error-prop" translate="no">error</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QSensorFilter *&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#filters" translate="no">filters</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#identifier-prop" translate="no">identifier</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#active-prop" translate="no">isActive</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#alwaysOn-prop" translate="no">isAlwaysOn</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#busy-prop" translate="no">isBusy</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#connectedToBackend-prop" translate="no">isConnectedToBackend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#isFeatureSupported" translate="no">isFeatureSupported</a></b>(QSensor::Feature <i>feature</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#maxBufferSize-prop" translate="no">maxBufferSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#outputRange-prop" translate="no">outputRange</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qoutputrangelist </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#outputRanges-prop" translate="no">outputRanges</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSensorReading *</td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#reading-prop" translate="no">reading</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#removeFilter" translate="no">removeFilter</a></b>(QSensorFilter *<i>filter</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#active-prop" translate="no">setActive</a></b>(bool <i>active</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#alwaysOn-prop" translate="no">setAlwaysOn</a></b>(bool <i>alwaysOn</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#axesOrientationMode-prop" translate="no">setAxesOrientationMode</a></b>(QSensor::AxesOrientationMode <i>axesOrientationMode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#bufferSize-prop" translate="no">setBufferSize</a></b>(int <i>bufferSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#setCurrentOrientation" translate="no">setCurrentOrientation</a></b>(int <i>currentOrientation</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#dataRate-prop" translate="no">setDataRate</a></b>(int <i>rate</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#setEfficientBufferSize" translate="no">setEfficientBufferSize</a></b>(int <i>efficientBufferSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#identifier-prop" translate="no">setIdentifier</a></b>(const QByteArray &amp;<i>identifier</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#setMaxBufferSize" translate="no">setMaxBufferSize</a></b>(int <i>maxBufferSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#outputRange-prop" translate="no">setOutputRange</a></b>(int <i>index</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#setSkipDuplicates" translate="no">setSkipDuplicates</a></b>(bool <i>skipDuplicates</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#userOrientation-prop" translate="no">setUserOrientation</a></b>(int <i>userOrientation</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#skipDuplicates-prop" translate="no">skipDuplicates</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#type-prop" translate="no">type</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#userOrientation-prop" translate="no">userOrientation</a></b>() const</td></tr>
</table></div>
<h2 id="public-slots">Public Slots</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#start" translate="no">start</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#stop" translate="no">stop</a></b>()</td></tr>
</table></div>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#activeChanged" translate="no">activeChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#alwaysOnChanged" translate="no">alwaysOnChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#availableSensorsChanged" translate="no">availableSensorsChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#axesOrientationMode-prop" translate="no">axesOrientationModeChanged</a></b>(QSensor::AxesOrientationMode <i>axesOrientationMode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#bufferSize-prop" translate="no">bufferSizeChanged</a></b>(int <i>bufferSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#busyChanged" translate="no">busyChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#currentOrientation-prop" translate="no">currentOrientationChanged</a></b>(int <i>currentOrientation</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#dataRate-prop" translate="no">dataRateChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#efficientBufferSize-prop" translate="no">efficientBufferSizeChanged</a></b>(int <i>efficientBufferSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#identifier-prop" translate="no">identifierChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#maxBufferSize-prop" translate="no">maxBufferSizeChanged</a></b>(int <i>maxBufferSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#readingChanged" translate="no">readingChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#sensorError" translate="no">sensorError</a></b>(int <i>error</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#skipDuplicatesChanged" translate="no">skipDuplicatesChanged</a></b>(bool <i>skipDuplicates</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#userOrientation-prop" translate="no">userOrientationChanged</a></b>(int <i>userOrientation</i>)</td></tr>
</table></div>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#defaultSensorForType" translate="no">defaultSensorForType</a></b>(const QByteArray &amp;<i>type</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QByteArray&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#sensorTypes" translate="no">sensorTypes</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QByteArray&gt; </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#sensorsForType" translate="no">sensorsForType</a></b>(const QByteArray &amp;<i>type</i>)</td></tr>
</table></div>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#qoutputrangelist-typedef" translate="no">qoutputrangelist</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#qrange-typedef" translate="no">qrange</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qsensor.html#qrangelist-typedef" translate="no">qrangelist</a></b></td></tr>
</table></div>
<!-- $$$QSensor-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The life cycle of a sensor is typically:</p>
<ul>
<li>Create a sub-class of QSensor on the stack or heap.</li>
<li>Setup as required by the application.</li>
<li>Start receiving values.</li>
<li>Sensor data is used by the application.</li>
<li>Stop receiving values.</li>
</ul>
<p>The sensor data is delivered via <a href="qsensorreading.html" translate="no">QSensorReading</a> and its sub-classes.</p>
<h3 id="orientation">Orientation</h3>
<p>Some sensors react to screen orientation changes, such as <a href="qaccelerometer.html" translate="no">QAccelerometer</a>, <a href="qmagnetometer.html" translate="no">QMagnetometer</a> and <a href="qrotationsensor.html" translate="no">QRotationSensor</a>. These are so called <i>orientable</i> sensors. For orientable sensors, QSensor supports changing the reporting of the reading values based on the orientation of the screen.</p>
<p>For orientable sensors, the <a href="qsensor.html#axesOrientationMode-prop" translate="no">axesOrientationMode</a> property controls how the orientation affects the reading values.</p>
<p>In the default mode, <a href="qsensor.html#AxesOrientationMode-enum" translate="no">QSensor::FixedOrientation</a>, the reading values remain unaffected by the orientation. In the <a href="qsensor.html#AxesOrientationMode-enum" translate="no">QSensor::AutomaticOrientation</a> mode, the reading values are automatically rotated by taking the current screen orientation into account. And finally, in the <a href="qsensor.html#AxesOrientationMode-enum" translate="no">QSensor::UserOrientation</a> mode, the reading values are rotated according to a user-specified orientation.</p>
<p>The functionality of this is only available if it is supported by the backend and if the sensor is orientable, which can be checked by calling <a href="qsensor.html#isFeatureSupported" translate="no">QSensor::isFeatureSupported</a>() with the <a href="qsensor.html#Feature-enum" translate="no">QSensor::AxesOrientation</a> flag.</p>
<p>The orientation values here are always of the screen orientation, not the device orientation. The screen orientation is the orientation of the GUI. For example when rotating a device by 90 degrees counter-clockwise, the screen orientation compensates for that by rotating 90 degrees clockwise, to the effect that the GUI is still facing upright after the device has been rotated. Note that applications can lock the screen orientation, for example to force portrait or landscape mode. For locked orientations, orientable sensors will not react with reading changes if the device orientation is changed, as orientable sensors react to screen orientation changes only. This makes sense, as the purpose of orientable sensors is to keep the sensor orientation in sync with the screen orientation.</p>
<p>The orientation values range from 0 to 270 degrees. The orientation is applied in clockwise direction, e.g&#x2e; an orientation value of 90 degrees means that the screen has been rotated 90 degress to the right from its origin position, to compensate a device rotation of 90 degrees to the left.</p>
</div>
<p><b>See also </b><a href="qsensorreading.html" translate="no">QSensorReading</a>.</p>
<!-- @@@QSensor -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$AxesOrientationMode$$$FixedOrientation$$$AutomaticOrientation$$$UserOrientation -->
<h3 class="fn" translate="no" id="AxesOrientationMode-enum">enum QSensor::<span class="name">AxesOrientationMode</span></h3>
<p>Describes how reading values are affected by the screen orientation.</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSensor::FixedOrientation</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">No automatic rotation is applied to the reading values.</td></tr>
<tr><td class="topAlign"><code translate="no">QSensor::AutomaticOrientation</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The reading values are automatically rotated based on the screen orientation.</td></tr>
<tr><td class="topAlign"><code translate="no">QSensor::UserOrientation</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The reading values are rotated based on the angle of the <a href="qsensor.html#userOrientation-prop" translate="no">userOrientation</a> property.</td></tr>
</table></div>
<p><b>See also </b><a href="qsensor.html#axesOrientationMode-prop" translate="no">QSensor::axesOrientationMode</a>.</p>
<!-- @@@AxesOrientationMode -->
<!-- $$$Feature$$$Buffering$$$AlwaysOn$$$GeoValues$$$FieldOfView$$$AccelerationMode$$$SkipDuplicates$$$AxesOrientation$$$PressureSensorTemperature$$$Reserved -->
<h3 class="fn" translate="no" id="Feature-enum">enum QSensor::<span class="name">Feature</span></h3>
<p>Lists optional features a backend might support.</p>
<p>The features common to all sensor types are:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSensor::Buffering</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The backend supports buffering of readings, controlled by the <a href="qsensor.html#bufferSize-prop" translate="no">QSensor::bufferSize</a> property.</td></tr>
<tr><td class="topAlign"><code translate="no">QSensor::AlwaysOn</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The backend supports changing the policy on whether to suspend when idle, controlled by the <a href="qsensor.html#alwaysOn-prop" translate="no">QSensor::alwaysOn</a> property.</td></tr>
<tr><td class="topAlign"><code translate="no">QSensor::SkipDuplicates</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">The backend supports skipping of same or very similar successive readings. This can be enabled by setting the <a href="qsensor.html#skipDuplicates-prop" translate="no">QSensor::skipDuplicates</a> property to true.</td></tr>
</table></div>
<p>The features of <a href="qmagnetometer.html" translate="no">QMagnetometer</a> are:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="even"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSensor::GeoValues</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The backend supports returning geo values, which can be controlled with the <a href="qmagnetometer.html#returnGeoValues-prop" translate="no">QMagnetometer::returnGeoValues</a> property.</td></tr>
</table></div>
<p>The features of <a href="qlightsensor.html" translate="no">QLightSensor</a> are:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSensor::FieldOfView</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">The backend specifies its field of view, which can be read from the <a href="qlightsensor.html#fieldOfView-prop" translate="no">QLightSensor::fieldOfView</a> property.</td></tr>
</table></div>
<p>The features of <a href="qaccelerometer.html" translate="no">QAccelerometer</a> are:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="even"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSensor::AccelerationMode</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">The backend supports switching the acceleration mode of the acceleromter with the <a href="qaccelerometer.html#accelerationMode-prop" translate="no">QAccelerometer::accelerationMode</a> property.</td></tr>
</table></div>
<p>The features of <a href="qpressuresensor.html" translate="no">QPressureSensor</a> are:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSensor::PressureSensorTemperature</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">The backend provides the pressure sensor's die temperature</td></tr>
</table></div>
<p>The features of all orientable sensors are:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="even"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSensor::AxesOrientation</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">The backend supports changing the axes orientation from the default of <a href="qsensor.html#AxesOrientationMode-enum" translate="no">QSensor::FixedOrientation</a> to something else.</td></tr>
</table></div>
<p><b>See also </b><a href="qsensor.html#isFeatureSupported" translate="no">QSensor::isFeatureSupported</a>().</p>
<!-- @@@Feature -->
</div>
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$active-prop$$$isActive$$$setActivebool$$$activeChanged -->
<h3 class="fn" translate="no" id="active-prop"><span class="name">active</span> : <span class="type">bool</span></h3>
<p>This property holds a value to indicate if the sensor is active.</p>
<p>This is true if the sensor is active (returning values). This is false otherwise.</p>
<p>Note that setting this value to true will not have an immediate effect. Instead, the sensor will be started once the event loop has been reached.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isActive</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setActive</b></span>(bool <i>active</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qsensor.html#activeChanged" translate="no">activeChanged</a></b></span>()</td></tr>
</table></div>
<!-- @@@active -->
<!-- $$$alwaysOn-prop$$$isAlwaysOn$$$setAlwaysOnbool$$$alwaysOnChanged -->
<h3 class="fn" translate="no" id="alwaysOn-prop"><span class="name">alwaysOn</span> : <span class="type">bool</span></h3>
<p>This property holds a value to indicate if the sensor should remain running when the screen is off.</p>
<p>Some platforms have a policy of suspending sensors when the screen turns off. Setting this property to true will ensure the sensor continues to run.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isAlwaysOn</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setAlwaysOn</b></span>(bool <i>alwaysOn</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qsensor.html#alwaysOnChanged" translate="no">alwaysOnChanged</a></b></span>()</td></tr>
</table></div>
<!-- @@@alwaysOn -->
<!-- $$$availableDataRates-prop$$$availableDataRates -->
<h3 class="fn" translate="no" id="availableDataRates-prop"><code translate="no">[read-only] </code><span class="name">availableDataRates</span> : const <span class="type"><a href="qsensor.html#qrangelist-typedef" translate="no">qrangelist</a></span></h3>
<p>This property holds the data rates that the sensor supports.</p>
<p>This is a list of the data rates that the sensor supports. Measured in Hertz.</p>
<p>Entries in the list can represent discrete rates or a continuous range of rates. A discrete rate is noted by having both values the same.</p>
<p>Note that this information is not mandatory as not all sensors have a rate at which they run. In such cases, the list will be empty.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> qrangelist </td><td class="memItemRight bottomAlign"><span class="name"><b>availableDataRates</b></span>() const</td></tr>
</table></div>
<p><b>See also </b><a href="qsensor.html#dataRate-prop" translate="no">QSensor::dataRate</a> and <a href="qsensor.html#qrangelist-typedef" translate="no">qrangelist</a>.</p>
<!-- @@@availableDataRates -->
<!-- $$$axesOrientationMode-prop$$$axesOrientationMode$$$setAxesOrientationModeQSensor::AxesOrientationMode$$$axesOrientationModeChangedQSensor::AxesOrientationMode -->
<h3 class="fn" translate="no" id="axesOrientationMode-prop"><span class="name">axesOrientationMode</span> : <span class="type"><a href="qsensor.html#AxesOrientationMode-enum" translate="no">AxesOrientationMode</a></span></h3>
<p>This property holds the mode that affects how the screen orientation changes reading values.</p>
<p>When set to <a href="qsensor.html#AxesOrientationMode-enum" translate="no">FixedOrientation</a>, which is the default mode, no automatic rotation is applied to the reading. This is the only mode available for backends that do not support the <a href="qsensor.html#Feature-enum" translate="no">QSensor::AxesOrientation</a> feature.</p>
<p>When set to <a href="qsensor.html#AxesOrientationMode-enum" translate="no">AutomaticOrientation</a>, the reading values are automatically rotated when the screen orientation changes. In effect, the screen orientation is canceled out.</p>
<p>As an example, assume the device is rotated by 180 degrees and therefore the screen orientation also is rotated by 180 degrees from the native orientation. Without automatic axes orientation, the reading values would now be changed: Both the X and the Y values would be negated, forcing an application developer to manually cancel out the negation in application code. Automatic axes orientation does this automatically, in this mode the X and Y values would be the same as with the default screen orientation.</p>
<p>This automatic rotation of the axes is handy is some usecases, for example in a bubble level application that measures how level a surface is by looking at the X axis value of an accelerometer. When the device and screen orientation change by 90 degrees, an application developer does not need to change anything, he can continue using the X axis value even though the device is rotated. Without automatic axes orientation, the application developer would need to look at the Y values instead, thereby adding code to the application that reads from a different axis depending on the screen orientation.</p>
<p>The <a href="qsensor.html#AxesOrientationMode-enum" translate="no">UserOrientation</a> mode is quite similar to <a href="qsensor.html#AxesOrientationMode-enum" translate="no">AutomaticOrientation</a>, only that the screen orientation is manually controlled instead of automatically determined. The angle of the <a href="qsensor.html#userOrientation-prop" translate="no">userOrientation</a> property is then used for rotating the reading values.</p>
<p>Since the rotation of the reading values is based on the screen orientation, Z values will never change, as the Z axis is perpendicular to the screen. As screen orientation changes in 90 degree steps, rotating the reading values is also done in steps of 90 degrees.</p>
<p>This property is only used for orientable sensors.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QSensor::AxesOrientationMode </td><td class="memItemRight bottomAlign"><span class="name"><b>axesOrientationMode</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setAxesOrientationMode</b></span>(QSensor::AxesOrientationMode <i>axesOrientationMode</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>axesOrientationModeChanged</b></span>(QSensor::AxesOrientationMode <i>axesOrientationMode</i>)</td></tr>
</table></div>
<!-- @@@axesOrientationMode -->
<!-- $$$bufferSize-prop$$$bufferSize$$$setBufferSizeint$$$bufferSizeChangedint -->
<h3 class="fn" translate="no" id="bufferSize-prop"><span class="name">bufferSize</span> : <span class="type">int</span></h3>
<p>This property holds the size of the buffer. By default, the buffer size is 1, which means no buffering. If the maximum buffer size is 1, then buffering is not supported by the sensor.</p>
<p>Setting bufferSize greater than <a href="qsensor.html#maxBufferSize-prop" translate="no">maxBufferSize</a> will cause <a href="qsensor.html#maxBufferSize-prop" translate="no">maxBufferSize</a> to be used.</p>
<p>Buffering is turned on when bufferSize is greater than 1. The sensor will collect the requested number of samples and deliver them all to the application at one time. They will be delivered to the application as a burst of changed readings so it is particularly important that the application processes each reading immediately or saves the values somewhere else.</p>
<p>If <a href="qsensor.html#stop" translate="no">stop</a>() is called when buffering is on-going, the partial buffer is not delivered.</p>
<p>When the sensor is started with buffering option, values are collected from that moment onwards. There is no pre-existing buffer that can be utilized.</p>
<p>Some backends only support enabling or disabling the buffer and do not give control over the size. In this case, the <a href="qsensor.html#maxBufferSize-prop" translate="no">maxBufferSize</a> and <a href="qsensor.html#efficientBufferSize-prop" translate="no">efficientBufferSize</a> properties might not be set at all, even though buffering is supported. Setting the bufferSize property to any value greater than 1 will enable buffering. After the sensor has been started, the bufferSize property will be set to the actual value by the backend.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>bufferSize</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setBufferSize</b></span>(int <i>bufferSize</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>bufferSizeChanged</b></span>(int <i>bufferSize</i>)</td></tr>
</table></div>
<p><b>See also </b><a href="qsensor.html#maxBufferSize-prop" translate="no">QSensor::maxBufferSize</a> and <a href="qsensor.html#efficientBufferSize-prop" translate="no">QSensor::efficientBufferSize</a>.</p>
<!-- @@@bufferSize -->
<!-- $$$busy-prop$$$isBusy$$$busyChanged -->
<h3 class="fn" translate="no" id="busy-prop"><code translate="no">[read-only] </code><span class="name">busy</span> : const <span class="type">bool</span></h3>
<p>This property holds a value to indicate if the sensor is busy.</p>
<p>Some sensors may be on the system but unavailable for use. This function will return true if the sensor is busy. You will not be able to <a href="qsensor.html#start" translate="no">start</a>() the sensor.</p>
<p>Note that this function does not return true if you are using the sensor, only if another process is using the sensor.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isBusy</b></span>() const</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qsensor.html#busyChanged" translate="no">busyChanged</a></b></span>()</td></tr>
</table></div>
<p><b>See also </b><a href="qsensor.html#busyChanged" translate="no">busyChanged</a>().</p>
<!-- @@@busy -->
<!-- $$$connectedToBackend-prop$$$isConnectedToBackend -->
<h3 class="fn" translate="no" id="connectedToBackend-prop"><code translate="no">[read-only] </code><span class="name">connectedToBackend</span> : const <span class="type">bool</span></h3>
<p>This property holds a value indicating if the sensor has connected to a backend.</p>
<p>A sensor that has not been connected to a backend cannot do anything useful.</p>
<p>Call the <a href="qsensor.html#connectToBackend" translate="no">connectToBackend</a>() method to force the sensor to connect to a backend immediately. This is automatically called if you call <a href="qsensor.html#start" translate="no">start</a>() so you only need to do this if you need access to sensor properties (ie. to poll the sensor's meta-data before you use it).</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isConnectedToBackend</b></span>() const</td></tr>
</table></div>
<!-- @@@connectedToBackend -->
<!-- $$$currentOrientation-prop$$$currentOrientation$$$currentOrientationChangedint -->
<h3 class="fn" translate="no" id="currentOrientation-prop"><code translate="no">[read-only] </code><span class="name">currentOrientation</span> : const <span class="type">int</span></h3>
<p>This property holds the current orientation that is used for rotating the reading values.</p>
<p>This might not be the same as the screen orientation. For example, in the <a href="qsensor.html#AxesOrientationMode-enum" translate="no">FixedOrientation</a> mode, the reading values are not rotated, and therefore the property is 0.</p>
<p>In the <a href="qsensor.html#AxesOrientationMode-enum" translate="no">UserOrientation</a> mode, the readings are rotated based on the <a href="qsensor.html#userOrientation-prop" translate="no">userOrientation</a> property, and therefore this property is equal to the <a href="qsensor.html#userOrientation-prop" translate="no">userOrientation</a> property.</p>
<p>In the <a href="qsensor.html#AxesOrientationMode-enum" translate="no">AutomaticOrientation</a> mode, the readings are rotated based on the screen orientation, and therefore this property will be equal to the current screen orientation.</p>
<p>This property is set by the backend and only valid for orientable sensors.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>currentOrientation</b></span>() const</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>currentOrientationChanged</b></span>(int <i>currentOrientation</i>)</td></tr>
</table></div>
<!-- @@@currentOrientation -->
<!-- $$$dataRate-prop$$$dataRate$$$setDataRateint$$$dataRateChanged -->
<h3 class="fn" translate="no" id="dataRate-prop"><span class="name">dataRate</span> : <span class="type">int</span></h3>
<p>This property holds the data rate that the sensor should be run at.</p>
<p>Measured in Hertz.</p>
<p>The data rate is the maximum frequency at which the sensor can detect changes.</p>
<p>Setting this property is not portable and can cause conflicts with other applications. Check with the sensor backend and platform documentation for any policy regarding multiple applications requesting a data rate.</p>
<p>The default value (0) means that the app does not care what the data rate is. Applications should consider using a timer-based poll of the current value or ensure that the code that processes values can run very quickly as the platform may provide updates hundreds of times each second.</p>
<p>This should be set before calling <a href="qsensor.html#start" translate="no">start</a>() because the sensor may not notice changes to this value while it is running.</p>
<p>Note that there is no mechanism to determine the current data rate in use by the platform.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>dataRate</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setDataRate</b></span>(int <i>rate</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>dataRateChanged</b></span>()</td></tr>
</table></div>
<p><b>See also </b><a href="qsensor.html#availableDataRates-prop" translate="no">QSensor::availableDataRates</a>.</p>
<!-- @@@dataRate -->
<!-- $$$description-prop$$$description -->
<h3 class="fn" translate="no" id="description-prop"><code translate="no">[read-only] </code><span class="name">description</span> : const <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span></h3>
<p>This property holds a descriptive string for the sensor.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>description</b></span>() const</td></tr>
</table></div>
<!-- @@@description -->
<!-- $$$efficientBufferSize-prop$$$efficientBufferSize$$$efficientBufferSizeChangedint -->
<h3 class="fn" translate="no" id="efficientBufferSize-prop"><code translate="no">[read-only] </code><span class="name">efficientBufferSize</span> : const <span class="type">int</span></h3>
<p>The property holds the most efficient buffer size. Normally this is 1 (which means no particular size is most efficient). Some sensor drivers have a FIFO buffer which makes it more efficient to deliver the FIFO's size worth of readings at one time.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>efficientBufferSize</b></span>() const</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>efficientBufferSizeChanged</b></span>(int <i>efficientBufferSize</i>)</td></tr>
</table></div>
<p><b>See also </b><a href="qsensor.html#bufferSize-prop" translate="no">QSensor::bufferSize</a> and <a href="qsensor.html#maxBufferSize-prop" translate="no">QSensor::maxBufferSize</a>.</p>
<!-- @@@efficientBufferSize -->
<!-- $$$error-prop$$$error$$$sensorErrorint -->
<h3 class="fn" translate="no" id="error-prop"><code translate="no">[read-only] </code><span class="name">error</span> : const <span class="type">int</span></h3>
<p>This property holds the last error code set on the sensor.</p>
<p>Note that error codes are sensor-specific.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>error</b></span>() const</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qsensor.html#sensorError" translate="no">sensorError</a></b></span>(int <i>error</i>)</td></tr>
</table></div>
<!-- @@@error -->
<!-- $$$identifier-prop$$$identifier$$$setIdentifierconstQByteArray&$$$identifierChanged -->
<h3 class="fn" translate="no" id="identifier-prop"><span class="name">identifier</span> : <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span></h3>
<p>This property holds the backend identifier for the sensor.</p>
<p>Note that the identifier is filled out automatically when the sensor is connected to a backend. If you want to connect a specific backend, you should call setIdentifier() before <a href="qsensor.html#connectToBackend" translate="no">connectToBackend</a>().</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QByteArray </td><td class="memItemRight bottomAlign"><span class="name"><b>identifier</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setIdentifier</b></span>(const QByteArray &amp;<i>identifier</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>identifierChanged</b></span>()</td></tr>
</table></div>
<!-- @@@identifier -->
<!-- $$$maxBufferSize-prop$$$maxBufferSize$$$maxBufferSizeChangedint -->
<h3 class="fn" translate="no" id="maxBufferSize-prop"><code translate="no">[read-only] </code><span class="name">maxBufferSize</span> : const <span class="type">int</span></h3>
<p>The property holds the maximum buffer size.</p>
<p>Note that this may be 1, in which case the sensor does not support any form of buffering. In that case, <a href="qsensor.html#isFeatureSupported" translate="no">isFeatureSupported</a>(<a href="qsensor.html#Feature-enum" translate="no">QSensor::Buffering</a>) will also return false.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>maxBufferSize</b></span>() const</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>maxBufferSizeChanged</b></span>(int <i>maxBufferSize</i>)</td></tr>
</table></div>
<p><b>See also </b><a href="qsensor.html#bufferSize-prop" translate="no">QSensor::bufferSize</a> and <a href="qsensor.html#efficientBufferSize-prop" translate="no">QSensor::efficientBufferSize</a>.</p>
<!-- @@@maxBufferSize -->
<!-- $$$outputRange-prop$$$outputRange$$$setOutputRangeint -->
<h3 class="fn" translate="no" id="outputRange-prop"><span class="name">outputRange</span> : <span class="type">int</span></h3>
<p>This property holds the output range in use by the sensor.</p>
<p>This value represents the index in the <a href="qsensor.html#outputRanges-prop" translate="no">QSensor::outputRanges</a> list to use.</p>
<p>Setting this property is not portable and can cause conflicts with other applications. Check with the sensor backend and platform documentation for any policy regarding multiple applications requesting an output range.</p>
<p>The default value (-1) means that the app does not care what the output range is.</p>
<p>Note that there is no mechanism to determine the current output range in use by the platform.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>outputRange</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setOutputRange</b></span>(int <i>index</i>)</td></tr>
</table></div>
<p><b>See also </b><a href="qsensor.html#outputRanges-prop" translate="no">QSensor::outputRanges</a>.</p>
<!-- @@@outputRange -->
<!-- $$$outputRanges-prop$$$outputRanges -->
<h3 class="fn" translate="no" id="outputRanges-prop"><code translate="no">[read-only] </code><span class="name">outputRanges</span> : const <span class="type"><a href="qsensor.html#qoutputrangelist-typedef" translate="no">qoutputrangelist</a></span></h3>
<p>This property holds a list of output ranges the sensor supports.</p>
<p>A sensor may have more than one output range. Typically this is done to give a greater measurement range at the cost of lowering accuracy.</p>
<p>Note that this information is not mandatory. This information is typically only available for sensors that have selectable output ranges (such as typical accelerometers).</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> qoutputrangelist </td><td class="memItemRight bottomAlign"><span class="name"><b>outputRanges</b></span>() const</td></tr>
</table></div>
<p><b>See also </b><a href="qsensor.html#outputRange-prop" translate="no">QSensor::outputRange</a> and <a href="qsensor.html#qoutputrangelist-typedef" translate="no">qoutputrangelist</a>.</p>
<!-- @@@outputRanges -->
<!-- $$$reading-prop$$$reading$$$readingChanged -->
<h3 class="fn" translate="no" id="reading-prop"><code translate="no">[read-only] </code><span class="name">reading</span> : <span class="type"><a href="qsensorreading.html" translate="no">QSensorReading</a></span>* const</h3>
<p>This property holds the reading class.</p>
<p>The reading class provides access to sensor readings. The reading object is a volatile cache of the most recent sensor reading that has been received so the application should process readings immediately or save the values somewhere for later processing.</p>
<p>Note that this will return 0 until a sensor backend is connected to a backend.</p>
<p>Also note that readings are not immediately available after <a href="qsensor.html#start" translate="no">start</a>() is called. Applications must wait for the <a href="qsensor.html#readingChanged" translate="no">readingChanged</a>() signal to be emitted.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QSensorReading *</td><td class="memItemRight bottomAlign"><span class="name"><b>reading</b></span>() const</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qsensor.html#readingChanged" translate="no">readingChanged</a></b></span>()</td></tr>
</table></div>
<p><b>See also </b><a href="qsensor.html#connectedToBackend-prop" translate="no">isConnectedToBackend</a>() and <a href="qsensor.html#start" translate="no">start</a>().</p>
<!-- @@@reading -->
<!-- $$$skipDuplicates-prop$$$skipDuplicates$$$setSkipDuplicatesbool$$$skipDuplicatesChangedbool -->
<h3 class="fn" translate="no" id="skipDuplicates-prop"><span class="name">skipDuplicates</span> : <span class="type">bool</span></h3>
<p>Indicates whether duplicate reading values should be omitted.</p>
<p>When duplicate skipping is enabled, successive readings with the same or very similar values are omitted. This helps reducing the amount of processing done, as less sensor readings are made available. As a consequence, readings arrive at an irregular interval.</p>
<p>Duplicate skipping is not just enabled for readings that are exactly the same, but also for readings that are quite similar, as each sensor has a bit of jitter even if the device is not moved.</p>
<p>Support for this property depends on the backend. Use <a href="qsensor.html#isFeatureSupported" translate="no">isFeatureSupported</a>() to check if it is supported on the current platform.</p>
<p>Duplicate skipping is disabled by default.</p>
<p>Duplicate skipping takes effect when the sensor is started, changing the property while the sensor is active has no immediate effect.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>skipDuplicates</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qsensor.html#setSkipDuplicates" translate="no">setSkipDuplicates</a></b></span>(bool <i>skipDuplicates</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qsensor.html#skipDuplicatesChanged" translate="no">skipDuplicatesChanged</a></b></span>(bool <i>skipDuplicates</i>)</td></tr>
</table></div>
<!-- @@@skipDuplicates -->
<!-- $$$type-prop$$$type -->
<h3 class="fn" translate="no" id="type-prop"><code translate="no">[read-only] </code><span class="name">type</span> : const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span></h3>
<p>This property holds the type of the sensor.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> QByteArray </td><td class="memItemRight bottomAlign"><span class="name"><b>type</b></span>() const</td></tr>
</table></div>
<!-- @@@type -->
<!-- $$$userOrientation-prop$$$userOrientation$$$setUserOrientationint$$$userOrientationChangedint -->
<h3 class="fn" translate="no" id="userOrientation-prop"><span class="name">userOrientation</span> : <span class="type">int</span></h3>
<p>This property holds the angle used for rotating the reading values in the <a href="qsensor.html#AxesOrientationMode-enum" translate="no">UserOrientation</a> mode.</p>
<p>When the <a href="qsensor.html#axesOrientationMode-prop" translate="no">axesOrientationMode</a> property is set to <a href="qsensor.html#AxesOrientationMode-enum" translate="no">UserOrientation</a>, the angle for rotating the reading values is taken from this property. In other modes, the property has no effect.</p>
<p>The default is 0. The only valid values are 0, 90, 180 and 270, as those are the only possible screen orientations.</p>
<p>This property is only valid for orientable sensors.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>userOrientation</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setUserOrientation</b></span>(int <i>userOrientation</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>userOrientationChanged</b></span>(int <i>userOrientation</i>)</td></tr>
</table></div>
<!-- @@@userOrientation -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QSensor[overload1]$$$QSensorconstQByteArray&QObject* -->
<h3 class="fn" translate="no" id="QSensor"><code translate="no">[explicit] </code>QSensor::<span class="name">QSensor</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>type</i>, <span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Construct the <i translate="no">type</i> sensor as a child of <i translate="no">parent</i>.</p>
<p>Do not use this constructor if a derived class exists for the specific sensor type.</p>
<p>The wrong way is to use the base class constructor:</p>
<pre class="cpp" translate="no">
 <span class="type">QSensor</span> <span class="operator">*</span>magnetometer <span class="operator">=</span> <span class="keyword">new</span> <span class="type">QSensor</span>(<span class="type"><a href="qmagnetometer.html" translate="no">QMagnetometer</a></span><span class="operator">::</span>sensorType<span class="operator">,</span> <span class="keyword">this</span>);
</pre>
<p>The right way is to create an instance of the derived class:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qmagnetometer.html" translate="no">QMagnetometer</a></span> <span class="operator">*</span>magnetometer <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qmagnetometer.html" translate="no">QMagnetometer</a></span>(<span class="keyword">this</span>);
</pre>
<p>The derived classes have additional properties and data members which are needed for certain features such as geo value support in <a href="qmagnetometer.html" translate="no">QMagnetometer</a> or acceleration mode support in <a href="qaccelerometer.html" translate="no">QAccelerometer</a>. These features will only work properly when creating a sensor instance from a QSensor subclass.</p>
<p>Only use this constructor if there is no derived sensor class available. Note that all built-in sensors have a derived class, so using this constructor should only be necessary when implementing custom sensors.</p>
<!-- @@@QSensor -->
<!-- $$$~QSensor[overload1]$$$~QSensor -->
<h3 class="fn" translate="no" id="dtor.QSensor"><code translate="no">[virtual noexcept] </code>QSensor::<span class="name">~QSensor</span>()</h3>
<p>Destroy the sensor. Stops the sensor if it has not already been stopped.</p>
<!-- @@@~QSensor -->
<!-- $$$activeChanged -->
<h3 class="fn" translate="no" id="activeChanged"><code translate="no">[signal] </code><span class="type">void</span> QSensor::<span class="name">activeChanged</span>()</h3>
<p>This signal is emitted when the <a href="qsensor.html#active-prop" translate="no">QSensor::active</a> property has changed.</p>
<div class="admonition note"><p><b>Note: </b>Notifier signal for property <a href="qsensor.html#active-prop" translate="no">active</a>. </p>
</div><p><b>See also </b><a href="qsensor.html#active-prop" translate="no">QSensor::active</a>.</p>
<!-- @@@activeChanged -->
<!-- $$$addFilter[overload1]$$$addFilterQSensorFilter* -->
<h3 class="fn" translate="no" id="addFilter"><span class="type">void</span> QSensor::<span class="name">addFilter</span>(<span class="type"><a href="qsensorfilter.html" translate="no">QSensorFilter</a></span> *<i>filter</i>)</h3>
<p>Add a <i translate="no">filter</i> to the sensor.</p>
<p>The sensor does not take ownership of the filter. <a href="qsensorfilter.html" translate="no">QSensorFilter</a> will inform the sensor if it is destroyed.</p>
<p><b>See also </b><a href="qsensorfilter.html" translate="no">QSensorFilter</a>.</p>
<!-- @@@addFilter -->
<!-- $$$alwaysOnChanged -->
<h3 class="fn" translate="no" id="alwaysOnChanged"><code translate="no">[signal] </code><span class="type">void</span> QSensor::<span class="name">alwaysOnChanged</span>()</h3>
<p>This signal is emitted when the <a href="qsensor.html#alwaysOn-prop" translate="no">alwaysOn</a> property changes.</p>
<div class="admonition note"><p><b>Note: </b>Notifier signal for property <a href="qsensor.html#alwaysOn-prop" translate="no">alwaysOn</a>. </p>
</div><!-- @@@alwaysOnChanged -->
<!-- $$$availableSensorsChanged[overload1]$$$availableSensorsChanged -->
<h3 class="fn" translate="no" id="availableSensorsChanged"><code translate="no">[signal] </code><span class="type">void</span> QSensor::<span class="name">availableSensorsChanged</span>()</h3>
<p>This signal is emitted when the list of available sensors has changed. The sensors available to a program will not generally change over time however some of the available sensors may represent hardware that is not permanently connected. For example, a game controller that is connected via bluetooth would become available when it was on and would become unavailable when it was off.</p>
<p><b>See also </b><a href="qsensor.html#sensorTypes" translate="no">QSensor::sensorTypes</a>() and <a href="qsensor.html#sensorsForType" translate="no">QSensor::sensorsForType</a>().</p>
<!-- @@@availableSensorsChanged -->
<!-- $$$busyChanged -->
<h3 class="fn" translate="no" id="busyChanged"><code translate="no">[signal] </code><span class="type">void</span> QSensor::<span class="name">busyChanged</span>()</h3>
<p>This signal is emitted when the sensor is no longer busy. This can be used to grab a sensor when it becomes available.</p>
<pre class="cpp" translate="no">
 sensor<span class="operator">.</span>start();
 <span class="keyword">if</span> (sensor<span class="operator">.</span>isBusy()) {
     <span class="comment">// need to wait for busyChanged signal and try again</span>
 }
</pre>
<div class="admonition note"><p><b>Note: </b>Notifier signal for property <a href="qsensor.html#busy-prop" translate="no">busy</a>. </p>
</div><!-- @@@busyChanged -->
<!-- $$$connectToBackend[overload1]$$$connectToBackend -->
<h3 class="fn" translate="no" id="connectToBackend"><code translate="no">[invokable] </code><span class="type">bool</span> QSensor::<span class="name">connectToBackend</span>()</h3>
<p>Try to connect to a sensor backend.</p>
<p>Returns true if a suitable backend could be found, false otherwise.</p>
<p>The type must be set before calling this method if you are using <a href="qsensor.html" translate="no">QSensor</a> directly.</p>
<div class="admonition note"><p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>.</p>
</div><p><b>See also </b><a href="qsensor.html#connectedToBackend-prop" translate="no">isConnectedToBackend</a>().</p>
<!-- @@@connectToBackend -->
<!-- $$$defaultSensorForType[overload1]$$$defaultSensorForTypeconstQByteArray& -->
<h3 class="fn" translate="no" id="defaultSensorForType"><code translate="no">[static] </code><span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> QSensor::<span class="name">defaultSensorForType</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>type</i>)</h3>
<p>Returns the default sensor identifier for <i translate="no">type</i>. This is set in a config file and can be overridden if required. If no default is available the system will return the first registered sensor for <i translate="no">type</i>.</p>
<p>Note that there is special case logic to prevent the generic plugin's backends from becoming the default when another backend is registered for the same type. This logic means that a backend identifier starting with <code translate="no">generic.</code> will only be the default if no other backends have been registered for that type or if it is specified in <code translate="no">Sensors.conf</code>.</p>
<p><b>See also </b><a href="determining-the-default-sensor-for-a-type.html" translate="no">Determining the default sensor for a type</a>.</p>
<!-- @@@defaultSensorForType -->
<!-- $$$filters[overload1]$$$filters -->
<h3 class="fn" translate="no" id="filters"><span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="qsensorfilter.html" translate="no">QSensorFilter</a></span> *&gt; QSensor::<span class="name">filters</span>() const</h3>
<p>Returns the filters currently attached to the sensor.</p>
<p><b>See also </b><a href="qsensorfilter.html" translate="no">QSensorFilter</a>.</p>
<!-- @@@filters -->
<!-- $$$isFeatureSupported[overload1]$$$isFeatureSupportedQSensor::Feature -->
<h3 class="fn" translate="no" id="isFeatureSupported"><code translate="no">[invokable] </code><span class="type">bool</span> QSensor::<span class="name">isFeatureSupported</span>(<span class="type"><a href="qsensor.html#Feature-enum" translate="no">QSensor::Feature</a></span> <i>feature</i>) const</h3>
<p>Checks if a specific feature is supported by the backend.</p>
<p><a href="qtsensors-qmlmodule.html" translate="no">QtSensors</a> supports a rich API for controlling and providing information about sensors. Naturally, not all of this functionality can be supported by all of the backends.</p>
<p>To check if the current backend supports the feature <i translate="no">feature</i>, call this function.</p>
<p>The backend needs to be connected, otherwise false will be returned. Calling <a href="qsensor.html#connectToBackend" translate="no">connectToBackend</a>() or <a href="qsensor.html#start" translate="no">start</a>() will create a connection to the backend.</p>
<p>Backends have to implement <a href="qsensorbackend.html#isFeatureSupported" translate="no">QSensorBackend::isFeatureSupported</a>() to make this work.</p>
<p>Returns whether or not the feature is supported if the backend is connected, or false if the backend is not connected.</p>
<div class="admonition note"><p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="../qtcore/qobject.html#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>.</p>
</div><!-- @@@isFeatureSupported -->
<!-- $$$readingChanged -->
<h3 class="fn" translate="no" id="readingChanged"><code translate="no">[signal] </code><span class="type">void</span> QSensor::<span class="name">readingChanged</span>()</h3>
<p>This signal is emitted when a new sensor reading is received.</p>
<p>The sensor reading can be found in the <a href="qsensor.html#reading-prop" translate="no">QSensor::reading</a> property. Note that the reading object is a volatile cache of the most recent sensor reading that has been received so the application should process the reading immediately or save the values somewhere for later processing.</p>
<p>Before this signal has been emitted for the first time, the reading object will have uninitialized data.</p>
<div class="admonition note"><p><b>Note: </b>Notifier signal for property <a href="qsensor.html#reading-prop" translate="no">reading</a>. </p>
</div><p><b>See also </b><a href="qsensor.html#start" translate="no">start</a>().</p>
<!-- @@@readingChanged -->
<!-- $$$removeFilter[overload1]$$$removeFilterQSensorFilter* -->
<h3 class="fn" translate="no" id="removeFilter"><span class="type">void</span> QSensor::<span class="name">removeFilter</span>(<span class="type"><a href="qsensorfilter.html" translate="no">QSensorFilter</a></span> *<i>filter</i>)</h3>
<p>Remove <i translate="no">filter</i> from the sensor.</p>
<p><b>See also </b><a href="qsensorfilter.html" translate="no">QSensorFilter</a>.</p>
<!-- @@@removeFilter -->
<!-- $$$sensorError -->
<h3 class="fn" translate="no" id="sensorError"><code translate="no">[signal] </code><span class="type">void</span> QSensor::<span class="name">sensorError</span>(<span class="type">int</span> <i>error</i>)</h3>
<p>This signal is emitted when an <i translate="no">error</i> code is set on the sensor. Note that some errors will cause the sensor to stop working. You should call <a href="qsensor.html#active-prop" translate="no">isActive</a>() to determine if the sensor is still running.</p>
<div class="admonition note"><p><b>Note: </b>Notifier signal for property <a href="qsensor.html#error-prop" translate="no">error</a>. </p>
</div><!-- @@@sensorError -->
<!-- $$$sensorTypes[overload1]$$$sensorTypes -->
<h3 class="fn" translate="no" id="sensorTypes"><code translate="no">[static] </code><span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span>&gt; QSensor::<span class="name">sensorTypes</span>()</h3>
<p>Returns a list of all sensor types.</p>
<!-- @@@sensorTypes -->
<!-- $$$sensorsForType[overload1]$$$sensorsForTypeconstQByteArray& -->
<h3 class="fn" translate="no" id="sensorsForType"><code translate="no">[static] </code><span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span>&lt;<span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span>&gt; QSensor::<span class="name">sensorsForType</span>(const <span class="type"><a href="../qtcore/qbytearray.html" translate="no">QByteArray</a></span> &amp;<i>type</i>)</h3>
<p>Returns a list of ids for each of the sensors for <i translate="no">type</i>. If there are no sensors of that type available the list will be empty.</p>
<!-- @@@sensorsForType -->
<!-- $$$setCurrentOrientation[overload1]$$$setCurrentOrientationint -->
<h3 class="fn" translate="no" id="setCurrentOrientation"><span class="type">void</span> QSensor::<span class="name">setCurrentOrientation</span>(<span class="type">int</span> <i>currentOrientation</i>)</h3>
<p>Sets the current screen orientation to <i translate="no">currentOrientation</i>. This is to be called from the backend whenever the screen orientation or the <a href="qsensor.html#userOrientation-prop" translate="no">userOrientation</a> property changes.</p>
<p><b>See also </b><a href="qsensor.html#currentOrientation-prop" translate="no">currentOrientation</a>().</p>
<!-- @@@setCurrentOrientation -->
<!-- $$$setEfficientBufferSize[overload1]$$$setEfficientBufferSizeint -->
<h3 class="fn" translate="no" id="setEfficientBufferSize"><span class="type">void</span> QSensor::<span class="name">setEfficientBufferSize</span>(<span class="type">int</span> <i>efficientBufferSize</i>)</h3>
<p>Sets the efficient buffer size to <i translate="no">efficientBufferSize</i>. This is to be called from the backend.</p>
<p><b>See also </b><a href="qsensor.html#efficientBufferSize-prop" translate="no">efficientBufferSize</a>().</p>
<!-- @@@setEfficientBufferSize -->
<!-- $$$setMaxBufferSize[overload1]$$$setMaxBufferSizeint -->
<h3 class="fn" translate="no" id="setMaxBufferSize"><span class="type">void</span> QSensor::<span class="name">setMaxBufferSize</span>(<span class="type">int</span> <i>maxBufferSize</i>)</h3>
<p>Sets the maximum buffer size to <i translate="no">maxBufferSize</i>. This is to be called from the backend.</p>
<p><b>See also </b><a href="qsensor.html#maxBufferSize-prop" translate="no">maxBufferSize</a>().</p>
<!-- @@@setMaxBufferSize -->
<!-- $$$setSkipDuplicates -->
<h3 class="fn" translate="no" id="setSkipDuplicates"><span class="type">void</span> QSensor::<span class="name">setSkipDuplicates</span>(<span class="type">bool</span> <i>skipDuplicates</i>)</h3>
<p>Sets the duplicate skipping to <i translate="no">skipDuplicates</i>.</p>
<div class="admonition note"><p><b>Note: </b>Setter function for property <a href="qsensor.html#skipDuplicates-prop" translate="no">skipDuplicates</a>. </p>
</div><p><b>See also </b><a href="qsensor.html#skipDuplicates-prop" translate="no">skipDuplicates</a>().</p>
<!-- @@@setSkipDuplicates -->
<!-- $$$skipDuplicatesChanged -->
<h3 class="fn" translate="no" id="skipDuplicatesChanged"><code translate="no">[signal] </code><span class="type">void</span> QSensor::<span class="name">skipDuplicatesChanged</span>(<span class="type">bool</span> <i>skipDuplicates</i>)</h3>
<p>This signal is emitted when the <i translate="no">skipDuplicates</i> property changes.</p>
<div class="admonition note"><p><b>Note: </b>Notifier signal for property <a href="qsensor.html#skipDuplicates-prop" translate="no">skipDuplicates</a>. </p>
</div><!-- @@@skipDuplicatesChanged -->
<!-- $$$start[overload1]$$$start -->
<h3 class="fn" translate="no" id="start"><code translate="no">[slot] </code><span class="type">bool</span> QSensor::<span class="name">start</span>()</h3>
<p>Start retrieving values from the sensor. Returns true if the sensor was started, false otherwise.</p>
<p>The sensor may fail to start for several reasons.</p>
<p>Once an application has started a sensor it must wait until the sensor receives a new value before it can query the sensor's values. This is due to how the sensor receives values from the system. Sensors do not (in general) poll for new values, rather new values are pushed to the sensors as they happen.</p>
<p>For example, this code will not work as intended.</p>
<pre class="cpp plain" translate="no">
 sensor-&gt;start();
 sensor-&gt;reading()-&gt;x(); // no data available
</pre>
<p>To work correctly, the code that accesses the reading should ensure the <a href="qsensor.html#readingChanged" translate="no">readingChanged</a>() signal has been emitted.</p>
<pre class="cpp" translate="no">
     connect(sensor<span class="operator">,</span> SIGNAL(readingChanged())<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> SLOT(checkReading()));
     sensor<span class="operator">-</span><span class="operator">&gt;</span>start();
 }
 <span class="type">void</span> MyClass<span class="operator">::</span>checkReading() {
     sensor<span class="operator">-</span><span class="operator">&gt;</span>reading()<span class="operator">-</span><span class="operator">&gt;</span>x();
</pre>
<p><b>See also </b><a href="qsensor.html#busy-prop" translate="no">QSensor::busy</a>.</p>
<!-- @@@start -->
<!-- $$$stop[overload1]$$$stop -->
<h3 class="fn" translate="no" id="stop"><code translate="no">[slot] </code><span class="type">void</span> QSensor::<span class="name">stop</span>()</h3>
<p>Stop retrieving values from the sensor.</p>
<p>This releases the sensor so that other processes can use it.</p>
<p><b>See also </b><a href="qsensor.html#busy-prop" translate="no">QSensor::busy</a>.</p>
<!-- @@@stop -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qoutputrangelist -->
<h3 class="fn" translate="no" id="qoutputrangelist-typedef"><code translate="no">[alias] </code><span class="name">qoutputrangelist</span></h3>
<p>This type is defined as a list of qoutputrange values.</p>
<pre class="cpp" translate="no">
 <span class="keyword">typedef</span> <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span>qoutputrange<span class="operator">&gt;</span> qoutputrangelist;
</pre>
<p><b>See also </b><a href="../qtcore/qlist.html" translate="no">QList</a>, <a href="qoutputrange.html" translate="no">qoutputrange</a>, and <a href="qsensor.html#outputRanges-prop" translate="no">QSensor::outputRanges</a>.</p>
<!-- @@@qoutputrangelist -->
<!-- $$$qrange -->
<h3 class="fn" translate="no" id="qrange-typedef"><code translate="no">[alias] </code><span class="name">qrange</span></h3>
<p>This type is defined as a <a href="../qtcore/qpair-proxy.html#QPair-typedef" translate="no">QPair</a>.</p>
<pre class="cpp" translate="no">
 <span class="keyword">typedef</span> <span class="type"><a href="../qtcore/qpair-proxy.html#QPair-typedef" translate="no">QPair</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span><span class="type">int</span><span class="operator">&gt;</span> qrange;
</pre>
<p><b>See also </b><a href="../qtcore/qpair-proxy.html" translate="no">QPair</a>, <a href="qsensor.html#qrangelist-typedef" translate="no">qrangelist</a>, and <a href="qsensor.html#availableDataRates-prop" translate="no">QSensor::availableDataRates</a>.</p>
<!-- @@@qrange -->
<!-- $$$qrangelist -->
<h3 class="fn" translate="no" id="qrangelist-typedef"><code translate="no">[alias] </code><span class="name">qrangelist</span></h3>
<p>This type is defined as a list of qrange values.</p>
<pre class="cpp" translate="no">
 <span class="keyword">typedef</span> <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span>qrange<span class="operator">&gt;</span> qrangelist;
</pre>
<p><b>See also </b><a href="../qtcore/qlist.html" translate="no">QList</a>, <a href="qsensor.html#qrange-typedef" translate="no">qrange</a>, and <a href="qsensor.html#availableDataRates-prop" translate="no">QSensor::availableDataRates</a>.</p>
<!-- @@@qrangelist -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2023 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
