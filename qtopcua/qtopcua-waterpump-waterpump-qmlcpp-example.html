<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- waterpump-qmlcpp.qdoc -->
  <meta name="description" content="Interacting with an OPC UA server to build a QML-based HMI for a simple machine.">
  <title>Waterpump Example | Qt OPC UA 6.6.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.6</a></li>
<li><a href="qtopcua-index.html" translate="no">Qt OPC UA</a></li>
<li><a href="qtopcua-examples.html" translate="no">Qt OPC UA Examples</a></li>
<li>Waterpump Example</li>
<li id="buildversion"><a href="qtopcua-index.html" translate="no">Qt 6.6&#x2e;0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#building-the-server">Building the Server</a></li>
<li class="level1"><a href="#the-simulation">The Simulation</a></li>
<li class="level1"><a href="#client-features">Client Features</a></li>
<li class="level1"><a href="#implementation">Implementation</a></li>
<li class="level2"><a href="#member-variables">Member Variables</a></li>
<li class="level2"><a href="#asynchronous-handlers">Asynchronous Handlers</a></li>
<li class="level2"><a href="#interaction-with-the-server">Interaction with the Server</a></li>
<li class="level2"><a href="#the-hmi">The HMI</a></li>
<li class="level1"><a href="#usage">Usage</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Waterpump Example</h1>
<!-- $$$waterpump/waterpump-qmlcpp-brief -->
<p>Interacting with an OPC UA server to build a QML-based HMI for a simple machine.</p>
<!-- @@@waterpump/waterpump-qmlcpp -->
<!-- $$$waterpump/waterpump-qmlcpp-description -->
<div class="descr" id="details">
<p><i>Waterpump</i> shows how to use Qt OPC UA to interact with an OPC UA server to build a QML-based HMI for a simple machine.</p>
<h4 id="building-the-server">Building the Server</h4>
<p>Before you can use the waterpump examples, you need to build the simulation server. The simulator server project resides next to the waterpump examples. You can open and build it in QtCreator or from the terminal as usual.</p>
<h4 id="the-simulation">The Simulation</h4>
<p>The OPC UA server included in this example runs a simulation of a machine containing two tanks, a water pump, and a valve. Water can be pumped from the first tank into the second tank and then be flushed from the second tank by opening the valve. Both operations have a user-configurable setpoint which controls how much water is pumped to or flushed from the second tank.</p>
<p>The following nodes exist on the server:</p>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th ><a href="qml-qtopcua-nodeid.html" translate="no">NodeId</a></th><th >Function</th></tr></thead>
<tr valign="top" class="odd"><td >ns=2;s=Machine</td><td >The folder containing the method and variable nodes for the machine</td></tr>
<tr valign="top" class="even"><td >ns=2;s=Machine.State</td><td >The state of the machine</td></tr>
<tr valign="top" class="odd"><td >ns=2;s=Machine.Tank1.PercentFilled</td><td >The current fill status of the first tank</td></tr>
<tr valign="top" class="even"><td >ns=2;s=Machine.Tank2.PercentFilled</td><td >The current fill status of the second tank</td></tr>
<tr valign="top" class="odd"><td >ns=2;s=Machine.Tank2.TargetPercent</td><td >The setpoint for pumping and flushing</td></tr>
<tr valign="top" class="even"><td >ns=2;s=Machine.Tank2.ValveState</td><td >The state of the valve of the second tank</td></tr>
<tr valign="top" class="odd"><td >ns=2;s=Machine.Designation</td><td >A human readable designation of the machine for display purposes</td></tr>
<tr valign="top" class="even"><td >ns=2;s=Machine.Start</td><td >Call this method to start the pump</td></tr>
<tr valign="top" class="odd"><td >ns=2;s=Machine.Stop</td><td >Call this method to stop the pump</td></tr>
<tr valign="top" class="even"><td >ns=2;s=Machine.FlushTank2</td><td >Call this method to flush tank 2</td></tr>
</table></div>
<p>All methods return <a href="qopcua.html#UaStatusCode-enum" translate="no">Good</a> in case of success and <a href="qopcua.html#UaStatusCode-enum" translate="no">BadUserAccessDenied</a> if the operation is illegal (for example, trying to start the pump if the first tank is empty).</p>
<h4 id="client-features">Client Features</h4>
<p>This example uses read, write, method calls, and data change subscriptions and shows how to set up handlers for the asynchronous operations offered by <a href="qopcuaclient.html" translate="no">QOpcUaClient</a> and <a href="qopcuanode.html" translate="no">QOpcUaNode</a>.</p>
<h4 id="implementation">Implementation</h4>
<p>A backend class is used to handle the communication with the OPC UA server and expose the content of this server by means of properties and <code translate="no">Q_INVOKABLE</code> methods wrapping the OPC UA method calls.</p>
<h5 id="member-variables">Member Variables</h5>
<p>A pointer to <a href="qopcuaclient.html" translate="no">QOpcUaClient</a> is required for connection management. An additional pointer to a <a href="qopcuanode.html" translate="no">QOpcUaNode</a> object is needed for each OPC UA node the HMI interacts with. For the values of these nodes, member variables containing the last value reported by the server are added.</p>
<pre class="cpp" translate="no">
     ...
     <span class="type"><a href="../qtcore/qscopedpointer.html" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="qopcuaclient.html" translate="no">QOpcUaClient</a></span><span class="operator">&gt;</span> m_client;
     <span class="type"><a href="../qtcore/qscopedpointer.html" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="qopcuanode.html" translate="no">QOpcUaNode</a></span><span class="operator">&gt;</span> m_machineStateNode;
     <span class="type"><a href="../qtcore/qscopedpointer.html" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="qopcuanode.html" translate="no">QOpcUaNode</a></span><span class="operator">&gt;</span> m_percentFilledTank1Node;
     <span class="type"><a href="../qtcore/qscopedpointer.html" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="qopcuanode.html" translate="no">QOpcUaNode</a></span><span class="operator">&gt;</span> m_percentFilledTank2Node;
     <span class="type"><a href="../qtcore/qscopedpointer.html" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="qopcuanode.html" translate="no">QOpcUaNode</a></span><span class="operator">&gt;</span> m_tank2TargetPercentNode;
     <span class="type"><a href="../qtcore/qscopedpointer.html" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="qopcuanode.html" translate="no">QOpcUaNode</a></span><span class="operator">&gt;</span> m_tank2ValveStateNode;
     <span class="type"><a href="../qtcore/qscopedpointer.html" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="qopcuanode.html" translate="no">QOpcUaNode</a></span><span class="operator">&gt;</span> m_machineNode;
     <span class="type"><a href="../qtcore/qscopedpointer.html" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="qopcuanode.html" translate="no">QOpcUaNode</a></span><span class="operator">&gt;</span> m_machineDesignationNode;
     <span class="type">double</span> m_percentFilledTank1;
     <span class="type">double</span> m_percentFilledTank2;
     <span class="type">double</span> m_tank2TargetPercent;
     <span class="type">bool</span> m_tank2ValveState;
     MachineState m_machineState;
     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> m_machineDesignation;
     ...
</pre>
<p>For each value used in the HMI, a getter, a changed signal, and a property are added to enable property bindings in QML</p>
<pre class="cpp" translate="no">
     ...
     Q_PROPERTY(<span class="type">double</span> percentFilledTank1 READ percentFilledTank1 NOTIFY percentFilledTank1Changed)
     Q_PROPERTY(<span class="type">double</span> percentFilledTank2 READ percentFilledTank2 NOTIFY percentFilledTank2Changed)
     Q_PROPERTY(<span class="type">double</span> tank2TargetPercent READ tank2TargetPercent NOTIFY tank2TargetPercentChanged)
     Q_PROPERTY(OpcUaMachineBackend<span class="operator">::</span>MachineState machineState READ machineState NOTIFY machineStateChanged)
     Q_PROPERTY(<span class="type">bool</span> tank2ValveState READ tank2ValveState NOTIFY tank2ValveStateChanged)
     Q_PROPERTY(<span class="type">bool</span> connected READ connected NOTIFY connectedChanged)
     Q_PROPERTY(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> machineDesignation READ machineDesignation NOTIFY machineDesignationChanged)
     Q_PROPERTY(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> message READ message NOTIFY messageChanged)
     ...
</pre>
<h5 id="asynchronous-handlers">Asynchronous Handlers</h5>
<p>The asynchronous API of Qt OPC UA requires signal handlers for all operations.</p>
<p>Data change subscriptions report their updates using <a href="qopcuanode.html#attributeUpdated" translate="no">QOpcUaNode::attributeUpdated</a>. A handler connected to this signal gets the new value as <a href="../qtcore/qvariant.html" translate="no">QVariant</a> and can write that value to a variable or emit a signal with the new value, for example.</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> OpcUaMachineBackend<span class="operator">::</span>percentFilledTank1Updated(<span class="type"><a href="qopcua.html" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute attr<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qvariant.html" translate="no">QVariant</a></span> <span class="operator">&amp;</span>value)
 {
     Q_UNUSED(attr);
     m_percentFilledTank1 <span class="operator">=</span> value<span class="operator">.</span>toDouble();
     <span class="keyword">emit</span> percentFilledTank1Changed(m_percentFilledTank1);
 }
</pre>
<p>A read operation emits the <a href="qopcuanode.html#attributeRead" translate="no">QOpcUaNode::attributeRead</a> signal on completion. The client has to check the status code and then get the result from the node.</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> OpcUaMachineBackend<span class="operator">::</span>machineDesignationRead(<span class="type"><a href="qopcua.html" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttributes attr)
 {
     <span class="keyword">if</span> (attr <span class="operator">&amp;</span> <span class="type"><a href="qopcua.html" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value) { <span class="comment">// Make sure the value attribute has been read</span>
         <span class="keyword">if</span> (m_machineDesignationNode<span class="operator">-</span><span class="operator">&gt;</span>attributeError(<span class="type"><a href="qopcua.html" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value) <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qopcua.html" translate="no">QOpcUa</a></span><span class="operator">::</span>UaStatusCode<span class="operator">::</span>Good) { <span class="comment">// Make sure there was no error</span>
             m_machineDesignation <span class="operator">=</span> m_machineDesignationNode<span class="operator">-</span><span class="operator">&gt;</span>attribute(<span class="type"><a href="qopcua.html" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value)<span class="operator">.</span>toString(); <span class="comment">// Get the attribute from the cache</span>
             <span class="keyword">emit</span> machineDesignationChanged(m_machineDesignation);
         }
     }
 }
</pre>
<h5 id="interaction-with-the-server">Interaction with the Server</h5>
<p>In the constructor, a <a href="qopcuaprovider.html" translate="no">QOpcUaProvider</a> is created and the available backends are saved to provide a model for the backend selection dropdown menu.</p>
<pre class="cpp" translate="no">
     ...
     <span class="type"><a href="qopcuaprovider.html" translate="no">QOpcUaProvider</a></span> provider;
     setBackends(provider<span class="operator">.</span>availableBackends());
     ...
</pre>
<p>Before attempting a connection, a <a href="qopcuaclient.html" translate="no">QOpcUaClient</a> with the selected backend is created. Its <a href="qopcuaclient.html#endpointsRequestFinished" translate="no">QOpcUaClient::endpointsRequestFinished</a> signal is connected to the backend's <code translate="no">requestEndpointsFinished</code> slot. The <a href="qopcuaclient.html#state-prop" translate="no">QOpcUaClient::stateChanged</a> signal must be connected to the backend's <code translate="no">clientStateHandler</code> slot.</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> OpcUaMachineBackend<span class="operator">::</span>connectToEndpoint(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> <span class="operator">&amp;</span>url<span class="operator">,</span> <span class="type"><a href="../qtcore/qttypes.html#qint32-typedef" translate="no">qint32</a></span> index)
 {
     <span class="keyword">if</span> (m_connected)
         <span class="keyword">return</span>;

     <span class="type"><a href="qopcuaprovider.html" translate="no">QOpcUaProvider</a></span> provider;

     <span class="keyword">if</span> (index <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> index <span class="operator">&gt;</span><span class="operator">=</span> m_backends<span class="operator">.</span>size())
         <span class="keyword">return</span>; <span class="comment">// Invalid index</span>

     <span class="keyword">if</span> (<span class="operator">!</span>m_client <span class="operator">|</span><span class="operator">|</span> (m_client <span class="operator">&amp;</span><span class="operator">&amp;</span> m_client<span class="operator">-</span><span class="operator">&gt;</span>backend() <span class="operator">!</span><span class="operator">=</span> m_backends<span class="operator">.</span>at(index))) {
         m_client<span class="operator">.</span>reset(provider<span class="operator">.</span>createClient(m_backends<span class="operator">.</span>at(index)));
         <span class="keyword">if</span> (m_client) {
             <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span><span class="operator">::</span>connect(m_client<span class="operator">.</span>data()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qopcuaclient.html" translate="no">QOpcUaClient</a></span><span class="operator">::</span>endpointsRequestFinished<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>OpcUaMachineBackend<span class="operator">::</span>requestEndpointsFinished);
             <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span><span class="operator">::</span>connect(m_client<span class="operator">.</span>data()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qopcuaclient.html" translate="no">QOpcUaClient</a></span><span class="operator">::</span>stateChanged<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>OpcUaMachineBackend<span class="operator">::</span>clientStateHandler);
         }
     }

     <span class="keyword">if</span> (<span class="operator">!</span>m_client) {
         <a href="../qtcore/qtlogging.html#qWarning" translate="no">qWarning</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Could not create client&quot;</span>;
         m_successfullyCreated <span class="operator">=</span> <span class="keyword">false</span>;
         <span class="keyword">return</span>;
     }

     m_successfullyCreated <span class="operator">=</span> <span class="keyword">true</span>;
     m_client<span class="operator">-</span><span class="operator">&gt;</span>requestEndpoints(url);
 }
</pre>
<p>The <code translate="no">OpcUaMachineBackend::requestEndpointsFinished</code> slot receives the list of available endpoints on the server and starts a connection to the first entry in the list. If there are no available endpoints, the connection establishment is aborted.</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> OpcUaMachineBackend<span class="operator">::</span>requestEndpointsFinished(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qlist.html" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qopcuaendpointdescription.html" translate="no">QOpcUaEndpointDescription</a></span><span class="operator">&gt;</span> <span class="operator">&amp;</span>endpoints)
 {
     <span class="keyword">if</span> (endpoints<span class="operator">.</span>isEmpty()) {
        <a href="../qtcore/qtlogging.html#qWarning" translate="no">qWarning</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;The server did not return any endpoints&quot;</span>;
        clientStateHandler(<span class="type"><a href="qopcuaclient.html" translate="no">QOpcUaClient</a></span><span class="operator">::</span>ClientState<span class="operator">::</span>Disconnected);
        <span class="keyword">return</span>;
     }
     m_client<span class="operator">-</span><span class="operator">&gt;</span>connectToEndpoint(endpoints<span class="operator">.</span>at(<span class="number">0</span>));
 }
</pre>
<p><code translate="no">clientStateHandler</code> acts on <a href="qopcuaclient.html" translate="no">QOpcUaClient</a> being connected or disconnected. In case of a successful connection, the node member variables created before are filled with node objects.</p>
<pre class="cpp" translate="no">
     ...
     <span class="keyword">if</span> (state <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qopcuaclient.html" translate="no">QOpcUaClient</a></span><span class="operator">::</span>ClientState<span class="operator">::</span>Connected) {
         setMessage(<span class="string">&quot;Connected&quot;</span>);
         <span class="comment">// Create node objects for reading, writing and subscriptions</span>
         m_machineNode<span class="operator">.</span>reset(m_client<span class="operator">-</span><span class="operator">&gt;</span>node(<span class="string">&quot;ns=2;s=Machine&quot;</span>));
         m_machineStateNode<span class="operator">.</span>reset(m_client<span class="operator">-</span><span class="operator">&gt;</span>node(<span class="string">&quot;ns=2;s=Machine.State&quot;</span>));
         m_percentFilledTank1Node<span class="operator">.</span>reset(m_client<span class="operator">-</span><span class="operator">&gt;</span>node(<span class="string">&quot;ns=2;s=Machine.Tank1.PercentFilled&quot;</span>));
         m_percentFilledTank2Node<span class="operator">.</span>reset(m_client<span class="operator">-</span><span class="operator">&gt;</span>node(<span class="string">&quot;ns=2;s=Machine.Tank2.PercentFilled&quot;</span>));
         m_tank2TargetPercentNode<span class="operator">.</span>reset(m_client<span class="operator">-</span><span class="operator">&gt;</span>node(<span class="string">&quot;ns=2;s=Machine.Tank2.TargetPercent&quot;</span>));
         m_tank2ValveStateNode<span class="operator">.</span>reset(m_client<span class="operator">-</span><span class="operator">&gt;</span>node(<span class="string">&quot;ns=2;s=Machine.Tank2.ValveState&quot;</span>));
         m_machineDesignationNode<span class="operator">.</span>reset(m_client<span class="operator">-</span><span class="operator">&gt;</span>node(<span class="string">&quot;ns=2;s=Machine.Designation&quot;</span>));
     ...
</pre>
<p>After all node objects have been created, the data change handlers are connected to the node objects and monitoring is enabled.</p>
<pre class="cpp" translate="no">
     ...
         <span class="comment">// Connect signal handlers for subscribed values</span>
         <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span><span class="operator">::</span>connect(m_machineStateNode<span class="operator">.</span>data()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qopcuanode.html" translate="no">QOpcUaNode</a></span><span class="operator">::</span>dataChangeOccurred<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>OpcUaMachineBackend<span class="operator">::</span>machineStateUpdated);
         <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span><span class="operator">::</span>connect(m_percentFilledTank1Node<span class="operator">.</span>data()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qopcuanode.html" translate="no">QOpcUaNode</a></span><span class="operator">::</span>dataChangeOccurred<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>OpcUaMachineBackend<span class="operator">::</span>percentFilledTank1Updated);
         <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span><span class="operator">::</span>connect(m_percentFilledTank2Node<span class="operator">.</span>data()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qopcuanode.html" translate="no">QOpcUaNode</a></span><span class="operator">::</span>dataChangeOccurred<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>OpcUaMachineBackend<span class="operator">::</span>percentFilledTank2Updated);
         <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span><span class="operator">::</span>connect(m_tank2TargetPercentNode<span class="operator">.</span>data()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qopcuanode.html" translate="no">QOpcUaNode</a></span><span class="operator">::</span>dataChangeOccurred<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>OpcUaMachineBackend<span class="operator">::</span>tank2TargetPercentUpdated);
         <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span><span class="operator">::</span>connect(m_tank2ValveStateNode<span class="operator">.</span>data()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qopcuanode.html" translate="no">QOpcUaNode</a></span><span class="operator">::</span>dataChangeOccurred<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>OpcUaMachineBackend<span class="operator">::</span>tank2ValveStateUpdated);

         <span class="comment">// Subscribe to data changes</span>
         m_machineStateNode<span class="operator">-</span><span class="operator">&gt;</span>enableMonitoring(<span class="type"><a href="qopcua.html" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value<span class="operator">,</span> <span class="type"><a href="qopcuamonitoringparameters.html" translate="no">QOpcUaMonitoringParameters</a></span>(<span class="number">100</span>));
         m_percentFilledTank1Node<span class="operator">-</span><span class="operator">&gt;</span>enableMonitoring(<span class="type"><a href="qopcua.html" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value<span class="operator">,</span> <span class="type"><a href="qopcuamonitoringparameters.html" translate="no">QOpcUaMonitoringParameters</a></span>(<span class="number">100</span>));
         m_percentFilledTank2Node<span class="operator">-</span><span class="operator">&gt;</span>enableMonitoring(<span class="type"><a href="qopcua.html" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value<span class="operator">,</span> <span class="type"><a href="qopcuamonitoringparameters.html" translate="no">QOpcUaMonitoringParameters</a></span>(<span class="number">100</span>));
         m_tank2TargetPercentNode<span class="operator">-</span><span class="operator">&gt;</span>enableMonitoring(<span class="type"><a href="qopcua.html" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value<span class="operator">,</span> <span class="type"><a href="qopcuamonitoringparameters.html" translate="no">QOpcUaMonitoringParameters</a></span>(<span class="number">100</span>));
         m_tank2ValveStateNode<span class="operator">-</span><span class="operator">&gt;</span>enableMonitoring(<span class="type"><a href="qopcua.html" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value<span class="operator">,</span> <span class="type"><a href="qopcuamonitoringparameters.html" translate="no">QOpcUaMonitoringParameters</a></span>(<span class="number">100</span>));
     ...
</pre>
<p>The machine designation is not supposed to change and will be read once at startup.</p>
<pre class="cpp" translate="no">
     ...
         <span class="comment">// Connect the handler for async reading</span>
         <span class="type"><a href="../qtcore/qobject.html" translate="no">QObject</a></span><span class="operator">::</span>connect(m_machineDesignationNode<span class="operator">.</span>data()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qopcuanode.html" translate="no">QOpcUaNode</a></span><span class="operator">::</span>attributeRead<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>OpcUaMachineBackend<span class="operator">::</span>machineDesignationRead);
         <span class="comment">// Request the value attribute of the machine designation node</span>
         m_machineDesignationNode<span class="operator">-</span><span class="operator">&gt;</span>readAttributes(<span class="type"><a href="qopcua.html" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value);
     ...
</pre>
<p>A setter for the setpoint is added to the backend.</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> OpcUaMachineBackend<span class="operator">::</span>machineWriteTank2TargetPercent(<span class="type">double</span> value)
 {
     <span class="keyword">if</span> (m_tank2TargetPercentNode)
         m_tank2TargetPercentNode<span class="operator">-</span><span class="operator">&gt;</span>writeAttribute(<span class="type"><a href="qopcua.html" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value<span class="operator">,</span> value);
 }
</pre>
<p>For the methods, wrappers which call the OPC UA server method are created.</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> OpcUaMachineBackend<span class="operator">::</span>startPump()
 {
     m_machineNode<span class="operator">-</span><span class="operator">&gt;</span>callMethod(<span class="string">&quot;ns=2;s=Machine.Start&quot;</span>);
 }
</pre>
<h5 id="the-hmi">The HMI</h5>
<p>A backend instance is created and handed to the QML part as a context property named <code translate="no">uaBackend</code>.</p>
<pre class="cpp" translate="no">
     ...
     OpcUaMachineBackend backend;

     <span class="type"><a href="../qtqml/qqmlapplicationengine.html" translate="no">QQmlApplicationEngine</a></span> engine;
     engine<span class="operator">.</span>rootContext()<span class="operator">-</span><span class="operator">&gt;</span>setContextProperty(<span class="string">&quot;uaBackend&quot;</span><span class="operator">,</span> <span class="operator">&amp;</span>backend);
     ...
</pre>
<p>The properties, signals and <code translate="no">Q_INVOKABLE</code> methods of uaBackend can now be accessed by the QML code. For example, the button to flush the second tank is enabled only if the backend is connected to the server, the machine is idle and the tank level is above the setpoint. On click, the <code translate="no">flushTank2()</code> method is called on the server.</p>
<pre class="cpp" translate="no">
         <span class="type">Button</span> {
             <span class="name">id</span>: <span class="name">flushButton</span>
             <span class="name">text</span>: <span class="string">&quot;Flush&quot;</span>
             <span class="name">enabled</span>: <span class="name">uaBackend</span>.<span class="name">connected</span> <span class="operator">&amp;&amp;</span> <span class="name">uaBackend</span>.<span class="name">machineState</span> <span class="operator">===</span> <span class="name">OpcUaMachineBackend</span>.<span class="name">MachineState</span>.<span class="name">Idle</span> <span class="operator">&amp;&amp;</span> <span class="name">uaBackend</span>.<span class="name">percentFilledTank2</span> <span class="operator">&gt;</span> <span class="name">uaBackend</span>.<span class="name">tank2TargetPercent</span>
             <span class="name">onClicked</span>: {
                 <span class="name">uaBackend</span>.<span class="name">flushTank2</span>()
             }
         }
</pre>
<p>Signals from the backend can also be used directly in the QML code.</p>
<pre class="cpp" translate="no">
     <span class="type"><a href="../qtqml/qml-qtqml-connections.html" translate="no">Connections</a></span> {
         <span class="name">target</span>: <span class="name">uaBackend</span>
         <span class="name">onPercentFilledTank2Changed</span>: {
             <span class="keyword">if</span> (<span class="name">uaBackend</span>.<span class="name">machineState</span> <span class="operator">===</span> <span class="name">OpcUaMachineBackend</span>.<span class="name">MachineState</span>.<span class="name">Pumping</span>)
                 <span class="name">rotation</span> <span class="operator">+=</span> <span class="number">15</span>
         }
     }
</pre>
<h4 id="usage">Usage</h4>
<p>The server is started automatically by the HMI application. After connecting to the server by clicking the <b translate="no">Connect</b> button, drag the slider to set a setpoint, then click <b translate="no">Start</b> to start pumping water from the first tank to the second tank. After setting a setpoint lower than the current value of the second tank, a click on <b translate="no">Flush</b> opens the valve.</p>
<p>If there is no water left, click <b translate="no">Reset simulation</b> to refill the first tank.</p>
<p class="centerAlign"><img src="images/tankexample.jpg" alt="" /></p><p>Files:</p>
<ul>
<li><a href="qtopcua-waterpump-waterpump-qmlcpp-cmakelists-txt.html" translate="no">waterpump/waterpump-qmlcpp/CMakeLists.txt</a></li>
<li><a href="qtopcua-waterpump-waterpump-qmlcpp-main-cpp.html" translate="no">waterpump/waterpump-qmlcpp/main.cpp</a></li>
<li><a href="qtopcua-waterpump-waterpump-qmlcpp-opcuamachinebackend-cpp.html" translate="no">waterpump/waterpump-qmlcpp/opcuamachinebackend.cpp</a></li>
<li><a href="qtopcua-waterpump-waterpump-qmlcpp-qml-qrc.html" translate="no">waterpump/waterpump-qmlcpp/qml.qrc</a></li>
<li><a href="qtopcua-waterpump-waterpump-qmlcpp-waterpump-qmlcpp-pro.html" translate="no">waterpump/waterpump-qmlcpp/waterpump-qmlcpp.pro</a></li>
</ul>
</div>
<!-- @@@waterpump/waterpump-qmlcpp -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2023 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
