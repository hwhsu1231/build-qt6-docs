<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- rogue.qdoc -->
  <meta name="description" content="The Rogue example shows how to use the Qt state machine for event handling.">
  <title>Rogue | Qt State Machine 6.6.2</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.6</a></li>
<li><a href="qtstatemachine-index.html" translate="no">Qt State Machine</a></li>
<li><a href="examples-qtstatemachine.html" translate="no">Qt State Machine Examples</a></li>
<li>Rogue</li>
<li id="buildversion"><a href="qtstatemachine-index.html" translate="no">Qt 6.6.2 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#window-class-definition">Window Class Definition</a></li>
<li class="level1"><a href="#window-class-implementation">Window Class Implementation</a></li>
<li class="level1"><a href="#the-movementtransition-class">The MovementTransition Class</a></li>
<li class="level1"><a href="#the-roguelike-tradition">The Roguelike Tradition</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Rogue</h1>
<!-- $$$rogue-brief -->
<p>The Rogue example shows how to use the Qt state machine for event handling.</p>
<!-- @@@rogue -->
<!-- $$$rogue-description -->
<div class="descr" id="details">
<p class="centerAlign"><img src="images/rogue-example.png" alt="" /></p><p>This example implements a simple text based game. Do you see the <code translate="no">@</code> in the screenshot? That's you, the rogue. The <code translate="no">#</code> characters are walls, and the dots represent floor. In a real game, other ASCII characters would represent all kinds of objects and creatures, for instance, ancient dragons (<code translate="no">D</code>s) or food rations (<code translate="no">%</code>s). But let's not get carried away. In this game, the rogue is simply running around in an empty room.</p>
<p>The rogue is moved with the keypad (2, 4, 8, 6). That aside, we have implemented a <code translate="no">quit</code> command that triggers if the player types <code translate="no">q</code>. The player is then asked if he/she really wants to quit.</p>
<p>Most games have commands that need more than one key press (we think of consecutive presses, i.e., not of several keys being pressed at the same time). In this game, only the <code translate="no">quit</code> command falls under this category, but for the sake of argument, let's imagine a fully-fledged game with a rich set of commands. If we were to implement these by catching key events in <a href="../qtwidgets/qwidget.html#keyPressEvent" translate="no">keyPressEvent</a>(), we would have to keep a lot of class member variables to track the sequence of keys already typed (or find some other way of deducing the current state of a command). This can easily lead to spaghetti, which is&ndash;as we all well know, I'm sure&ndash;unpleasant. With a state machine, on the other hand, separate states can wait for a single key press, and that makes our lives a lot simpler.</p>
<p>The example consists of two classes:</p>
<ul>
<li><code translate="no">Window</code> draws the text display of the game and sets up the state machine. The window also has a status bar above the area in which the rouge moves.</li>
<li><code translate="no">MovementTransition</code> is a transition that carries out a single move of the rogue.</li>
</ul>
<p>Before we embark on a code walkthrough, it is necessary to take a closer look at the design of the machine. Here is a state chart that shows what we want to achieve:</p>
<p class="centerAlign"><img src="images/rogue-statechart.png" alt="" /></p><p>The input state waits for a key press to start a new command. When receiving a key it recognizes, it transitions to one of the two commands of the game; though, as we will see, movement is handled by the transition itself. The quit state waits for the player to answer yes or no (by typing <code translate="no">y</code> or <code translate="no">n</code>) when asked whether he/she really wants to quit the game.</p>
<p>The chart demonstrates how we use one state to wait for a single key press. The press received may trigger one of the transitions connected to the state.</p>
<h4 id="window-class-definition">Window Class Definition</h4>
<p>The <code translate="no">Window</code> class is a widget that draws the text display of the game. It also sets up the state machine, i.e., creates and connects the states in the machine. It is the key events from this widget that are used by the machine.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> Window : <span class="keyword">public</span> <span class="type"><a href="../qtwidgets/qwidget.html" translate="no">QWidget</a></span>
 {
     Q_OBJECT
     Q_PROPERTY(<span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> status READ status WRITE setStatus)

 <span class="keyword">public</span>:
     <span class="keyword">enum</span> Direction { Up<span class="operator">,</span> Down<span class="operator">,</span> Left<span class="operator">,</span> Right };

     Window();

     <span class="type">void</span> movePlayer(Direction direction);
     <span class="type">void</span> setStatus(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> <span class="operator">&amp;</span>status);
     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> status() <span class="keyword">const</span>;

     <span class="type"><a href="../qtcore/qsize.html" translate="no">QSize</a></span> sizeHint() <span class="keyword">const</span> override;

 <span class="keyword">protected</span>:
     <span class="type">void</span> paintEvent(<span class="type"><a href="../qtgui/qpaintevent.html" translate="no">QPaintEvent</a></span> <span class="operator">*</span>event) override;
</pre>
<p><code translate="no">Direction</code> specifies the direction in which the rogue is to move. We use this in <code translate="no">movePlayer()</code>, which moves the rogue and repaints the window. The game has a status line above the area in which the rogue moves. The <code translate="no">status</code> property contains the text of this line. We use a property because the <a href="qstate.html" translate="no">QState</a> class allows setting any Qt <a href="../qtcore/properties.html" translate="no">property</a> when entered. More on this later.</p>
<pre class="cpp" translate="no">
 <span class="keyword">private</span>:
     <span class="type">void</span> buildMachine();
     <span class="type">void</span> setupMap();

     <span class="keyword">static</span> constexpr <span class="type">int</span> WIDTH <span class="operator">=</span> <span class="number">35</span>;
     <span class="keyword">static</span> constexpr <span class="type">int</span> HEIGHT <span class="operator">=</span> <span class="number">20</span>;

     <span class="type"><a href="../qtcore/qchar.html" translate="no">QChar</a></span> map<span class="operator">[</span>WIDTH<span class="operator">]</span><span class="operator">[</span>HEIGHT<span class="operator">]</span>;
     <span class="type">int</span> pX <span class="operator">=</span> <span class="number">5</span>;
     <span class="type">int</span> pY <span class="operator">=</span> <span class="number">5</span>;

     <span class="type"><a href="qstatemachine.html" translate="no">QStateMachine</a></span> <span class="operator">*</span>machine;
     <span class="type"><a href="../qtcore/qstring.html" translate="no">QString</a></span> myStatus;
 };
</pre>
<p>The <code translate="no">map</code> is an array with the characters that are currently displayed. We set up the array in <code translate="no">setupMap()</code>, and update it when the rogue is moved. <code translate="no">pX</code> and <code translate="no">pY</code> is the current position of the rogue, initially set to (5, 5). <code translate="no">WIDTH</code> and <code translate="no">HEIGHT</code> are constants specifying the dimensions of the map.</p>
<p>The <code translate="no">paintEvent()</code> function is left out of this walkthrough. We also do not discuss other code that does not concern the state machine (the <code translate="no">setupMap()</code>, <code translate="no">status()</code>, <code translate="no">setStatus()</code>, <code translate="no">movePlayer()</code>, and <code translate="no">sizeHint()</code> functions). If you wish to take a look at the code, click on the link for the <code translate="no">window.cpp</code> file at the top of this page.</p>
<h4 id="window-class-implementation">Window Class Implementation</h4>
<p>Here is the constructor of <code translate="no">Window</code>:</p>
<pre class="cpp" translate="no">
 Window<span class="operator">::</span>Window()
 {
     ...
     setupMap();
     buildMachine();
 }
</pre>
<p>Here we set up the map and statemachine. Let's proceed with the <code translate="no">buildMachine()</code> function:</p>
<pre class="cpp" translate="no">
 <span class="type">void</span> Window<span class="operator">::</span>buildMachine()
 {
     machine <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qstatemachine.html" translate="no">QStateMachine</a></span>;

     <span class="keyword">auto</span> inputState <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qstate.html" translate="no">QState</a></span>(machine);
     inputState<span class="operator">-</span><span class="operator">&gt;</span>assignProperty(<span class="keyword">this</span><span class="operator">,</span> <span class="string">&quot;status&quot;</span><span class="operator">,</span> <span class="string">&quot;Move the rogue with 2, 4, 6, and 8&quot;</span>);

     <span class="keyword">auto</span> transition <span class="operator">=</span> <span class="keyword">new</span> MovementTransition(<span class="keyword">this</span>);
     inputState<span class="operator">-</span><span class="operator">&gt;</span>addTransition(transition);
</pre>
<p>We enter <code translate="no">inputState</code> when the machine is started and from the <code translate="no">quitState</code> if the user wants to continue playing. We then set the status to a helpful reminder of how to play the game.</p>
<p>First, the <code translate="no">Movement</code> transition is added to the input state. This will enable the rogue to be moved with the keypad. Notice that we don't set a target state for the movement transition. This will cause the transition to be triggered (and the <a href="qabstracttransition.html#onTransition" translate="no">onTransition</a>() function to be invoked), but the machine will not leave the <code translate="no">inputState</code>. If we had set <code translate="no">inputState</code> as the target state, we would first have left and then entered the <code translate="no">inputState</code> again.</p>
<pre class="cpp" translate="no">
     <span class="keyword">auto</span> quitState <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qstate.html" translate="no">QState</a></span>(machine);
     quitState<span class="operator">-</span><span class="operator">&gt;</span>assignProperty(<span class="keyword">this</span><span class="operator">,</span> <span class="string">&quot;status&quot;</span><span class="operator">,</span> <span class="string">&quot;Really quit(y/n)?&quot;</span>);

     <span class="keyword">auto</span> yesTransition <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qkeyeventtransition.html" translate="no">QKeyEventTransition</a></span>(<span class="keyword">this</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span><span class="operator">::</span>KeyPress<span class="operator">,</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_Y);
     yesTransition<span class="operator">-</span><span class="operator">&gt;</span>setTargetState(<span class="keyword">new</span> <span class="type"><a href="qfinalstate.html" translate="no">QFinalState</a></span>(machine));
     quitState<span class="operator">-</span><span class="operator">&gt;</span>addTransition(yesTransition);

     <span class="keyword">auto</span> noTransition <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qkeyeventtransition.html" translate="no">QKeyEventTransition</a></span>(<span class="keyword">this</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span><span class="operator">::</span>KeyPress<span class="operator">,</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_N);
     noTransition<span class="operator">-</span><span class="operator">&gt;</span>setTargetState(inputState);
     quitState<span class="operator">-</span><span class="operator">&gt;</span>addTransition(noTransition);
</pre>
<p>When we enter <code translate="no">quitState</code>, we update the status bar of the window.</p>
<p><code translate="no">QKeyEventTransition</code> is a utility class that removes the hassle of implementing transitions for <a href="../qtgui/qkeyevent.html" translate="no">QKeyEvent</a>s. We simply need to specify the key on which the transition should trigger and the target state of the transition.</p>
<pre class="cpp" translate="no">
     <span class="keyword">auto</span> quitTransition <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qkeyeventtransition.html" translate="no">QKeyEventTransition</a></span>(<span class="keyword">this</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span><span class="operator">::</span>KeyPress<span class="operator">,</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_Q);
     quitTransition<span class="operator">-</span><span class="operator">&gt;</span>setTargetState(quitState);
     inputState<span class="operator">-</span><span class="operator">&gt;</span>addTransition(quitTransition);
</pre>
<p>The transition from <code translate="no">inputState</code> allows triggering the quit state when the player types <code translate="no">q</code>.</p>
<pre class="cpp" translate="no">
     machine<span class="operator">-</span><span class="operator">&gt;</span>setInitialState(inputState);

     connect(machine<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qstatemachine.html" translate="no">QStateMachine</a></span><span class="operator">::</span>finished<span class="operator">,</span> <a href="../qtwidgets/qapplication.html#qApp" translate="no">qApp</a><span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="../qtwidgets/qapplication.html" translate="no">QApplication</a></span><span class="operator">::</span>quit);

     machine<span class="operator">-</span><span class="operator">&gt;</span>start();
 }
</pre>
<p>The machine is set up, so it's time to start it.</p>
<h4 id="the-movementtransition-class">The MovementTransition Class</h4>
<p><code translate="no">MovementTransition</code> is triggered when the player request the rogue to be moved (by typing 2, 4, 6, or 8) when the machine is in the <code translate="no">inputState</code>.</p>
<pre class="cpp" translate="no">
 <span class="keyword">class</span> MovementTransition : <span class="keyword">public</span> <span class="type"><a href="qeventtransition.html" translate="no">QEventTransition</a></span>
 {
     Q_OBJECT

 <span class="keyword">public</span>:
     <span class="keyword">explicit</span> MovementTransition(Window <span class="operator">*</span>window)
         : <span class="type"><a href="qeventtransition.html" translate="no">QEventTransition</a></span>(window<span class="operator">,</span> <span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span><span class="operator">::</span>KeyPress)<span class="operator">,</span> window(window)
     {
     }
</pre>
<p>In the constructor, we tell <a href="qeventtransition.html" translate="no">QEventTransition</a> to only send <a href="../qtcore/qevent.html#Type-enum" translate="no">KeyPress</a> events to the <a href="qabstracttransition.html#eventTest" translate="no">eventTest</a>() function:</p>
<pre class="cpp" translate="no">
 <span class="keyword">protected</span>:
     <span class="type">bool</span> eventTest(<span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span> <span class="operator">*</span>event) override {
         <span class="keyword">if</span> (event<span class="operator">-</span><span class="operator">&gt;</span>type() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span><span class="operator">::</span>StateMachineWrapped <span class="operator">&amp;</span><span class="operator">&amp;</span>
             <span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type"><a href="qstatemachine.html" translate="no">QStateMachine</a></span><span class="operator">::</span>WrappedEvent <span class="operator">*</span><span class="operator">&gt;</span>(event)<span class="operator">-</span><span class="operator">&gt;</span>event()<span class="operator">-</span><span class="operator">&gt;</span>type() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span><span class="operator">::</span>KeyPress) {
             <span class="keyword">auto</span> wrappedEvent <span class="operator">=</span> <span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type"><a href="qstatemachine.html" translate="no">QStateMachine</a></span><span class="operator">::</span>WrappedEvent <span class="operator">*</span><span class="operator">&gt;</span>(event)<span class="operator">-</span><span class="operator">&gt;</span>event();

             <span class="keyword">auto</span> keyEvent <span class="operator">=</span> <span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type"><a href="../qtgui/qkeyevent.html" translate="no">QKeyEvent</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(wrappedEvent);
             <span class="type">int</span> key <span class="operator">=</span> keyEvent<span class="operator">-</span><span class="operator">&gt;</span>key();

             <span class="keyword">return</span> key <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_2 <span class="operator">|</span><span class="operator">|</span> key <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_8 <span class="operator">|</span><span class="operator">|</span> key <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_6 <span class="operator">|</span><span class="operator">|</span>
                    key <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_4 <span class="operator">|</span><span class="operator">|</span> key <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_Down <span class="operator">|</span><span class="operator">|</span> key <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_Up <span class="operator">|</span><span class="operator">|</span>
                    key <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_Right <span class="operator">|</span><span class="operator">|</span> key <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_Left;
         }
         <span class="keyword">return</span> <span class="keyword">false</span>;
     }
</pre>
<p>The KeyPress events come wrapped in <a href="qstatemachine-wrappedevent.html" translate="no">QStateMachine::WrappedEvent</a>s. <code translate="no">event</code> must be confirmed to be a wrapped event because Qt uses other events internally. After that, it is simply a matter of checking which key has been pressed.</p>
<p>Let's move on to the <code translate="no">onTransition()</code> function:</p>
<pre class="cpp" translate="no">
     <span class="type">void</span> onTransition(<span class="type"><a href="../qtcore/qevent.html" translate="no">QEvent</a></span> <span class="operator">*</span>event) override {
         <span class="keyword">auto</span> keyEvent <span class="operator">=</span> <span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type"><a href="../qtgui/qkeyevent.html" translate="no">QKeyEvent</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(
                 <span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type"><a href="qstatemachine.html" translate="no">QStateMachine</a></span><span class="operator">::</span>WrappedEvent <span class="operator">*</span><span class="operator">&gt;</span>(event)<span class="operator">-</span><span class="operator">&gt;</span>event());

         <span class="type">int</span> key <span class="operator">=</span> keyEvent<span class="operator">-</span><span class="operator">&gt;</span>key();
         <span class="keyword">switch</span> (key) {
             <span class="keyword">case</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_Left:
             <span class="keyword">case</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_4:
                 window<span class="operator">-</span><span class="operator">&gt;</span>movePlayer(Window<span class="operator">::</span>Left);
                 <span class="keyword">break</span>;
             <span class="keyword">case</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_Up:
             <span class="keyword">case</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_8:
                 window<span class="operator">-</span><span class="operator">&gt;</span>movePlayer(Window<span class="operator">::</span>Up);
                 <span class="keyword">break</span>;
             <span class="keyword">case</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_Right:
             <span class="keyword">case</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_6:
                 window<span class="operator">-</span><span class="operator">&gt;</span>movePlayer(Window<span class="operator">::</span>Right);
                 <span class="keyword">break</span>;
             <span class="keyword">case</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_Down:
             <span class="keyword">case</span> <span class="type"><a href="../qtcore/qt.html" translate="no">Qt</a></span><span class="operator">::</span>Key_2:
                 window<span class="operator">-</span><span class="operator">&gt;</span>movePlayer(Window<span class="operator">::</span>Down);
                 <span class="keyword">break</span>;
             <span class="keyword">default</span>:
                 ;
         }
     }
</pre>
<p>When <code translate="no">onTransition()</code> is invoked, we know that we have a <a href="../qtcore/qevent.html#Type-enum" translate="no">KeyPress</a> event with 2, 4, 6, or 8, and can ask <code translate="no">Window</code> to move the player.</p>
<h4 id="the-roguelike-tradition">The Roguelike Tradition</h4>
<p>You might have been wondering why the game features a rogue. Well, these kinds of text based dungeon exploration games date back to a game called, yes, &quot;Rogue&quot;. Although outflanked by the technology of modern 3D computer games, roguelikes have a solid community of hard-core, devoted followers.</p>
<p>Playing these games can be surprisingly addictive (despite the lack of graphics). Angband, the perhaps most well-known rougelike, is found here: <a href="http://rephial.org/" translate="no">http://rephial.org/</a>.</p>
<p><a href="https://code.qt.io/cgit/qt/qtscxml.git/tree/examples/statemachine/rogue?h=6.6" translate="no">Example project @ code.qt.io</a></p>
</div>
<!-- @@@rogue -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
