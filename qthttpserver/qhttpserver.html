<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qhttpserver.cpp -->
  <meta name="description" content="QHttpServer is a simplified API for QAbstractHttpServer and QHttpServerRouter.">
  <title>QHttpServer Class | Qt HTTP Server 6.6.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.6</a></li>
<li><a href="qthttpserver-index.html" translate="no">Qt HTTP Server</a></li>
<li><a href="qthttpserver-module.html" translate="no">C++ Classes</a></li>
<li><a href="qthttpserver-module.html" translate="no">QtHttpServer (Technical Preview)</a></li>
<li>QHttpServer</li>
<li id="buildversion"><a href="qthttpserver-index.html" translate="no">Qt 6.6&#x2e;0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title" translate="no">QHttpServer Class</h1>
<!-- $$$QHttpServer-brief -->
<p>QHttpServer is a simplified API for <a href="qabstracthttpserver.html" translate="no">QAbstractHttpServer</a> and <a href="qhttpserverrouter.html" translate="no">QHttpServerRouter</a>. <a href="#details">More...</a></p>
<!-- @@@QHttpServer -->
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QHttpServer&gt;</span></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CMake:</td><td class="memItemRight bottomAlign"> find_package(Qt6 REQUIRED COMPONENTS HttpServer) <br/>
target_link_libraries(mytarget PRIVATE Qt6::HttpServer)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += httpserver</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 6.4</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qabstracthttpserver.html" translate="no">QAbstractHttpServer</a></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Status:</td><td class="memItemRight bottomAlign"> Technical Preview<span class="status technical-preview"></span></td></tr>
</table></div>
<ul>
<li><a href="qhttpserver-members.html">List of all members, including inherited members</a></li>
</ul>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#MissingHandler-typedef" translate="no">MissingHandler</a></b></td></tr>
</table></div>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary" translate="no">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#QHttpServer" translate="no">QHttpServer</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#dtor.QHttpServer" translate="no">~QHttpServer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#afterRequest" translate="no">afterRequest</a></b>(ViewHandler &amp;&amp;<i>viewHandler</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#route" translate="no">route</a></b>(Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QHttpServerRouter *</td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#router" translate="no">router</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qhttpserver.html#setMissingHandler" translate="no">setMissingHandler</a></b>(MissingHandler <i>handler</i>)</td></tr>
</table></div>
<!-- $$$QHttpServer-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<pre class="cpp" translate="no">
 <span class="type"><a href="qhttpserver.html#QHttpServer" translate="no">QHttpServer</a></span> server;

 server<span class="operator">.</span>route(<span class="string">&quot;/&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> () {
     <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;
 });
 server<span class="operator">.</span>listen();
</pre>
</div>
<!-- @@@QHttpServer -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$MissingHandler -->
<h3 class="fn" translate="no" id="MissingHandler-typedef"><code translate="no">[alias] </code>QHttpServer::<span class="name">MissingHandler</span></h3>
<p>Type alias for std::function&lt;void(const <a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a> &amp;request, <a href="qhttpserverresponder.html" translate="no">QHttpServerResponder</a> &amp;&amp;responder)&gt;.</p>
<!-- @@@MissingHandler -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QHttpServer[overload1]$$$QHttpServerQObject* -->
<h3 class="fn" translate="no" id="QHttpServer"><code translate="no">[explicit] </code>QHttpServer::<span class="name">QHttpServer</span>(<span class="type"><a href="../qtcore/qobject.html#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Creates an instance of QHttpServer with parent <i translate="no">parent</i>.</p>
<!-- @@@QHttpServer -->
<!-- $$$~QHttpServer[overload1]$$$~QHttpServer -->
<h3 class="fn" translate="no" id="dtor.QHttpServer"><code translate="no">[virtual noexcept] </code>QHttpServer::<span class="name">~QHttpServer</span>()</h3>
<p>Destroys a <a href="qhttpserver.html" translate="no">QHttpServer</a>.</p>
<!-- @@@~QHttpServer -->
<!-- $$$afterRequest[overload1]$$$afterRequestViewHandler&& -->
<h3 class="fn" translate="no" id="afterRequest">template &lt;typename ViewHandler&gt; <span class="type">void</span> QHttpServer::<span class="name">afterRequest</span>(<span class="type">ViewHandler</span> &amp;&amp;<i>viewHandler</i>)</h3>
<p>Register a function to be run after each request.</p>
<p>The <i translate="no">viewHandler</i> argument can be a function pointer, non-mutable lambda, or any other copiable callable with const call operator. The callable can take one or two optional arguments: <code translate="no">QHttpServerResponse &amp;&amp;</code> and <code translate="no">const QHttpServerRequest &amp;</code>. If both are given, they can be in either order.</p>
<p>Examples:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qhttpserver.html#QHttpServer" translate="no">QHttpServer</a></span> server;

 <span class="comment">// Valid:</span>
 server<span class="operator">.</span>afterRequest(<span class="operator">[</span><span class="operator">]</span> (<span class="type"><a href="qhttpserverresponse.html" translate="no">QHttpServerResponse</a></span> <span class="operator">&amp;</span><span class="operator">&amp;</span>resp<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a></span> <span class="operator">&amp;</span>request) {
     <span class="keyword">return</span> std<span class="operator">::</span>move(resp);
 }
 server<span class="operator">.</span>afterRequest(<span class="operator">[</span><span class="operator">]</span> (<span class="keyword">const</span> <span class="type"><a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a></span> <span class="operator">&amp;</span>request<span class="operator">,</span> <span class="type"><a href="qhttpserverresponse.html" translate="no">QHttpServerResponse</a></span> <span class="operator">&amp;</span><span class="operator">&amp;</span>resp) {
     <span class="keyword">return</span> std<span class="operator">::</span>move(resp);
 }
 server<span class="operator">.</span>afterRequest(<span class="operator">[</span><span class="operator">]</span> (<span class="type"><a href="qhttpserverresponse.html" translate="no">QHttpServerResponse</a></span> <span class="operator">&amp;</span><span class="operator">&amp;</span>resp) { <span class="keyword">return</span> std<span class="operator">::</span>move(resp); }

 <span class="comment">// Invalid (compile time error):</span>
 <span class="comment">// resp must be passed by universal reference</span>
 server<span class="operator">.</span>afterRequest(<span class="operator">[</span><span class="operator">]</span> (<span class="type"><a href="qhttpserverresponse.html" translate="no">QHttpServerResponse</a></span> <span class="operator">&amp;</span>resp<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a></span> <span class="operator">&amp;</span>request) {
     <span class="keyword">return</span> std<span class="operator">::</span>move(resp);
 }
 <span class="comment">// request must be passed by const reference</span>
 server<span class="operator">.</span>afterRequest(<span class="operator">[</span><span class="operator">]</span> (<span class="type"><a href="qhttpserverresponse.html" translate="no">QHttpServerResponse</a></span> <span class="operator">&amp;</span><span class="operator">&amp;</span>resp<span class="operator">,</span> <span class="type"><a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a></span> <span class="operator">&amp;</span>request) {
     <span class="keyword">return</span> std<span class="operator">::</span>move(resp);
 }
</pre>
<!-- @@@afterRequest -->
<!-- $$$route[overload1]$$$routeArgs&&... -->
<h3 class="fn" translate="no" id="route">template &lt;typename Rule, typename Args&gt; <span class="type">bool</span> QHttpServer::<span class="name">route</span>(<span class="type">Args</span> &amp;&amp;... <i>args</i>)</h3>
<p>This function is just a wrapper to simplify the router API.</p>
<p>This function takes variadic arguments <i translate="no">args</i>. The last argument is a callback (<code translate="no">ViewHandler</code>). The remaining arguments are used to create a new <code translate="no">Rule</code> (the default is <a href="qhttpserverrouterrule.html" translate="no">QHttpServerRouterRule</a>). This is in turn added to the <a href="qhttpserverrouter.html" translate="no">QHttpServerRouter</a>. It returns <code translate="no">true</code> if a new rule is created, otherwise it returns <code translate="no">false</code>.</p>
<p><code translate="no">ViewHandler</code> can be a function pointer, non-mutable lambda, or any other copiable callable with const call operator. The callable can take two optional special arguments: <code translate="no">const QHttpServerRequest&amp;</code> and <code translate="no">QHttpServerResponder&amp;&amp;</code>. These special arguments must be the last in the parameter list, but in any order, and there can be none, one, or both of them present.</p>
<p>Examples:</p>
<pre class="cpp" translate="no">
 <span class="type"><a href="qhttpserver.html#QHttpServer" translate="no">QHttpServer</a></span> server;

 <span class="comment">// Valid:</span>
 server<span class="operator">.</span>route(<span class="string">&quot;test&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (<span class="keyword">const</span> <span class="type">int</span> page) { <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; });
 server<span class="operator">.</span>route(<span class="string">&quot;test&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (<span class="keyword">const</span> <span class="type">int</span> page<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a></span> <span class="operator">&amp;</span>request) { <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; });
 server<span class="operator">.</span>route(<span class="string">&quot;test&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (<span class="type"><a href="qhttpserverresponder.html" translate="no">QHttpServerResponder</a></span> <span class="operator">&amp;</span><span class="operator">&amp;</span>responder) { <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; });

 <span class="comment">// Invalid (compile time error):</span>
 server<span class="operator">.</span>route(<span class="string">&quot;test&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (<span class="keyword">const</span> <span class="type"><a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a></span> <span class="operator">&amp;</span>request<span class="operator">,</span> <span class="keyword">const</span> <span class="type">int</span> page) { <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; }); <span class="comment">// request must be last</span>
 server<span class="operator">.</span>route(<span class="string">&quot;test&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (<span class="type"><a href="qhttpserverrequest.html" translate="no">QHttpServerRequest</a></span> <span class="operator">&amp;</span>request) { <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; });      <span class="comment">// request must be passed by const reference</span>
 server<span class="operator">.</span>route(<span class="string">&quot;test&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (<span class="type"><a href="qhttpserverresponder.html" translate="no">QHttpServerResponder</a></span> <span class="operator">&amp;</span>responder) { <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; });  <span class="comment">// responder must be passed by universal reference</span>
</pre>
<p>The request handler may return <code translate="no">QFuture&lt;QHttpServerResponse&gt;</code> if asynchronous processing is desired:</p>
<pre class="cpp" translate="no">
 server<span class="operator">.</span>route(<span class="string">&quot;/feature/&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span> (<span class="type">int</span> id) {
     <span class="keyword">return</span> <span class="type">QtConcurrent</span><span class="operator">::</span>run(<span class="operator">[</span><span class="operator">]</span> () {
         <span class="keyword">return</span> <span class="type"><a href="qhttpserverresponse.html" translate="no">QHttpServerResponse</a></span>(<span class="string">&quot;the future is coming&quot;</span>);
     });
 });
</pre>
<p><b>See also </b><a href="qhttpserverrouter.html#addRule" translate="no">QHttpServerRouter::addRule</a>.</p>
<!-- @@@route -->
<!-- $$$router[overload1]$$$router -->
<h3 class="fn" translate="no" id="router"><span class="type"><a href="qhttpserverrouter.html" translate="no">QHttpServerRouter</a></span> *QHttpServer::<span class="name">router</span>()</h3>
<p>Returns the router object.</p>
<!-- @@@router -->
<!-- $$$setMissingHandler[overload1]$$$setMissingHandlerMissingHandler -->
<h3 class="fn" translate="no" id="setMissingHandler"><span class="type">void</span> QHttpServer::<span class="name">setMissingHandler</span>(<span class="type"><a href="qhttpserver.html#MissingHandler-typedef" translate="no">MissingHandler</a></span> <i>handler</i>)</h3>
<p>Set a handler to call for unhandled paths.</p>
<p>The invocable passed as <i translate="no">handler</i> will be invoked for each request that cannot be handled by any of registered route handlers. Passing a default-constructed std::function resets the handler to the default one that produces replies with status 404 Not Found.</p>
<!-- @@@setMissingHandler -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2023 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
