<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- definetypes.qdoc -->
  <meta name="description" content="Description of how a QML document is a reusable type definition">
  <title>Defining Object Types through QML Documents | Qt QML 6.6.2</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html" translate="no">Qt 6.6</a></li>
<li><a href="qtqml-index.html" translate="no">Qt QML</a></li>
<li>Defining Object Types through QML Documents</li>
<li id="buildversion"><a href="qtqml-index.html" translate="no">Qt 6.6.2 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3 id="toc">Contents</h3>
<ul>
<li class="level1"><a href="#defining-an-object-type-with-a-qml-file">Defining an Object Type with a QML File</a></li>
<li class="level2"><a href="#naming-custom-qml-object-types">Naming Custom QML Object Types</a></li>
<li class="level2"><a href="#custom-qml-type-definition">Custom QML Type Definition</a></li>
<li class="level2"><a href="#inline-components">Inline Components</a></li>
<li class="level2"><a href="#importing-types-defined-outside-the-current-directory">Importing Types Defined Outside the Current Directory</a></li>
<li class="level1"><a href="#accessible-attributes-of-custom-types">Accessible Attributes of Custom Types</a></li>
<li class="level1"><a href="#pragmas">Pragmas</a></li>
<li class="level2"><a href="#singleton">Singleton</a></li>
<li class="level2"><a href="#listpropertyassignbehavior">ListPropertyAssignBehavior</a></li>
<li class="level2"><a href="#componentbehavior">ComponentBehavior</a></li>
<li class="level2"><a href="#functionsignaturebehavior">FunctionSignatureBehavior</a></li>
<li class="level2"><a href="#valuetypebehavior">ValueTypeBehavior</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Defining Object Types through QML Documents</h1>
<!-- $$$qtqml-documents-definetypes.html-description -->
<div class="descr" id="details">
<p>One of the core features of QML is that it enables QML object types to be easily defined in a lightweight manner through QML documents to suit the needs of individual QML applications. The standard <a href="../qtquick/qtquick-index.html" translate="no">Qt Quick</a> module provides various types like <a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a>, <a href="../qtquick/qml-qtquick-text.html" translate="no">Text</a> and <a href="../qtquick/qml-qtquick-image.html" translate="no">Image</a> for building a QML application; beyond these, you can easily define your own QML types to be reused within your application. This ability to create your own types forms the building blocks of any QML application.</p>
<h2 id="defining-an-object-type-with-a-qml-file">Defining an Object Type with a QML File</h2>
<h3 id="naming-custom-qml-object-types">Naming Custom QML Object Types</h3>
<p>To create an object type, a QML document should be placed into a text file named as <i>&lt;TypeName&gt;.qml</i> where <i>&lt;TypeName&gt;</i> is the desired name of the type. The type name has the following requirements:</p>
<ul>
<li>It must be comprised of alphanumeric characters or underscores.</li>
<li>It must begin with an uppercase letter.</li>
</ul>
<p>This document is then automatically recognized by the engine as a definition of a QML type. Additionally, a type defined in this manner is automatically made available to other QML files within the same local directory as the engine searches within the immediate directory when resolving QML type names.</p>
<div class="admonition note">
<p><b>Note: </b>The QML engine does not automatically search remote directories this way. You have to add a qmldir file if your documents are loaded over the network. See <a href="qtqml-syntax-directoryimports.html" translate="no">Importing QML Document Directories</a>.</p>
</div>
<h3 id="custom-qml-type-definition">Custom QML Type Definition</h3>
<p>For example, below is a document that declares a <a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a> with a child <a href="../qtquick/qml-qtquick-mousearea.html" translate="no">MouseArea</a>. The document has been saved to file named <code translate="no">SquareButton.qml</code>:</p>
<pre class="qml" translate="no">
 <span class="comment">// SquareButton.qml</span>
 import QtQuick 2.0

 <span class="type"><a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
     property <span class="type"><a href="qml-int.html" translate="no">int</a></span> <span class="name">side</span>: <span class="number">100</span>
     <span class="name">width</span>: <span class="name">side</span>; <span class="name">height</span>: <span class="name">side</span>
     <span class="name">color</span>: <span class="string">&quot;red&quot;</span>

     <span class="type"><a href="../qtquick/qml-qtquick-mousearea.html" translate="no">MouseArea</a></span> {
         <span class="name">anchors</span>.fill: <span class="name">parent</span>
         <span class="name">onClicked</span>: <span class="name">console</span>.<span class="name">log</span>(<span class="string">&quot;Button clicked!&quot;</span>)
     }
 }
</pre>
<p>Since the file is named <code translate="no">SquareButton.qml</code>, <b>this can now be used as a type named <code translate="no">SquareButton</code> by any other QML file within the same directory</b>. For example, if there was a <code translate="no">myapplication.qml</code> file in the same directory, it could refer to the <code translate="no">SquareButton</code> type:</p>
<pre class="qml" translate="no">
 <span class="comment">// myapplication.qml</span>
 import QtQuick 2.0

 <span class="type">SquareButton</span> {}
</pre>
<p class="centerAlign"><img src="images/documents-definetypes-simple.png" alt="" /></p><p>This creates a 100 x 100 red <a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a> with an inner <a href="../qtquick/qml-qtquick-mousearea.html" translate="no">MouseArea</a>, as defined in <code translate="no">SquareButton.qml</code>. When this <code translate="no">myapplication.qml</code> document is loaded by the engine, it loads the SquareButton.qml document as a component and instantiates it to create a <code translate="no">SquareButton</code> object.</p>
<p>The <code translate="no">SquareButton</code> type encapsulates the tree of QML objects declared in <code translate="no">SquareButton.qml</code>. When the QML engine instantiates a <code translate="no">SquareButton</code> object from this type, it is instantiating an object from the <a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a> tree declared in <code translate="no">SquareButton.qml</code>.</p>
<div class="admonition note">
<p><b>Note: </b>the letter case of the file name is significant on some (notably UNIX) filesystems. It is recommended the file name case matches the case of the desired QML type name exactly - for example, <code translate="no">Box.qml</code> and not <code translate="no">BoX.qml</code> - regardless of the platform to which the QML type will be deployed.</p>
</div>
<h3 id="inline-components">Inline Components</h3>
<p>Sometimes, it can be inconvenient to create a new file for a type, for instance when reusing a small delegate in multiple views. If you don't actually need to expose the type, but only need to create an instance, <a href="qml-qtqml-component.html" translate="no">Component</a> is an option. But if you want to declare properties with the component types, or if you want to use it in multiple files, <code translate="no">Component</code> is not an option. In that case, you can use <i>inline components</i>. Inline components declare a new component inside of a file. The syntax for that is</p>
<pre class="cpp" translate="no">
 component <span class="operator">&lt;</span>component name<span class="operator">&gt;</span> : BaseType {
     <span class="comment">// declare properties and bindings here</span>
 }
</pre>
<p>Inside the file which declares the inline component, the type can be referenced simply by its name.</p>
<pre class="qml" translate="no">
 <span class="comment">// Images.qml</span>
 import QtQuick

 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     component LabeledImage: <span class="type"><a href="../qtquick/qml-qtquick-column.html" translate="no">Column</a></span> {
         property <span class="type">alias</span> <span class="name">source</span>: <span class="name">image</span>.<span class="name">source</span>
         property <span class="type">alias</span> <span class="name">caption</span>: <span class="name">text</span>.<span class="name">text</span>

         <span class="type"><a href="../qtquick/qml-qtquick-image.html" translate="no">Image</a></span> {
             <span class="name">id</span>: <span class="name">image</span>
             <span class="name">width</span>: <span class="number">50</span>
             <span class="name">height</span>: <span class="number">50</span>
         }
         <span class="type"><a href="../qtquick/qml-qtquick-text.html" translate="no">Text</a></span> {
             <span class="name">id</span>: <span class="name">text</span>
             <span class="name">font</span>.bold: <span class="number">true</span>
         }
     }

     <span class="type"><a href="../qtquick/qml-qtquick-row.html" translate="no">Row</a></span> {
         <span class="type">LabeledImage</span> {
             <span class="name">id</span>: <span class="name">before</span>
             <span class="name">source</span>: <span class="string">&quot;before.png&quot;</span>
             <span class="name">caption</span>: <span class="string">&quot;Before&quot;</span>
         }
         <span class="type">LabeledImage</span> {
             <span class="name">id</span>: <span class="name">after</span>
             <span class="name">source</span>: <span class="string">&quot;after.png&quot;</span>
             <span class="name">caption</span>: <span class="string">&quot;After&quot;</span>
         }
     }
     property <span class="type">LabeledImage</span> <span class="name">selectedImage</span>: <span class="name">before</span>
 }
</pre>
<p>In other files, it has to be prefixed with the name of its containing component.</p>
<pre class="qml" translate="no">
 <span class="comment">// LabeledImageBox.qml</span>
 import QtQuick

 <span class="type"><a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
     property <span class="type">alias</span> <span class="name">caption</span>: <span class="name">image</span>.<span class="name">caption</span>
     property <span class="type">alias</span> <span class="name">source</span>: <span class="name">image</span>.<span class="name">source</span>
     <span class="name">border</span>.width: <span class="number">2</span>
     <span class="name">border</span>.color: <span class="string">&quot;black&quot;</span>
     <span class="type">Images</span>.LabeledImage {
         <span class="name">id</span>: <span class="name">image</span>
     }
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>Inline components don't share their scope with the component they are declared in. In the following example, when <code translate="no">A.MyInlineComponent</code> in file B.qml gets created, a ReferenceError will occur, as <code translate="no">root</code> does not exist as an id in B.qml. It is therefore advisable not to reference objects in an inline component which are not part of it.</p>
</div>
<pre class="qml" translate="no">
 <span class="comment">// A.qml</span>
 import QtQuick

 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="name">id</span>: <span class="name">root</span>
     property <span class="type"><a href="qml-string.html" translate="no">string</a></span> <span class="name">message</span>: <span class="string">&quot;From A&quot;</span>
     component MyInlineComponent : <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
         <span class="name">Component</span>.onCompleted: <span class="name">console</span>.<span class="name">log</span>(<span class="name">root</span>.<span class="name">message</span>)
     }
 }
 <span class="comment">// B.qml</span>
 import QtQuick

 <span class="type"><a href="../qtquick/qml-qtquick-item.html" translate="no">Item</a></span> {
     <span class="type">A</span>.MyInlineComponent {}
 }
</pre>
<div class="admonition note">
<p><b>Note: </b>Inline components cannot be nested.</p>
</div>
<h3 id="importing-types-defined-outside-the-current-directory">Importing Types Defined Outside the Current Directory</h3>
<p>If <code translate="no">SquareButton.qml</code> was not in the same directory as <code translate="no">myapplication.qml</code>, the <code translate="no">SquareButton</code> type would need to be specifically made available through an <i>import</i> statement in <code translate="no">myapplication.qml</code>. It could be imported from a relative path on the file system, or as an installed module; see <a href="qtqml-modules-topic.html" translate="no">module</a> for more details.</p>
<h2 id="accessible-attributes-of-custom-types">Accessible Attributes of Custom Types</h2>
<p>The <b>root object</b> definition in a .qml file <b>defines the attributes that are available for a QML type</b>. All properties, signals and methods that belong to this root object - whether they are custom declared, or come from the QML type of the root object - are externally accessible and can be read and modified for objects of this type.</p>
<p>For example, the root object type in the <code translate="no">SquareButton.qml</code> file above is <a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a>. This means any properties defined by the <a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a> type can be modified for a <code translate="no">SquareButton</code> object. The code below defines three <code translate="no">SquareButton</code> objects with customized values for some of the properties of the root <a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a> object of the <code translate="no">SquareButton</code> type:</p>
<pre class="qml" translate="no">
 <span class="comment">// application.qml</span>
 import QtQuick 2.0

 <span class="type"><a href="../qtquick/qml-qtquick-column.html" translate="no">Column</a></span> {
     <span class="type">SquareButton</span> { <span class="name">side</span>: <span class="number">50</span> }
     <span class="type">SquareButton</span> { <span class="name">x</span>: <span class="number">50</span>; <span class="name">color</span>: <span class="string">&quot;blue&quot;</span> }
     <span class="type">SquareButton</span> { <span class="name">radius</span>: <span class="number">10</span> }
 }
</pre>
<p class="centerAlign"><img src="images/documents-definetypes-attributes.png" alt="" /></p><p>The attributes that are accessible to objects of the custom QML type include any <a href="qtqml-syntax-objectattributes.html#defining-property-attributes" translate="no">custom properties</a>, <a href="qtqml-syntax-objectattributes.html#defining-method-attributes" translate="no">methods</a> and <a href="qtqml-syntax-objectattributes.html#defining-signal-attributes" translate="no">signals</a> that have additionally been defined for an object. For example, suppose the <a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a> in <code translate="no">SquareButton.qml</code> had been defined as follows, with additional properties, methods and signals:</p>
<pre class="qml" translate="no">
 <span class="comment">// SquareButton.qml</span>
 import QtQuick 2.0

 <span class="type"><a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a></span> {
     <span class="name">id</span>: <span class="name">root</span>

     property <span class="type"><a href="qml-bool.html" translate="no">bool</a></span> <span class="name">pressed</span>: <span class="name">mouseArea</span>.<span class="name">pressed</span>

     signal <span class="type">buttonClicked</span>(real xPos, real yPos)

     <span class="keyword">function </span><span class="name">randomizeColor</span>() {
         <span class="name">root</span>.<span class="name">color</span> <span class="operator">=</span> <span class="name">Qt</span>.<span class="name">rgba</span>(<span class="name">Math</span>.<span class="name">random</span>(), <span class="name">Math</span>.<span class="name">random</span>(), <span class="name">Math</span>.<span class="name">random</span>(), <span class="number">1</span>)
     }

     property <span class="type"><a href="qml-int.html" translate="no">int</a></span> <span class="name">side</span>: <span class="number">100</span>
     <span class="name">width</span>: <span class="name">side</span>; <span class="name">height</span>: <span class="name">side</span>
     <span class="name">color</span>: <span class="string">&quot;red&quot;</span>

     <span class="type"><a href="../qtquick/qml-qtquick-mousearea.html" translate="no">MouseArea</a></span> {
         <span class="name">id</span>: <span class="name">mouseArea</span>
         <span class="name">anchors</span>.fill: <span class="name">parent</span>
         <span class="name">onClicked</span>: (<span class="keyword"></span>mouse)=&gt; <span class="keyword"></span><span class="name">root</span>.<span class="name">buttonClicked</span>(<span class="name">mouse</span>.<span class="name">x</span>, <span class="name">mouse</span>.<span class="name">y</span>)
     }
 }
</pre>
<p>Any <code translate="no">SquareButton</code> object could make use of the <code translate="no">pressed</code> property, <code translate="no">buttonClicked</code> signal and <code translate="no">randomizeColor()</code> method that have been added to the root <a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a>:</p>
<pre class="qml" translate="no">
 <span class="comment">// application.qml</span>
 import QtQuick 2.0

 <span class="type">SquareButton</span> {
     <span class="name">id</span>: <span class="name">squareButton</span>

     <span class="name">onButtonClicked</span>: (<span class="keyword"></span>xPos, yPos)=&gt; {
         <span class="name">console</span>.<span class="name">log</span>(<span class="string">&quot;Clicked&quot;</span>, <span class="name">xPos</span>, <span class="name">yPos</span>)
         <span class="name">randomizeColor</span>()
     }

     <span class="type"><a href="../qtquick/qml-qtquick-text.html" translate="no">Text</a></span> { <span class="name">text</span>: <span class="name">squareButton</span>.<span class="name">pressed</span> ? <span class="string">&quot;Down&quot;</span> : <span class="string">&quot;Up&quot;</span> }
 }
</pre>
<p>Note that any of the <code translate="no">id</code> values defined in <code translate="no">SquareButton.qml</code> are not accessible to <code translate="no">SquareButton</code> objects, as id values are only accessible from within the component scope in which a component is declared. The <code translate="no">SquareButton</code> object definition above cannot refer to <code translate="no">mouseArea</code> in order to refer to the <a href="../qtquick/qml-qtquick-mousearea.html" translate="no">MouseArea</a> child, and if it had an <code translate="no">id</code> of <code translate="no">root</code> rather than <code translate="no">squareButton</code>, this would not conflict with the <code translate="no">id</code> of the same value for the root object defined in <code translate="no">SquareButton.qml</code> as the two would be declared within separate scopes.</p>
<h2 id="pragmas">Pragmas</h2>
<p>You can prepend global instructions to a QML document using the <code translate="no">pragma</code> keyword. The following pragmas are supported:</p>
<h3 id="singleton">Singleton</h3>
<p><code translate="no">pragma Singleton</code> declares the component defined in the QML document as singleton. Singletons are created only once per QML engine. In order to use a QML-declared singleton you also have to register it with its module. See <a href="qt-target-qml-sources.html" translate="no">qt_target_qml_sources</a> for how to do this with CMake.</p>
<h3 id="listpropertyassignbehavior">ListPropertyAssignBehavior</h3>
<p>With this pragma you can define how assignments to list properties shall be handled in components defined in the QML document. By default, assigning to a list property appends to the list. You can explicitly request this behavior using the value <code translate="no">Append</code>. Alternatively, you can request the contents of list properties to always be replaced using <code translate="no">Replace</code>, or replaced if the property is not the default property using <code translate="no">ReplaceIfNotDefault</code>. For example:</p>
<pre class="qml" translate="no">
 pragma ListPropertyAssignBehavior: ReplaceIfNotDefault
</pre>
<p>The same declaration can also be given for C++-defined types. See <a href="qqmllistproperty.html#QML_LIST_PROPERTY_ASSIGN_BEHAVIOR_APPEND" translate="no">QML_LIST_PROPERTY_ASSIGN_BEHAVIOR_APPEND</a>, <a href="qqmllistproperty.html#QML_LIST_PROPERTY_ASSIGN_BEHAVIOR_REPLACE" translate="no">QML_LIST_PROPERTY_ASSIGN_BEHAVIOR_REPLACE</a>, and <a href="qqmllistproperty.html#QML_LIST_PROPERTY_ASSIGN_BEHAVIOR_REPLACE_IF_NOT_DEFAULT" translate="no">QML_LIST_PROPERTY_ASSIGN_BEHAVIOR_REPLACE_IF_NOT_DEFAULT</a></p>
<h3 id="componentbehavior">ComponentBehavior</h3>
<p>You may have multiple components defined in the same QML file. The root scope of the QML file is a component, and you may additionally have elements of type <a href="qqmlcomponent.html" translate="no">QQmlComponent</a>, explicitly or implicitly created as properties, or inline components. Those components are nested. Each of the inner components is within one specific outer component. Most of the time, IDs defined in an outer component are accessible within all its nested inner components. You can, however, create elements from a component in any a different context, with different IDs available. Doing so breaks the assumption that outer IDs are available. Therefore, the engine and the QML tooling cannot generally know in advance what type, if any, such IDs will resolve to at run time.</p>
<p>With the ComponentBehavior pragma you can restrict all inner components defined in a file to only create objects within their original context. If a component is bound to its context, you can safely use IDs from outer components in the same file within the component. QML tooling will then assume the outer IDs with their specific types to be available.</p>
<p>In order to bind the components to their context specify the <code translate="no">Bound</code> argument:</p>
<pre class="qml" translate="no">
 pragma ComponentBehavior: Bound
</pre>
<p>This implies that, in case of name clashes, IDs defined outside a bound component override local properties of objects created from the component. Otherwise it wouldn't actually be safe to use the IDs since later versions of a module might add more properties to the component. If the component is not bound, local properties override IDs defined outside the component, but not IDs defined inside the component.</p>
<p>The example below prints the <i>r</i> property of the <a href="../qtquick/qml-qtquick-listview.html" translate="no">ListView</a> object with the id <i>color</i>, not the <i>r</i> property of the rectangle's color.</p>
<pre class="qml" translate="no">
 pragma ComponentBehavior: Bound
 import QtQuick

 <span class="type"><a href="../qtquick/qml-qtquick-listview.html" translate="no">ListView</a></span> {
     <span class="name">id</span>: <span class="name">color</span>
     property <span class="type"><a href="qml-int.html" translate="no">int</a></span> <span class="name">r</span>: <span class="number">12</span>
     <span class="name">model</span>: <span class="number">1</span>
     <span class="name">delegate</span>: <span class="name">Rectangle</span> {
         <span class="name">Component</span>.onCompleted: <span class="name">console</span>.<span class="name">log</span>(<span class="name">color</span>.<span class="name">r</span>)
     }
 }
</pre>
<p>The default value of <code translate="no">ComponentBehavior</code> is <code translate="no">Unbound</code>. You can also specify it explicitly. In a future version of Qt the default will change to <code translate="no">Bound</code>.</p>
<p>Delegate components bound to their context don't receive their own private contexts on instantiation. This means that model data can only be passed via <a href="qtqml-syntax-objectattributes.html#required-properties" translate="no">required properties</a> in this case. Passing model data via context properties will not work. This concerns delegates to e.g. <a href="../qtqmlmodels/qml-qtqml-models-instantiator.html" translate="no">Instantiator</a>, <a href="../qtquick/qml-qtquick-repeater.html" translate="no">Repeater</a>, <a href="../qtquick/qml-qtquick-listview.html" translate="no">ListView</a>, <a href="../qtquick/qml-qtquick-tableview.html" translate="no">TableView</a>, <a href="../qtquick/qml-qtquick-gridview.html" translate="no">GridView</a>, <a href="../qtquick/qml-qtquick-treeview.html" translate="no">TreeView</a> and in general anything that uses <a href="../qtqmlmodels/qml-qtqml-models-delegatemodel.html" translate="no">DelegateModel</a> internally.</p>
<p>For example, the following will <i>not</i> work:</p>
<pre class="qml" translate="no">
 pragma ComponentBehavior: Bound
 import QtQuick

 <span class="type"><a href="../qtquick/qml-qtquick-listview.html" translate="no">ListView</a></span> {
     <span class="name">delegate</span>: <span class="name">Rectangle</span> {
         <span class="name">color</span>: <span class="name">model</span>.<span class="name">myColor</span>
     }
 }
</pre>
<p>The <code translate="no">delegate</code> property of <a href="../qtquick/qml-qtquick-listview.html" translate="no">ListView</a> is a component. Therefore, a <a href="qml-qtqml-component.html" translate="no">Component</a> is implicitly created around the <a href="../qtquick/qml-qtquick-rectangle.html" translate="no">Rectangle</a> here. That component is bound to its context. It doesn't receive the context property <code translate="no">model</code> provided by <a href="../qtquick/qml-qtquick-listview.html" translate="no">ListView</a>. To make it work, you'd have to write it this way:</p>
<pre class="qml" translate="no">
 pragma ComponentBehavior: Bound
 import QtQuick

 <span class="type"><a href="../qtquick/qml-qtquick-listview.html" translate="no">ListView</a></span> {
     <span class="name">delegate</span>: <span class="name">Rectangle</span> {
         required property <span class="type"><a href="../qtquick/qml-color.html" translate="no">color</a></span> <span class="name">myColor</span>
         <span class="name">color</span>: <span class="name">myColor</span>
     }
 }
</pre>
<p>You can nest components in a QML file. The pragma holds for all components in the file, no matter how deeply nested.</p>
<h3 id="functionsignaturebehavior">FunctionSignatureBehavior</h3>
<p>With this pragma you can change the way type annotations on functions are handled. By default the interpreter and JIT ignore type annotations, but the <a href="qtqml-qml-script-compiler.html" translate="no">QML script compiler</a> enforces them when compiling to C++.</p>
<p>Specifying <code translate="no">Enforced</code> as value makes sure the type annotations are always enforced. The resulting type coercions increase the overhead of calling typed JavaScript functions.</p>
<p>Specifying <code translate="no">Ignored</code> as value makes the <a href="qtqml-qml-script-compiler.html" translate="no">QML script compiler</a> ignore any JavaScript functions when compiling the document to C++. This means less code is compiled to C++ ahead of time, and more code has to be interpreted or JIT-compiled.</p>
<h3 id="valuetypebehavior">ValueTypeBehavior</h3>
<p>With this pragma you can change the way value types and sequences are handled.</p>
<p>Usually lower case names cannot be type names in JavaScript code. This is a problem because value type names are lower case. You can specify <code translate="no">Addressable</code> as value for this pragma to change this. If <code translate="no">Addressable</code> is specified a JavaScript can be explicitly coerced to a specific, named, value type. This is done using the <code translate="no">as</code> operator, like you would do with object types. Furthermore, you can also check for value types using the <code translate="no">instanceof</code> operator:</p>
<pre class="qml" translate="no">
 pragma ValueTypeBehavior: Addressable
 import QtQml

 <span class="type"><a href="qml-qtqml-qtobject.html" translate="no">QtObject</a></span> {
     property <span class="type"><a href="qml-var.html" translate="no">var</a></span> <span class="name">a</span>
     property <span class="type"><a href="qml-real.html" translate="no">real</a></span> <span class="name">b</span>: (<span class="name">a</span> <span class="operator">as</span> <span class="name">rect</span>).<span class="name">x</span>
     property <span class="type"><a href="qml-bool.html" translate="no">bool</a></span> <span class="name">c</span>: <span class="name">a</span> <span class="operator">instanceof</span> <span class="name">rect</span>

     property <span class="type"><a href="qml-var.html" translate="no">var</a></span> <span class="name">rect</span> <span class="comment">// inaccessible. &quot;rect&quot; is a type name.</span>
 }
</pre>
<p>If the type does not match, casting returns <code translate="no">undefined</code>. <code translate="no">instanceof</code> only checks for inheritance, not for all possible type coercions. So, for example, a <a href="../qtcore/qrect.html" translate="no">QRect</a> is not a <code translate="no">rect</code> value type since <code translate="no">rect</code> is <a href="../qtcore/qrectf.html" translate="no">QRectF</a> in C++, and therefore not related by inheritance. With <code translate="no">as</code> you can cast to any type compatible via coercion.</p>
<p>Since <code translate="no">rect</code> in the above example is now a type name, it will shadow any properties called <code translate="no">rect</code>.</p>
<p>Explicitly casting to the desired type helps tooling. It can allow the <a href="qtqml-qtquick-compiler-tech.html" translate="no">Qt Quick Compiler</a> generate efficient code where it otherwise would not be able to. You can use <a href="../qtquick/qtquick-tool-qmllint.html" translate="no">qmllint</a> to find such occurrences.</p>
<p>There is also a <code translate="no">Inaddressable</code> value you can use to explicitly specify the default behavior.</p>
<p>Value types and sequences are generally treated as references. This means, if you retrieve a value type instance from a property into a local value, and then change the local value, the original property is also changed. Furthermore, if you write the original property explicitly, the local value is also updated. This behavior is rather unintuitive in many places, and you should not rely on it. The <code translate="no">Copy</code> and <code translate="no">Reference</code> values for the <code translate="no">ValueTypeBehavior</code> pragma are experimental options to change this behavior. You should not use them. Specifying <code translate="no">Copy</code> causes all value types to be treated as actual copies. Specifying <code translate="no">Reference</code> explicitly states the default behavior.</p>
<p>Rather than using <code translate="no">Copy</code> you should explicitly re-load references to value types and sequences any time they can have been affected by side effects. Side effects can happen whenever you call a function or imperatively set a property. <a href="../qtquick/qtquick-tool-qmllint.html" translate="no">qmllint</a> provides guidance on this. For example, in the following code the variable <code translate="no">f</code> is affected by side effects after writing <code translate="no">width</code>. This is because there may be a binding in a derived type or in a <code translate="no">Binding</code> element that updates <code translate="no">font</code> when <code translate="no">width</code> is changed.</p>
<pre class="qml" translate="no">
 import QtQuick
 <span class="type"><a href="../qtquick/qml-qtquick-text.html" translate="no">Text</a></span> {
     <span class="keyword">function </span><span class="name">a</span>() : real {
         var f = <span class="name">font</span>;
         <span class="name">width</span> <span class="operator">=</span> <span class="name">f</span>.<span class="name">pixelSize</span>;
         <span class="keyword">return</span> <span class="name">f</span>.<span class="name">pointSize</span>;
     }
 }
</pre>
<p>In order to address this, you can avoid holding <code translate="no">f</code> across the write operation on <code translate="no">width</code>:</p>
<pre class="qml" translate="no">
 import QtQuick
 <span class="type"><a href="../qtquick/qml-qtquick-text.html" translate="no">Text</a></span> {
     <span class="keyword">function </span><span class="name">a</span>() : real {
         var f = <span class="name">font</span>;
         <span class="name">width</span> <span class="operator">=</span> <span class="name">f</span>.<span class="name">pixelSize</span>;
         <span class="name">f</span> <span class="operator">=</span> <span class="name">font</span>;
         <span class="keyword">return</span> <span class="name">f</span>.<span class="name">pointSize</span>;
     }
 }
</pre>
<p>This, in turn can be shortened to:</p>
<pre class="qml" translate="no">
 import QtQuick
 <span class="type"><a href="../qtquick/qml-qtquick-text.html" translate="no">Text</a></span> {
     <span class="keyword">function </span><span class="name">a</span>() : real {
         <span class="name">width</span> <span class="operator">=</span> <span class="name">font</span>.<span class="name">pixelSize</span>;
         <span class="keyword">return</span> <span class="name">font</span>.<span class="name">pointSize</span>;
     }
 }
</pre>
<p>You might assume that re-retrieving the <code translate="no">font</code> property is costly, but actually the QML engine automatically refreshes value type references each time you read from them. So this is not more expensive than the first version, but a clearer way to express the same operations.</p>
</div>
<p><b>See also </b><a href="qtqml-javascript-hostenvironment.html#type-annotations-and-assertions" translate="no">Type annotations and assertions</a> and <a href="qtqml-javascript-hostenvironment.html#type-annotations-and-assertions" translate="no">Type annotations and assertions</a>.</p>
<!-- @@@qtqml-documents-definetypes.html -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2024 <span translate="no">The Qt Company Ltd.</span>
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the <span translate="no">Free Software Foundation</span>.<br/>    <span translate="no">Qt</span> and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of <span translate="no">The Qt Company Ltd.</span> in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>
</div>
</body>
</html>
